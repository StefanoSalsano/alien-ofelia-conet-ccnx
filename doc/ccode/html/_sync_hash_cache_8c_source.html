<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Content-Centric Networking in C: sync/SyncHashCache.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_a2ce97d05a9d430b2851eef455e009f7.html">sync</a>
  </div>
</div>
<div class="contents">
<h1>SyncHashCache.c</h1><a href="_sync_hash_cache_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**</span>
<a name="l00002"></a>00002 <span class="comment"> * @file sync/SyncHashCache.c</span>
<a name="l00003"></a>00003 <span class="comment"> *  </span>
<a name="l00004"></a>00004 <span class="comment"> * Part of CCNx Sync.</span>
<a name="l00005"></a>00005 <span class="comment"> */</span>
<a name="l00006"></a>00006 <span class="comment">/*</span>
<a name="l00007"></a>00007 <span class="comment"> * Copyright (C) 2011-2012 Palo Alto Research Center, Inc.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> * This library is free software; you can redistribute it and/or modify it</span>
<a name="l00010"></a>00010 <span class="comment"> * under the terms of the GNU Lesser General Public License version 2.1</span>
<a name="l00011"></a>00011 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00012"></a>00012 <span class="comment"> * This library is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<a name="l00015"></a>00015 <span class="comment"> * Lesser General Public License for more details. You should have received</span>
<a name="l00016"></a>00016 <span class="comment"> * a copy of the GNU Lesser General Public License along with this library;</span>
<a name="l00017"></a>00017 <span class="comment"> * if not, write to the Free Software Foundation, Inc., 51 Franklin Street,</span>
<a name="l00018"></a>00018 <span class="comment"> * Fifth Floor, Boston, MA 02110-1301 USA.</span>
<a name="l00019"></a>00019 <span class="comment"> */</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;<a class="code" href="_sync_base_8h.html" title="Part of CCNx Sync.">SyncBase.h</a>&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="_sync_hash_cache_8h.html" title="Part of CCNx Sync.">SyncHashCache.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="_sync_node_8h.html" title="Part of CCNx Sync.">SyncNode.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="_sync_root_8h.html" title="Part of CCNx Sync.">SyncRoot.h</a>&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="_sync_util_8h.html" title="Part of CCNx Sync.">SyncUtil.h</a>&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;strings.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="ccn_8h.html" title="This is the low-level interface for CCNx clients.">ccn/ccn.h</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="loglevels_8h.html" title="Part of the CCNx C Library.">ccn/loglevels.h</a>&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *
<a name="l00033"></a><a class="code" href="_sync_hash_cache_8c.html#a64b5a732b2fbe58f83c67e710ff9275d">00033</a> <a class="code" href="_sync_hash_cache_8c.html#a64b5a732b2fbe58f83c67e710ff9275d">localFreeEntry</a>(<span class="keyword">struct</span> <a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *ce) {
<a name="l00034"></a>00034     ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#ae4e3f5be0c085331268dc1ee724f9742" title="the next entry in the hash chain">next</a> = NULL;
<a name="l00035"></a>00035     <span class="keywordflow">if</span> (ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a94d0a088221aef50aace5c203075d686" title="the local node in memory">ncL</a> != NULL) <a class="code" href="_sync_node_8c.html#adbec8777422ca7e8c80714aa77afb5a4" title="Decrements the reference count.">SyncNodeDecRC</a>(ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a94d0a088221aef50aace5c203075d686" title="the local node in memory">ncL</a>);
<a name="l00036"></a>00036     <span class="keywordflow">if</span> (ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#ac36cf9f951468f67bd6bdb6afba90636" title="some remote node in memory">ncR</a> != NULL) <a class="code" href="_sync_node_8c.html#adbec8777422ca7e8c80714aa77afb5a4" title="Decrements the reference count.">SyncNodeDecRC</a>(ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#ac36cf9f951468f67bd6bdb6afba90636" title="some remote node in memory">ncR</a>);
<a name="l00037"></a>00037     <span class="keywordflow">if</span> (ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#aba3a8329dde03169d4bb1f369b2d78cf" title="hash used to reach this entry">hash</a> != NULL) <a class="code" href="charbuf_8h.html#a699030e7cb3c51ca2cde46af0ba6e1bb">ccn_charbuf_destroy</a>(&amp;ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#aba3a8329dde03169d4bb1f369b2d78cf" title="hash used to reach this entry">hash</a>);
<a name="l00038"></a>00038     free(ce);
<a name="l00039"></a>00039     <span class="keywordflow">return</span> NULL;
<a name="l00040"></a>00040 }
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *
<a name="l00043"></a><a class="code" href="_sync_hash_cache_8h.html#a15c6eafb71bb631fde85a2424f5ac449">00043</a> <a class="code" href="_sync_hash_cache_8c.html#a15c6eafb71bb631fde85a2424f5ac449" title="lookup a full hash in a hash table (raw contents, no tag)">SyncHashLookup</a>(<span class="keyword">struct</span> <a class="code" href="struct_sync_hash_cache_head.html">SyncHashCacheHead</a> *<a class="code" href="struct_sync_hash_cache_entry.html#a17d9349c3a973e5322e76c116a4c5b6d" title="the parent head">head</a>,
<a name="l00044"></a>00044                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *xp, ssize_t xs) {
<a name="l00045"></a>00045     <span class="keywordflow">if</span> (xp == NULL || xs &lt;= 0) <span class="keywordflow">return</span> NULL;
<a name="l00046"></a>00046     uint32_t h = <a class="code" href="_sync_util_8c.html#aaf1ad85f157755e43ad8daea03d68554">SyncSmallHash</a>(xp, xs);
<a name="l00047"></a>00047     uint32_t hx = h % head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a97cde5fba4685fecaf8ea024d754f5e4" title="the mod to use">mod</a>;
<a name="l00048"></a>00048     <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *ent = head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a688782daa06219bbf7f4876c0c704064" title="the vector of hash chains">ents</a>[hx];
<a name="l00049"></a>00049     head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a7455330fe9c4a0fdaedc2dca09440695" title="number of cache probes">probes</a> = head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a7455330fe9c4a0fdaedc2dca09440695" title="number of cache probes">probes</a> + 1;
<a name="l00050"></a>00050     <span class="keywordflow">while</span> (ent != NULL) {
<a name="l00051"></a>00051         <span class="keywordflow">if</span> (h == ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a875dcf9fba72d3d3d8da0e8266ada7de" title="the small hash">small</a>) {
<a name="l00052"></a>00052             <span class="comment">// probably equal, but we have to check</span>
<a name="l00053"></a>00053             ssize_t cmp = <a class="code" href="_sync_util_8c.html#ad1267040569a894c8110dff90024516e" title="compares two hash codes in charbufs">SyncCmpHashesRaw</a>(xp, xs, ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#aba3a8329dde03169d4bb1f369b2d78cf" title="hash used to reach this entry">hash</a>-&gt;<a class="code" href="structccn__charbuf.html#af24075ee3911a992d0dda6f449f3b3b3">buf</a>, ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#aba3a8329dde03169d4bb1f369b2d78cf" title="hash used to reach this entry">hash</a>-&gt;<a class="code" href="structccn__charbuf.html#a8847707f323a0aa35e2a81001a2d1fbf">length</a>);
<a name="l00054"></a>00054             <span class="keywordflow">if</span> (cmp == 0) <span class="keywordflow">return</span> ent;
<a name="l00055"></a>00055         }
<a name="l00056"></a>00056         ent = ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#ae4e3f5be0c085331268dc1ee724f9742" title="the next entry in the hash chain">next</a>;
<a name="l00057"></a>00057     }
<a name="l00058"></a>00058     head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a1aeb6bb926fb7c63b170c4f6002e3fab" title="number of cache misses">misses</a> = head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a1aeb6bb926fb7c63b170c4f6002e3fab" title="number of cache misses">misses</a> + 1;
<a name="l00059"></a>00059     <span class="keywordflow">return</span> NULL;
<a name="l00060"></a>00060 }
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *
<a name="l00063"></a><a class="code" href="_sync_hash_cache_8h.html#abcf5e784c52d971d943bddef80731954">00063</a> <a class="code" href="_sync_hash_cache_8c.html#abcf5e784c52d971d943bddef80731954" title="based on the raw hash, ensure that a remote cache entry exists ent-&amp;gt;state |= set...">SyncHashEnter</a>(<span class="keyword">struct</span> <a class="code" href="struct_sync_hash_cache_head.html">SyncHashCacheHead</a> *<a class="code" href="struct_sync_hash_cache_entry.html#a17d9349c3a973e5322e76c116a4c5b6d" title="the parent head">head</a>,
<a name="l00064"></a>00064               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *xp, ssize_t xs,
<a name="l00065"></a>00065               <span class="keyword">enum</span> <a class="code" href="_sync_hash_cache_8h.html#adc94d2e43fee7f723745607e3c3a1381">SyncHashState</a> <span class="keyword">set</span>) {
<a name="l00066"></a>00066     <span class="keywordflow">if</span> (xp == NULL || xs &lt;= 0) <span class="keywordflow">return</span> NULL;
<a name="l00067"></a>00067     uint32_t h = <a class="code" href="_sync_util_8c.html#aaf1ad85f157755e43ad8daea03d68554">SyncSmallHash</a>(xp, xs);
<a name="l00068"></a>00068     uint32_t hx = h % head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a97cde5fba4685fecaf8ea024d754f5e4" title="the mod to use">mod</a>;
<a name="l00069"></a>00069     <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *old = head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a688782daa06219bbf7f4876c0c704064" title="the vector of hash chains">ents</a>[hx];
<a name="l00070"></a>00070     <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *ent = old;
<a name="l00071"></a>00071     head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a7455330fe9c4a0fdaedc2dca09440695" title="number of cache probes">probes</a> = head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a7455330fe9c4a0fdaedc2dca09440695" title="number of cache probes">probes</a> + 1;
<a name="l00072"></a>00072     <span class="keywordflow">while</span> (ent != NULL) {
<a name="l00073"></a>00073         <span class="keywordflow">if</span> (h == ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a875dcf9fba72d3d3d8da0e8266ada7de" title="the small hash">small</a>) {
<a name="l00074"></a>00074             <span class="comment">// probably equal, but we have to check</span>
<a name="l00075"></a>00075             ssize_t cmp = <a class="code" href="_sync_util_8c.html#ad1267040569a894c8110dff90024516e" title="compares two hash codes in charbufs">SyncCmpHashesRaw</a>(xp, xs, ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#aba3a8329dde03169d4bb1f369b2d78cf" title="hash used to reach this entry">hash</a>-&gt;<a class="code" href="structccn__charbuf.html#af24075ee3911a992d0dda6f449f3b3b3">buf</a>, ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#aba3a8329dde03169d4bb1f369b2d78cf" title="hash used to reach this entry">hash</a>-&gt;<a class="code" href="structccn__charbuf.html#a8847707f323a0aa35e2a81001a2d1fbf">length</a>);
<a name="l00076"></a>00076             <span class="keywordflow">if</span> (cmp == 0) {
<a name="l00077"></a>00077                 ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a35ea2895580f670d81cc43cdc9505d8f" title="state bits">state</a> |= <span class="keyword">set</span>;
<a name="l00078"></a>00078                 <span class="keywordflow">return</span> ent;
<a name="l00079"></a>00079             }
<a name="l00080"></a>00080         }
<a name="l00081"></a>00081         ent = ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#ae4e3f5be0c085331268dc1ee724f9742" title="the next entry in the hash chain">next</a>;
<a name="l00082"></a>00082     }
<a name="l00083"></a>00083     head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a1aeb6bb926fb7c63b170c4f6002e3fab" title="number of cache misses">misses</a> = head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a1aeb6bb926fb7c63b170c4f6002e3fab" title="number of cache misses">misses</a> + 1;
<a name="l00084"></a>00084     <span class="keywordflow">if</span> (ent == NULL) {
<a name="l00085"></a>00085         uintmax_t <a class="code" href="struct_sync_hash_cache_entry.html#a4b4ecc6c957b330126a72ce87960d644" title="assigned by order of creation">index</a> = head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a04e15edf7004d71034d4767794025f48" title="assigned by order of creation">lastIndex</a> + 1;
<a name="l00086"></a>00086         head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a04e15edf7004d71034d4767794025f48" title="assigned by order of creation">lastIndex</a> = index;
<a name="l00087"></a>00087         head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a7455330fe9c4a0fdaedc2dca09440695" title="number of cache probes">probes</a> = head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a7455330fe9c4a0fdaedc2dca09440695" title="number of cache probes">probes</a> + 1;
<a name="l00088"></a>00088         head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a1aeb6bb926fb7c63b170c4f6002e3fab" title="number of cache misses">misses</a> = head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a1aeb6bb926fb7c63b170c4f6002e3fab" title="number of cache misses">misses</a> + 1;
<a name="l00089"></a>00089         ent = <a class="code" href="_sync_macros_8h.html#ab707d3cfcb52f2e2f819771123942548">NEW_STRUCT</a>(1, <a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a>);
<a name="l00090"></a>00090         ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a6861960908cc217b639d3f1af6bbc520" title="time when entry last used in compare">lastUsed</a> = <a class="code" href="_sync_util_8c.html#a17f22694d0381f7cc758e3cb3a504283">SyncCurrentTime</a>();
<a name="l00091"></a>00091         ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a17d9349c3a973e5322e76c116a4c5b6d" title="the parent head">head</a> = head;
<a name="l00092"></a>00092         ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#ae4e3f5be0c085331268dc1ee724f9742" title="the next entry in the hash chain">next</a> = old;
<a name="l00093"></a>00093         ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a875dcf9fba72d3d3d8da0e8266ada7de" title="the small hash">small</a> = h;
<a name="l00094"></a>00094         ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#aba3a8329dde03169d4bb1f369b2d78cf" title="hash used to reach this entry">hash</a> = <a class="code" href="charbuf_8h.html#a6db2918ed16206ad07920ab26aac9da6">ccn_charbuf_create</a>();
<a name="l00095"></a>00095         ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a4b4ecc6c957b330126a72ce87960d644" title="assigned by order of creation">index</a> = index;
<a name="l00096"></a>00096         <a class="code" href="charbuf_8h.html#a5cc5c1412e38c015951394fcd79e2f6e">ccn_charbuf_append</a>(ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#aba3a8329dde03169d4bb1f369b2d78cf" title="hash used to reach this entry">hash</a>, xp, xs);
<a name="l00097"></a>00097         head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a688782daa06219bbf7f4876c0c704064" title="the vector of hash chains">ents</a>[hx] = ent;
<a name="l00098"></a>00098         head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a8c16a1c3383637d2accd2917282ae431" title="number of entries">len</a>++;
<a name="l00099"></a>00099     }
<a name="l00100"></a>00100     ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a35ea2895580f670d81cc43cdc9505d8f" title="state bits">state</a> |= <span class="keyword">set</span>;
<a name="l00101"></a>00101     <span class="keywordflow">return</span> ent;
<a name="l00102"></a>00102 }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="keyword">extern</span> <span class="keywordtype">void</span>
<a name="l00105"></a><a class="code" href="_sync_hash_cache_8h.html#a4b3eb7fb0b76b12e5e28e6d22e79b0ae">00105</a> <a class="code" href="_sync_hash_cache_8c.html#a4b3eb7fb0b76b12e5e28e6d22e79b0ae" title="remove the entry (if present)">SyncHashRemoveEntry</a>(<span class="keyword">struct</span> <a class="code" href="struct_sync_hash_cache_head.html">SyncHashCacheHead</a> *<a class="code" href="struct_sync_hash_cache_entry.html#a17d9349c3a973e5322e76c116a4c5b6d" title="the parent head">head</a>,
<a name="l00106"></a>00106                     <span class="keyword">struct</span> <a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *ce) {
<a name="l00107"></a>00107     <span class="keywordflow">if</span> (ce != NULL) {
<a name="l00108"></a>00108         uint32_t h = ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a875dcf9fba72d3d3d8da0e8266ada7de" title="the small hash">small</a>;
<a name="l00109"></a>00109         uint32_t hx = h % head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a97cde5fba4685fecaf8ea024d754f5e4" title="the mod to use">mod</a>;
<a name="l00110"></a>00110         <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *ent = head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a688782daa06219bbf7f4876c0c704064" title="the vector of hash chains">ents</a>[hx];
<a name="l00111"></a>00111         <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *lag = NULL;
<a name="l00112"></a>00112         <span class="keywordflow">while</span> (ent != NULL) {
<a name="l00113"></a>00113             <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *<a class="code" href="struct_sync_hash_cache_entry.html#ae4e3f5be0c085331268dc1ee724f9742" title="the next entry in the hash chain">next</a> = ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#ae4e3f5be0c085331268dc1ee724f9742" title="the next entry in the hash chain">next</a>;
<a name="l00114"></a>00114             <span class="keywordflow">if</span> (ent == ce) {
<a name="l00115"></a>00115                 <span class="comment">// unchain from main chain</span>
<a name="l00116"></a>00116                 <span class="keywordflow">if</span> (lag == NULL) head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a688782daa06219bbf7f4876c0c704064" title="the vector of hash chains">ents</a>[hx] = next;
<a name="l00117"></a>00117                 <span class="keywordflow">else</span> lag-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#ae4e3f5be0c085331268dc1ee724f9742" title="the next entry in the hash chain">next</a> = next;
<a name="l00118"></a>00118                 <span class="keywordflow">break</span>;
<a name="l00119"></a>00119             }
<a name="l00120"></a>00120             lag = ent;
<a name="l00121"></a>00121             ent = next;
<a name="l00122"></a>00122         }
<a name="l00123"></a>00123         <span class="keywordflow">if</span> (ent == ce)
<a name="l00124"></a>00124             ce = <a class="code" href="_sync_hash_cache_8c.html#a64b5a732b2fbe58f83c67e710ff9275d">localFreeEntry</a>(ce);
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126 }
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 <span class="keyword">extern</span> <span class="keywordtype">void</span>
<a name="l00129"></a><a class="code" href="_sync_hash_cache_8h.html#a3b70f87d8ce6ed84b0b658dd0d4742e9">00129</a> <a class="code" href="_sync_hash_cache_8c.html#a3b70f87d8ce6ed84b0b658dd0d4742e9" title="clear all marks">SyncHashClearMarks</a>(<span class="keyword">struct</span> <a class="code" href="struct_sync_hash_cache_head.html">SyncHashCacheHead</a> *<a class="code" href="struct_sync_hash_cache_entry.html#a17d9349c3a973e5322e76c116a4c5b6d" title="the parent head">head</a>) {
<a name="l00130"></a>00130     <span class="keywordtype">int</span> hx = 0;
<a name="l00131"></a>00131     <span class="keywordflow">for</span> (hx = 0; hx &lt; head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a97cde5fba4685fecaf8ea024d754f5e4" title="the mod to use">mod</a>; hx++) {
<a name="l00132"></a>00132         <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *ent = head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a688782daa06219bbf7f4876c0c704064" title="the vector of hash chains">ents</a>[hx];
<a name="l00133"></a>00133         <span class="keywordflow">while</span> (ent != NULL) {
<a name="l00134"></a>00134             <span class="keyword">enum</span> <a class="code" href="_sync_hash_cache_8h.html#adc94d2e43fee7f723745607e3c3a1381">SyncHashState</a> <a class="code" href="struct_sync_hash_cache_entry.html#a35ea2895580f670d81cc43cdc9505d8f" title="state bits">state</a> = ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a35ea2895580f670d81cc43cdc9505d8f" title="state bits">state</a>;
<a name="l00135"></a>00135             <span class="keyword">enum</span> <a class="code" href="_sync_hash_cache_8h.html#adc94d2e43fee7f723745607e3c3a1381">SyncHashState</a> bit = state &amp; <a class="code" href="_sync_hash_cache_8h.html#adc94d2e43fee7f723745607e3c3a1381a82c2c7c70f2313fdc8a563bd15874184" title="cache entry has been marked">SyncHashState_marked</a>;
<a name="l00136"></a>00136             ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a35ea2895580f670d81cc43cdc9505d8f" title="state bits">state</a> = state - bit;
<a name="l00137"></a>00137             ent = ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#ae4e3f5be0c085331268dc1ee724f9742" title="the next entry in the hash chain">next</a>;
<a name="l00138"></a>00138         }
<a name="l00139"></a>00139     }
<a name="l00140"></a>00140 }
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_head.html">SyncHashCacheHead</a> *
<a name="l00143"></a><a class="code" href="_sync_hash_cache_8h.html#adcd97f68b3c8364ff8fcee1b3c99e6d3">00143</a> <a class="code" href="_sync_hash_cache_8c.html#adcd97f68b3c8364ff8fcee1b3c99e6d3" title="create a new hash table with the given modulus (mod == 0 uses a default)">SyncHashCacheCreate</a>(<span class="keyword">struct</span> <a class="code" href="struct_sync_root_struct.html" title="A SyncRootStruct object holds the necessary data for a root sync tree.">SyncRootStruct</a> *<a class="code" href="struct_sync_hash_cache_head.html#aae4f738e778a493f25625017a060393f" title="the parent root">root</a>, uint32_t <a class="code" href="struct_sync_hash_cache_head.html#a97cde5fba4685fecaf8ea024d754f5e4" title="the mod to use">mod</a>) {
<a name="l00144"></a>00144     <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_head.html">SyncHashCacheHead</a> *head = <a class="code" href="_sync_macros_8h.html#ab707d3cfcb52f2e2f819771123942548">NEW_STRUCT</a>(1, <a class="code" href="struct_sync_hash_cache_head.html">SyncHashCacheHead</a>);
<a name="l00145"></a>00145     <span class="keywordflow">if</span> (mod &lt; 4) mod = 4;
<a name="l00146"></a>00146     head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a97cde5fba4685fecaf8ea024d754f5e4" title="the mod to use">mod</a> = mod;
<a name="l00147"></a>00147     head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a688782daa06219bbf7f4876c0c704064" title="the vector of hash chains">ents</a> = <a class="code" href="_sync_macros_8h.html#ad73a1ea2efeb48dbdfd99d0b27d8e695">NEW_ANY</a>(mod, <span class="keyword">struct</span> <a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *);
<a name="l00148"></a>00148     head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#aae4f738e778a493f25625017a060393f" title="the parent root">root</a> = root;
<a name="l00149"></a>00149     <span class="keywordflow">return</span> head;
<a name="l00150"></a>00150 }
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 <span class="keyword">extern</span> <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_head.html">SyncHashCacheHead</a> *
<a name="l00153"></a><a class="code" href="_sync_hash_cache_8h.html#ab1f4fdb69850160777d5427d9d057586">00153</a> <a class="code" href="_sync_hash_cache_8c.html#ab1f4fdb69850160777d5427d9d057586" title="frees the cache resources caller must ensure no further use of the cache">SyncHashCacheFree</a>(<span class="keyword">struct</span> <a class="code" href="struct_sync_hash_cache_head.html">SyncHashCacheHead</a> *head) {
<a name="l00154"></a>00154     <span class="keywordflow">if</span> (head != NULL) {
<a name="l00155"></a>00155         <span class="keywordtype">size_t</span> i = 0;
<a name="l00156"></a>00156         <span class="keywordtype">size_t</span> lim = head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a97cde5fba4685fecaf8ea024d754f5e4" title="the mod to use">mod</a>;
<a name="l00157"></a>00157         <span class="keywordflow">while</span> (i &lt; lim) {
<a name="l00158"></a>00158             <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *ent = head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a688782daa06219bbf7f4876c0c704064" title="the vector of hash chains">ents</a>[i];
<a name="l00159"></a>00159             head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a688782daa06219bbf7f4876c0c704064" title="the vector of hash chains">ents</a>[i] = NULL;
<a name="l00160"></a>00160             <span class="keywordflow">while</span> (ent != NULL) {
<a name="l00161"></a>00161                 <span class="comment">// TBD: error if busy?</span>
<a name="l00162"></a>00162                 <span class="keyword">struct </span><a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *<a class="code" href="struct_sync_hash_cache_entry.html#ae4e3f5be0c085331268dc1ee724f9742" title="the next entry in the hash chain">next</a> = ent-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#ae4e3f5be0c085331268dc1ee724f9742" title="the next entry in the hash chain">next</a>;
<a name="l00163"></a>00163                 ent = <a class="code" href="_sync_hash_cache_8c.html#a64b5a732b2fbe58f83c67e710ff9275d">localFreeEntry</a>(ent);
<a name="l00164"></a>00164                 ent = next;
<a name="l00165"></a>00165             }
<a name="l00166"></a>00166             i++;
<a name="l00167"></a>00167         }
<a name="l00168"></a>00168         free(head-&gt;<a class="code" href="struct_sync_hash_cache_head.html#a688782daa06219bbf7f4876c0c704064" title="the vector of hash chains">ents</a>);
<a name="l00169"></a>00169         free(head);
<a name="l00170"></a>00170     }
<a name="l00171"></a>00171     <span class="keywordflow">return</span> NULL;
<a name="l00172"></a>00172 }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="keyword">extern</span> <span class="keywordtype">int</span>
<a name="l00175"></a><a class="code" href="_sync_hash_cache_8h.html#afb2e6f78b30fa3d307dcc9e3b0b86056">00175</a> <a class="code" href="_sync_hash_cache_8c.html#afb2e6f78b30fa3d307dcc9e3b0b86056" title="stores the cahe entry to the repo to be eligible, ce != NULL &amp;amp;&amp;amp; ce-&amp;gt;ncL...">SyncCacheEntryStore</a>(<span class="keyword">struct</span> <a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *ce) {
<a name="l00176"></a>00176     <span class="comment">// causes the cache entry to be saved to the repo</span>
<a name="l00177"></a>00177     <span class="keywordtype">int</span> res = 0;
<a name="l00178"></a>00178     <span class="keywordflow">if</span> (ce == NULL) {
<a name="l00179"></a>00179         <span class="comment">// not an entry</span>
<a name="l00180"></a>00180         res = -1;
<a name="l00181"></a>00181     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a94d0a088221aef50aace5c203075d686" title="the local node in memory">ncL</a> == NULL || ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a94d0a088221aef50aace5c203075d686" title="the local node in memory">ncL</a>-&gt;<a class="code" href="struct_sync_node_composite.html#a5b1cdb9c3eabafe04a18c8623784ff04" title="pointer to ccnb encoding">cb</a> == NULL
<a name="l00182"></a>00182         || (ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a35ea2895580f670d81cc43cdc9505d8f" title="state bits">state</a> &amp; <a class="code" href="_sync_hash_cache_8h.html#adc94d2e43fee7f723745607e3c3a1381a83898a8e93d5a30a5b8278f74aedb6ef" title="local node has been stored">SyncHashState_stored</a>)
<a name="l00183"></a>00183         || (ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a35ea2895580f670d81cc43cdc9505d8f" title="state bits">state</a> &amp; <a class="code" href="_sync_hash_cache_8h.html#adc94d2e43fee7f723745607e3c3a1381ad4b20491244029e5364fcf26e8bd7a56" title="local node is queued to be stored">SyncHashState_storing</a>) == 0 ) {
<a name="l00184"></a>00184         <span class="comment">// not eligible</span>
<a name="l00185"></a>00185         res = 0;
<a name="l00186"></a>00186     } <span class="keywordflow">else</span> {
<a name="l00187"></a>00187         <span class="keyword">struct </span><a class="code" href="struct_sync_root_struct.html" title="A SyncRootStruct object holds the necessary data for a root sync tree.">SyncRootStruct</a> *root = ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a17d9349c3a973e5322e76c116a4c5b6d" title="the parent head">head</a>-&gt;<a class="code" href="struct_sync_hash_cache_head.html#aae4f738e778a493f25625017a060393f" title="the parent root">root</a>;
<a name="l00188"></a>00188         <span class="keyword">struct </span><a class="code" href="struct_sync_base_struct.html">SyncBaseStruct</a> *base = root-&gt;<a class="code" href="struct_sync_root_struct.html#aeb13995531505b4198ee20697bf1c08f" title="Sync Agent base.">base</a>;
<a name="l00189"></a>00189         <span class="keyword">struct </span><a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *name = <a class="code" href="_sync_util_8c.html#a221b6f73b716854ce94d5d815cfe0795" title="given a sync node hash,">SyncNameForLocalNode</a>(root, ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#aba3a8329dde03169d4bb1f369b2d78cf" title="hash used to reach this entry">hash</a>);
<a name="l00190"></a>00190         <span class="keyword">struct </span><a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *content = ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a94d0a088221aef50aace5c203075d686" title="the local node in memory">ncL</a>-&gt;<a class="code" href="struct_sync_node_composite.html#a5b1cdb9c3eabafe04a18c8623784ff04" title="pointer to ccnb encoding">cb</a>;
<a name="l00191"></a>00191         
<a name="l00192"></a>00192         <span class="comment">// TBD: do we want to omit version and segment?</span>
<a name="l00193"></a>00193         res |= <a class="code" href="ccn_8h.html#af222a5e0ff25d4f2ff60eed72b3defb2" title="Extend a Name with a new version stamp.">ccn_create_version</a>(base-&gt;<a class="code" href="struct_sync_base_struct.html#a86379b5e56784ebff9e36a2da1976ef6">sd</a>-&gt;<a class="code" href="structsync__plumbing.html#a5c7f66f36ab1eb5de840d06ab1da6e74">ccn</a>, name, <a class="code" href="ccn_8h.html#ac0d9b4a6ddee8ae94d87d8c2340ac907" title="use current time">CCN_V_NOW</a>, 0, 0);
<a name="l00194"></a>00194         res |= <a class="code" href="ccn_8h.html#a3b95a770555b90f43d4876bea62c202d" title="Add a binary Component to a ccnb-encoded Name.">ccn_name_append_numeric</a>(name, <a class="code" href="ccn_8h.html#afec910e39c89dcf24a44f93e97032399af3eb8e7fa3a938a5bcc6c1f141357d71" title="consecutive block sequence numbers">CCN_MARKER_SEQNUM</a>, 0);
<a name="l00195"></a>00195         
<a name="l00196"></a>00196         res = <a class="code" href="_sync_util_8c.html#ae73bbf60dd7be15fd58bbfba72a0d900" title="given a sync node hash,">SyncLocalRepoStore</a>(base, name, content, <a class="code" href="ccn_8h.html#abff51f3f313d457fbcc13006343fdd28">CCN_SP_FINAL_BLOCK</a>);
<a name="l00197"></a>00197         <span class="keywordflow">if</span> (res &gt; 0) {
<a name="l00198"></a>00198             <span class="comment">// clear the bits</span>
<a name="l00199"></a>00199             ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a35ea2895580f670d81cc43cdc9505d8f" title="state bits">state</a> |= <a class="code" href="_sync_hash_cache_8h.html#adc94d2e43fee7f723745607e3c3a1381a83898a8e93d5a30a5b8278f74aedb6ef" title="local node has been stored">SyncHashState_stored</a>;
<a name="l00200"></a>00200             ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a35ea2895580f670d81cc43cdc9505d8f" title="state bits">state</a> = ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a35ea2895580f670d81cc43cdc9505d8f" title="state bits">state</a> - <a class="code" href="_sync_hash_cache_8h.html#adc94d2e43fee7f723745607e3c3a1381ad4b20491244029e5364fcf26e8bd7a56" title="local node is queued to be stored">SyncHashState_storing</a>;
<a name="l00201"></a>00201         }
<a name="l00202"></a>00202         <a class="code" href="charbuf_8h.html#a699030e7cb3c51ca2cde46af0ba6e1bb">ccn_charbuf_destroy</a>(&amp;name);
<a name="l00203"></a>00203     }
<a name="l00204"></a>00204     <span class="keywordflow">return</span> res;
<a name="l00205"></a>00205 }
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 <span class="keyword">extern</span> <span class="keywordtype">int</span>
<a name="l00208"></a><a class="code" href="_sync_hash_cache_8h.html#a88b8496fee4324b2359f23e3c6dd9472">00208</a> <a class="code" href="_sync_hash_cache_8c.html#a88b8496fee4324b2359f23e3c6dd9472" title="fetches the cache entry to be eligible, ce != NULL &amp;amp;&amp;amp; ce-&amp;gt;ncL != NULL...">SyncCacheEntryFetch</a>(<span class="keyword">struct</span> <a class="code" href="struct_sync_hash_cache_entry.html">SyncHashCacheEntry</a> *ce) {
<a name="l00209"></a>00209     <span class="comment">// causes the cache entry to fetched from the repo</span>
<a name="l00210"></a>00210     <span class="keywordtype">char</span> *here = <span class="stringliteral">&quot;Sync.SyncCacheEntryFetch&quot;</span>;
<a name="l00211"></a>00211     <span class="keywordtype">int</span> res = 0;
<a name="l00212"></a>00212     <span class="keywordflow">if</span> (ce == NULL) {
<a name="l00213"></a>00213         <span class="comment">// not an entry</span>
<a name="l00214"></a>00214         res = -1;
<a name="l00215"></a>00215     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a94d0a088221aef50aace5c203075d686" title="the local node in memory">ncL</a> != NULL) {
<a name="l00216"></a>00216         <span class="comment">// it&#39;s already here</span>
<a name="l00217"></a>00217         res = 0;
<a name="l00218"></a>00218     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a35ea2895580f670d81cc43cdc9505d8f" title="state bits">state</a> &amp; <a class="code" href="_sync_hash_cache_8h.html#adc94d2e43fee7f723745607e3c3a1381a83898a8e93d5a30a5b8278f74aedb6ef" title="local node has been stored">SyncHashState_stored</a>) == 0) {
<a name="l00219"></a>00219         <span class="comment">// it&#39;s never been stored, fail quietly</span>
<a name="l00220"></a>00220         res = -1;
<a name="l00221"></a>00221     } <span class="keywordflow">else</span> {
<a name="l00222"></a>00222         <span class="comment">// at this point we try to fetch it from the local repo</span>
<a name="l00223"></a>00223         <span class="comment">// a failure should complain</span>
<a name="l00224"></a>00224         <span class="keyword">struct </span><a class="code" href="struct_sync_root_struct.html" title="A SyncRootStruct object holds the necessary data for a root sync tree.">SyncRootStruct</a> *root = ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a17d9349c3a973e5322e76c116a4c5b6d" title="the parent head">head</a>-&gt;<a class="code" href="struct_sync_hash_cache_head.html#aae4f738e778a493f25625017a060393f" title="the parent root">root</a>;
<a name="l00225"></a>00225         <span class="keyword">struct </span><a class="code" href="struct_sync_base_struct.html">SyncBaseStruct</a> *base = root-&gt;<a class="code" href="struct_sync_root_struct.html#aeb13995531505b4198ee20697bf1c08f" title="Sync Agent base.">base</a>;
<a name="l00226"></a>00226         <span class="keyword">struct </span><a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *name = <a class="code" href="_sync_util_8c.html#a221b6f73b716854ce94d5d815cfe0795" title="given a sync node hash,">SyncNameForLocalNode</a>(root, ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#aba3a8329dde03169d4bb1f369b2d78cf" title="hash used to reach this entry">hash</a>);
<a name="l00227"></a>00227         <span class="keyword">struct </span><a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *content = <a class="code" href="charbuf_8h.html#a6db2918ed16206ad07920ab26aac9da6">ccn_charbuf_create</a>();
<a name="l00228"></a>00228         <span class="keywordtype">char</span> *why = <span class="stringliteral">&quot;no fetch&quot;</span>;
<a name="l00229"></a>00229         <span class="keyword">struct </span><a class="code" href="structccn__parsed___content_object.html">ccn_parsed_ContentObject</a> pcos;
<a name="l00230"></a>00230         
<a name="l00231"></a>00231         res = <a class="code" href="_sync_util_8c.html#ac820265fc0e721a9424924d759ca377e" title="given a local repo name and a buffer to fill, fills cb with the content object (note:...">SyncLocalRepoFetch</a>(base, name, content, &amp;pcos);
<a name="l00232"></a>00232         <span class="keywordflow">if</span> (res &gt;= 0) {
<a name="l00233"></a>00233             <span class="comment">// parse the object</span>
<a name="l00234"></a>00234             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *xp = NULL;
<a name="l00235"></a>00235             <span class="keywordtype">size_t</span> xs = 0;
<a name="l00236"></a>00236             <span class="comment">// get the encoded node</span>
<a name="l00237"></a>00237             res = <a class="code" href="ccn_8h.html#ac3a7a8cad96caf34fc73240b20f07cd2">ccn_content_get_value</a>(content-&gt;<a class="code" href="structccn__charbuf.html#af24075ee3911a992d0dda6f449f3b3b3">buf</a>, content-&gt;<a class="code" href="structccn__charbuf.html#a8847707f323a0aa35e2a81001a2d1fbf">length</a>,
<a name="l00238"></a>00238                                         &amp;pcos, &amp;xp, &amp;xs);
<a name="l00239"></a>00239             <span class="keywordflow">if</span> (res &lt; 0)
<a name="l00240"></a>00240                 why = <span class="stringliteral">&quot;ccn_content_get_value failed&quot;</span>;
<a name="l00241"></a>00241             <span class="keywordflow">else</span> {
<a name="l00242"></a>00242                 <span class="keyword">struct </span><a class="code" href="structccn__buf__decoder.html">ccn_buf_decoder</a> ds;
<a name="l00243"></a>00243                 <span class="keyword">struct </span><a class="code" href="structccn__buf__decoder.html">ccn_buf_decoder</a> *d = <a class="code" href="ccn_8h.html#a4ba830f8dad511663779d85122db633a">ccn_buf_decoder_start</a>(&amp;ds, xp, xs);
<a name="l00244"></a>00244                 <span class="keyword">struct </span><a class="code" href="struct_sync_node_composite.html" title="A SyncNodeComposite object holds the necessary data for a sync tree node.">SyncNodeComposite</a> *nc = <a class="code" href="_sync_node_8c.html#adbc4a9ebd7d35b9d7c9d36a9c3263bb7" title="allocates a new, empty, composite object">SyncAllocComposite</a>(root-&gt;<a class="code" href="struct_sync_root_struct.html#aeb13995531505b4198ee20697bf1c08f" title="Sync Agent base.">base</a>);
<a name="l00245"></a>00245                 res |= <a class="code" href="_sync_node_8c.html#aaea566ba70951e05863f749b1d8c97eb" title="parses an encoded node and fills in the supplied node implicitly resets the node...">SyncParseComposite</a>(nc, d);
<a name="l00246"></a>00246                 <span class="keywordflow">if</span> (res &lt; 0) {
<a name="l00247"></a>00247                     <span class="comment">// failed, so back out of the allocations</span>
<a name="l00248"></a>00248                     why = <span class="stringliteral">&quot;bad parse&quot;</span>;
<a name="l00249"></a>00249                     <a class="code" href="_sync_node_8c.html#af28433d58bb465b237a50e3b0aa9d0e4" title="freeComposite returns the storage for the composite object">SyncFreeComposite</a>(nc);
<a name="l00250"></a>00250                     nc = NULL;
<a name="l00251"></a>00251                 } <span class="keywordflow">else</span> {
<a name="l00252"></a>00252                     res = 1;
<a name="l00253"></a>00253                     <a class="code" href="_sync_node_8c.html#aab2c27ab0d33e00e6bfe576bd9142c0a" title="Increments the reference count.">SyncNodeIncRC</a>(nc);
<a name="l00254"></a>00254                     ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a94d0a088221aef50aace5c203075d686" title="the local node in memory">ncL</a> = nc;
<a name="l00255"></a>00255                     ce-&gt;<a class="code" href="struct_sync_hash_cache_entry.html#a35ea2895580f670d81cc43cdc9505d8f" title="state bits">state</a> |= <a class="code" href="_sync_hash_cache_8h.html#adc94d2e43fee7f723745607e3c3a1381a83898a8e93d5a30a5b8278f74aedb6ef" title="local node has been stored">SyncHashState_stored</a>;
<a name="l00256"></a>00256                 }
<a name="l00257"></a>00257             }
<a name="l00258"></a>00258         }
<a name="l00259"></a>00259         <span class="keywordflow">if</span> (res &lt; 0)
<a name="l00260"></a>00260             <span class="keywordflow">if</span> (root-&gt;<a class="code" href="struct_sync_root_struct.html#aeb13995531505b4198ee20697bf1c08f" title="Sync Agent base.">base</a>-&gt;<a class="code" href="struct_sync_base_struct.html#a700f75c76dde6f2a525ea5b4cf7c0b79">debug</a> &gt;= <a class="code" href="loglevels_8h.html#af91ddb985e8b28b1f1d0c74c7b6385c9" title="Configuration errors.">CCNL_ERROR</a>)
<a name="l00261"></a>00261                 <a class="code" href="_sync_util_8c.html#a60a96e3d70a904dbe3f038aaa622fb36">SyncNoteUri</a>(root, here, why, name);
<a name="l00262"></a>00262         <a class="code" href="charbuf_8h.html#a699030e7cb3c51ca2cde46af0ba6e1bb">ccn_charbuf_destroy</a>(&amp;name);
<a name="l00263"></a>00263         <a class="code" href="charbuf_8h.html#a699030e7cb3c51ca2cde46af0ba6e1bb">ccn_charbuf_destroy</a>(&amp;content);
<a name="l00264"></a>00264     }
<a name="l00265"></a>00265     <span class="keywordflow">return</span> res;
<a name="l00266"></a>00266 }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Feb 4 11:56:48 2013 for Content-Centric Networking in C by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

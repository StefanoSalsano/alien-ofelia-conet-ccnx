<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Content-Centric Networking in C: lib/ccn_fetch.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_b8e74f80653d868cec04ba0ac37e4e28.html">lib</a>
  </div>
</div>
<div class="contents">
<h1>ccn_fetch.c</h1><a href="ccn__fetch_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * lib/ccn_fetch.c</span>
<a name="l00003"></a>00003 <span class="comment"> * </span>
<a name="l00004"></a>00004 <span class="comment"> * Part of the CCNx C Library.</span>
<a name="l00005"></a>00005 <span class="comment"> *</span>
<a name="l00006"></a>00006 <span class="comment"> * Copyright (C) 2010-2012 Palo Alto Research Center, Inc.</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * This library is free software; you can redistribute it and/or modify it</span>
<a name="l00009"></a>00009 <span class="comment"> * under the terms of the GNU Lesser General Public License version 2.1</span>
<a name="l00010"></a>00010 <span class="comment"> * as published by the Free Software Foundation.</span>
<a name="l00011"></a>00011 <span class="comment"> * This library is distributed in the hope that it will be useful,</span>
<a name="l00012"></a>00012 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00013"></a>00013 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<a name="l00014"></a>00014 <span class="comment"> * Lesser General Public License for more details. You should have received</span>
<a name="l00015"></a>00015 <span class="comment"> * a copy of the GNU Lesser General Public License along with this library;</span>
<a name="l00016"></a>00016 <span class="comment"> * if not, write to the Free Software Foundation, Inc., 51 Franklin Street,</span>
<a name="l00017"></a>00017 <span class="comment"> * Fifth Floor, Boston, MA 02110-1301 USA.</span>
<a name="l00018"></a>00018 <span class="comment"> */</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">/**</span>
<a name="l00021"></a>00021 <span class="comment"> * Streaming access for fetching segmented CCNx data.</span>
<a name="l00022"></a>00022 <span class="comment"> *</span>
<a name="l00023"></a>00023 <span class="comment"> * Supports multiple streams from a single connection and</span>
<a name="l00024"></a>00024 <span class="comment"> * seeking to an arbitrary position within the associated file.</span>
<a name="l00025"></a>00025 <span class="comment"> *</span>
<a name="l00026"></a>00026 <span class="comment"> * TBD: need to fix up the case where a segment cannot be fetched but we are</span>
<a name="l00027"></a>00027 <span class="comment"> * not really at the end of the stream data.  This case can occur if we express</span>
<a name="l00028"></a>00028 <span class="comment"> * an interest for a segment and the interest times out.  Current behavior is</span>
<a name="l00029"></a>00029 <span class="comment"> * to treat this as an end-of-stream (prematurely and silently)</span>
<a name="l00030"></a>00030 <span class="comment"> *</span>
<a name="l00031"></a>00031 <span class="comment"> * TBD: need to provide a more principled (or maybe just controlled) way to</span>
<a name="l00032"></a>00032 <span class="comment"> * handle interest timeouts.</span>
<a name="l00033"></a>00033 <span class="comment"> */</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="fetch_8h.html" title="Streaming access for fetching segmented CCNx data.">ccn/fetch.h</a>&gt;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;errno.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;time.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="comment">// TBD: the following constants should be more principled</span>
<a name="l00048"></a><a class="code" href="ccn__fetch_8c.html#ae5c2a797e9f60944a884d7410a69ce80">00048</a> <span class="preprocessor">#define CCN_VERSION_TIMEOUT 8000</span>
<a name="l00049"></a><a class="code" href="ccn__fetch_8c.html#afde4a7a5e602643b1d97eaf2a862f8b1">00049</a> <span class="preprocessor"></span><span class="preprocessor">#define CCN_INTEREST_TIMEOUT_USECS 15000000</span>
<a name="l00050"></a><a class="code" href="ccn__fetch_8c.html#ad9e1439bf63dbf29957d1c676008ec24">00050</a> <span class="preprocessor"></span><span class="preprocessor">#define MaxSuffixDefault 4</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00052"></a><a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">00052</a> <span class="keyword">typedef</span> intmax_t <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a>;
<a name="l00053"></a>00053 
<a name="l00054"></a><a class="code" href="ccn__fetch_8c.html#a1f969ace41b81f43e4b15f4a80906503">00054</a> <span class="keyword">typedef</span> uint64_t <a class="code" href="ccn__fetch_8c.html#a1f969ace41b81f43e4b15f4a80906503">TimeMarker</a>;
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="keyword">static</span> <a class="code" href="ccn__fetch_8c.html#a1f969ace41b81f43e4b15f4a80906503">TimeMarker</a>
<a name="l00057"></a><a class="code" href="ccn__fetch_8c.html#aff3b0edd6cf94b3fc5b9f042147c9181">00057</a> <a class="code" href="ccn__fetch_8c.html#aff3b0edd6cf94b3fc5b9f042147c9181">GetCurrentTimeUSecs</a>(<span class="keywordtype">void</span>) {
<a name="l00058"></a>00058         <span class="keyword">const</span> <a class="code" href="ccn__fetch_8c.html#a1f969ace41b81f43e4b15f4a80906503">TimeMarker</a> <a class="code" href="_sync_actions_8c.html#a52037c938e3c1b126c6277da5ca689d0">M</a> = 1000*1000;
<a name="l00059"></a>00059         <span class="keyword">struct </span>timeval now = {0};
<a name="l00060"></a>00060     gettimeofday(&amp;now, 0);
<a name="l00061"></a>00061         <span class="keywordflow">return</span> now.tv_sec*M+now.tv_usec;
<a name="l00062"></a>00062 }
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="keyword">static</span> intmax_t
<a name="l00065"></a><a class="code" href="ccn__fetch_8c.html#a43f0ed286bea5e2b05ccb70da559a8d1">00065</a> <a class="code" href="ccn__fetch_8c.html#a43f0ed286bea5e2b05ccb70da559a8d1">DeltaTime</a>(<a class="code" href="ccn__fetch_8c.html#a1f969ace41b81f43e4b15f4a80906503">TimeMarker</a> mt1, <a class="code" href="ccn__fetch_8c.html#a1f969ace41b81f43e4b15f4a80906503">TimeMarker</a> mt2) {
<a name="l00066"></a>00066         <span class="keywordflow">return</span>(mt2-mt1);
<a name="l00067"></a>00067 }
<a name="l00068"></a>00068 <span class="comment"></span>
<a name="l00069"></a>00069 <span class="comment">///////////////////////////////////////////////////////</span>
<a name="l00070"></a>00070 <span class="comment"></span>
<a name="l00071"></a>00071 <span class="keyword">struct </span>ccn_fetch {
<a name="l00072"></a>00072         <span class="keyword">struct </span>ccn *h;
<a name="l00073"></a>00073         FILE *<a class="code" href="ccnc_8c.html#ac3e1795766a80ec63b157951b4b9a7d4">debug</a>;
<a name="l00074"></a>00074         <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0">ccn_fetch_flags</a> debugFlags;
<a name="l00075"></a>00075         <span class="keywordtype">int</span> localConnect;
<a name="l00076"></a>00076         <span class="keywordtype">int</span> nStreams;
<a name="l00077"></a>00077         <span class="keywordtype">int</span> maxStreams;
<a name="l00078"></a>00078         <span class="keyword">struct </span>ccn_fetch_stream **streams;
<a name="l00079"></a>00079 };
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="keyword">struct </span>ccn_fetch_buffer {
<a name="l00082"></a>00082         <span class="keyword">struct </span>ccn_fetch_buffer *next;
<a name="l00083"></a>00083         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> seg;                      <span class="comment">// the seg for this buffer (&lt; 0 if unassigned)</span>
<a name="l00084"></a>00084         intmax_t pos;           <span class="comment">// the base byte position for this segment</span>
<a name="l00085"></a>00085         <span class="keywordtype">int</span> len;                        <span class="comment">// the number of valid bytes</span>
<a name="l00086"></a>00086         <span class="keywordtype">int</span> max;                        <span class="comment">// the buffer size</span>
<a name="l00087"></a>00087         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf;     <span class="comment">// where the bytes are</span>
<a name="l00088"></a>00088 };
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="keyword">struct </span>localClosure {
<a name="l00091"></a>00091         <span class="keyword">struct </span>ccn_fetch_stream *fs;
<a name="l00092"></a>00092         <span class="keyword">struct </span>localClosure *next;
<a name="l00093"></a>00093         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> reqSeg;
<a name="l00094"></a>00094         <a class="code" href="ccn__fetch_8c.html#a1f969ace41b81f43e4b15f4a80906503">TimeMarker</a> startClock;
<a name="l00095"></a>00095 };
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="keyword">struct </span>ccn_fetch_stream {
<a name="l00098"></a>00098         <span class="keyword">struct </span>ccn_fetch *parent;
<a name="l00099"></a>00099         <span class="keyword">struct </span>localClosure *requests;  <span class="comment">// segment requests in process</span>
<a name="l00100"></a>00100         <span class="keywordtype">int</span> reqBusy;                    <span class="comment">// the number of requests busy</span>
<a name="l00101"></a>00101         <span class="keywordtype">int</span> maxBufs;                    <span class="comment">// max number of buffers allowed</span>
<a name="l00102"></a>00102         <span class="keywordtype">int</span> nBufs;                              <span class="comment">// the number of buffers allocated</span>
<a name="l00103"></a>00103         <span class="keyword">struct </span>ccn_fetch_buffer *bufList;       <span class="comment">// the buffer list</span>
<a name="l00104"></a>00104         <span class="keywordtype">char</span> *id;
<a name="l00105"></a>00105         <span class="keyword">struct </span><a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *name;                       <span class="comment">// interest name (without seq#)</span>
<a name="l00106"></a>00106         <span class="keyword">struct </span><a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *interest;           <span class="comment">// interest template</span>
<a name="l00107"></a>00107         <span class="keywordtype">int</span> segSize;                    <span class="comment">// the segment size (-1 if variable, 0 if unknown)</span>
<a name="l00108"></a>00108         <span class="keywordtype">int</span> segsAhead;
<a name="l00109"></a>00109         intmax_t fileSize;              <span class="comment">// the file size (&lt; 0 if unassigned)</span>
<a name="l00110"></a>00110         intmax_t readPosition;  <span class="comment">// the read position (always assigned)</span>
<a name="l00111"></a>00111         intmax_t readStart;             <span class="comment">// the read position at segment start</span>
<a name="l00112"></a>00112         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> readSeg;                  <span class="comment">// the segment for the readPosition</span>
<a name="l00113"></a>00113         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> timeoutSeg;               <span class="comment">// the lowest timeout segment seen</span>
<a name="l00114"></a>00114         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> zeroLenSeg;               <span class="comment">// the lowest zero len segment seen</span>
<a name="l00115"></a>00115         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> finalSeg;                 <span class="comment">// final segment number (&lt; 0 if not known yet)</span>
<a name="l00116"></a>00116         <span class="keywordtype">int</span> finalSegLen;                <span class="comment">// final segment length</span>
<a name="l00117"></a>00117         intmax_t timeoutUSecs;  <span class="comment">// microseconds for interest timeout</span>
<a name="l00118"></a>00118         intmax_t timeoutsSeen;
<a name="l00119"></a>00119         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> segsRead;
<a name="l00120"></a>00120         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> segsRequested;
<a name="l00121"></a>00121 };
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 <span class="comment">// forward reference</span>
<a name="l00124"></a>00124 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="ccn_8h.html#ac4cc3fdb432fd23cdc0c5642276b0ddc" title="Upcalls return one of these values.">ccn_upcall_res</a>
<a name="l00125"></a>00125 <a class="code" href="ccn__fetch_8c.html#a05048f9a77fdc4341b88e8a89a3be7fa">CallMe</a>(<span class="keyword">struct</span> <a class="code" href="structccn__closure.html" title="Handle for upcalls that allow clients receive notifications of incoming interests...">ccn_closure</a> *selfp,
<a name="l00126"></a>00126            <span class="keyword">enum</span> <a class="code" href="ccn_8h.html#a5fcebad21626ea80c67775c092011c92" title="This tells what kind of event the upcall is handling.">ccn_upcall_kind</a> kind,
<a name="l00127"></a>00127            <span class="keyword">struct</span> <a class="code" href="structccn__upcall__info.html" title="Additional information provided in the upcall.">ccn_upcall_info</a> *info);
<a name="l00128"></a>00128 <span class="comment"></span>
<a name="l00129"></a>00129 <span class="comment">///////////////////////////////////////////////////////</span>
<a name="l00130"></a>00130 <span class="comment"></span><span class="comment">// Internal routines</span><span class="comment"></span>
<a name="l00131"></a>00131 <span class="comment">///////////////////////////////////////////////////////</span>
<a name="l00132"></a>00132 <span class="comment"></span>
<a name="l00133"></a><a class="code" href="ccn__fetch_8c.html#a7e8ee27c69f4d16d8ce0b45adf49f9ab">00133</a> <span class="keyword">static</span> <span class="keywordtype">char</span> *<a class="code" href="ccn__fetch_8c.html#a7e8ee27c69f4d16d8ce0b45adf49f9ab">globalNullString</a> = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00134"></a>00134 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00135"></a><a class="code" href="ccn__fetch_8c.html#a4caa1664e6311c2eb82a5ef980e9890f">00135</a> <a class="code" href="ccn__fetch_8c.html#a4caa1664e6311c2eb82a5ef980e9890f">newStringCopy</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *src) {
<a name="l00136"></a>00136         <span class="keywordtype">int</span> n = ((src == NULL) ? 0 : strlen(src));
<a name="l00137"></a>00137         <span class="keywordflow">if</span> (n &lt;= 0 || src == <a class="code" href="ccn__fetch_8c.html#a7e8ee27c69f4d16d8ce0b45adf49f9ab">globalNullString</a>) <span class="keywordflow">return</span> <a class="code" href="ccn__fetch_8c.html#a7e8ee27c69f4d16d8ce0b45adf49f9ab">globalNullString</a>;
<a name="l00138"></a>00138         <span class="keywordtype">char</span> *s = calloc(n+1, <span class="keyword">sizeof</span>(*s));
<a name="l00139"></a>00139         strncpy(s, src, n);
<a name="l00140"></a>00140         <span class="keywordflow">return</span> s;
<a name="l00141"></a>00141 }
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00144"></a><a class="code" href="ccn__fetch_8c.html#a6a63cd67624ab55e9bc78ce7af769cdf">00144</a> <a class="code" href="ccn__fetch_8c.html#a6a63cd67624ab55e9bc78ce7af769cdf">freeString</a>(<span class="keywordtype">char</span> * s) {
<a name="l00145"></a>00145         <span class="keywordflow">if</span> (s != NULL &amp;&amp; s != <a class="code" href="ccn__fetch_8c.html#a7e8ee27c69f4d16d8ce0b45adf49f9ab">globalNullString</a>)
<a name="l00146"></a>00146                 free(s);
<a name="l00147"></a>00147         <span class="keywordflow">return</span> NULL;
<a name="l00148"></a>00148 }
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *
<a name="l00151"></a><a class="code" href="ccn__fetch_8c.html#afee16db233fb7e8ee6e65dfe10bbaff5">00151</a> <a class="code" href="ccn__fetch_8c.html#afee16db233fb7e8ee6e65dfe10bbaff5">sequenced_name</a>(<span class="keyword">struct</span> <a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *<a class="code" href="ccnc_8c.html#a178e1112e389153c3928da85366014e1">basename</a>, <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> seq) {
<a name="l00152"></a>00152     <span class="comment">// creates a new struct ccn_charbuf *, appending the sequence number to the basename</span>
<a name="l00153"></a>00153         <span class="keyword">struct </span><a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *name = <a class="code" href="charbuf_8h.html#a6db2918ed16206ad07920ab26aac9da6">ccn_charbuf_create</a>();
<a name="l00154"></a>00154     <a class="code" href="charbuf_8h.html#aca88638b2e81602eb4a1da9be923dad7">ccn_charbuf_append_charbuf</a>(name, basename);
<a name="l00155"></a>00155         <span class="keywordflow">if</span> (seq &gt;= 0)
<a name="l00156"></a>00156                 <a class="code" href="ccn_8h.html#a3b95a770555b90f43d4876bea62c202d" title="Add a binary Component to a ccnb-encoded Name.">ccn_name_append_numeric</a>(name, <a class="code" href="ccn_8h.html#afec910e39c89dcf24a44f93e97032399af3eb8e7fa3a938a5bcc6c1f141357d71" title="consecutive block sequence numbers">CCN_MARKER_SEQNUM</a>, seq);
<a name="l00157"></a>00157     <span class="keywordflow">return</span>(name);
<a name="l00158"></a>00158 }
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *
<a name="l00161"></a><a class="code" href="ccn__fetch_8c.html#af6a2ec5f85d883e13a03691902b3f644">00161</a> <a class="code" href="ccn__fetch_8c.html#af6a2ec5f85d883e13a03691902b3f644">make_data_template</a>(<span class="keywordtype">int</span> maxSuffix) {
<a name="l00162"></a>00162         <span class="comment">// creates a template for interests that only have a name</span>
<a name="l00163"></a>00163         <span class="comment">// and a segment number</span>
<a name="l00164"></a>00164         <span class="keyword">struct </span><a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *cb = <a class="code" href="charbuf_8h.html#a6db2918ed16206ad07920ab26aac9da6">ccn_charbuf_create</a>();
<a name="l00165"></a>00165     <a class="code" href="ccn_8h.html#a2fded0bbb7253c024924baa53beda660" title="Append a ccnb start marker.">ccn_charbuf_append_tt</a>(cb, <a class="code" href="coding_8h.html#a720ee1182276ef229dcf775366d84f33ac3c02bb032cd835a5f9e439cadd0a455">CCN_DTAG_Interest</a>, <a class="code" href="coding_8h.html#a750e116f861c8e3f015cde245bbc0570aea37aecfff1efe438c628cfa8f18c449" title="starts composite - numval is tagdict index (enum ccn_dtag)">CCN_DTAG</a>);
<a name="l00166"></a>00166     <a class="code" href="ccn_8h.html#a2fded0bbb7253c024924baa53beda660" title="Append a ccnb start marker.">ccn_charbuf_append_tt</a>(cb, <a class="code" href="coding_8h.html#a720ee1182276ef229dcf775366d84f33a7903556a9a07652962c02014f7f7832f">CCN_DTAG_Name</a>, <a class="code" href="coding_8h.html#a750e116f861c8e3f015cde245bbc0570aea37aecfff1efe438c628cfa8f18c449" title="starts composite - numval is tagdict index (enum ccn_dtag)">CCN_DTAG</a>);
<a name="l00167"></a>00167     <a class="code" href="ccn_8h.html#ac8fba19d429bb106de10a008142882aa" title="Append a CCN_CLOSE.">ccn_charbuf_append_closer</a>(cb); <span class="comment">/* &lt;/Name&gt; */</span>
<a name="l00168"></a>00168     <a class="code" href="ccn_8h.html#a2fded0bbb7253c024924baa53beda660" title="Append a ccnb start marker.">ccn_charbuf_append_tt</a>(cb, <a class="code" href="coding_8h.html#a720ee1182276ef229dcf775366d84f33a7aad87e03f0facd444ae112ec6beaf84">CCN_DTAG_MaxSuffixComponents</a>, <a class="code" href="coding_8h.html#a750e116f861c8e3f015cde245bbc0570aea37aecfff1efe438c628cfa8f18c449" title="starts composite - numval is tagdict index (enum ccn_dtag)">CCN_DTAG</a>);
<a name="l00169"></a>00169     <a class="code" href="ccn_8h.html#af18933c1d395fb231d2a41c611314717" title="Append a non-negative integer as a UDATA.">ccnb_append_number</a>(cb, maxSuffix);
<a name="l00170"></a>00170     <a class="code" href="ccn_8h.html#ac8fba19d429bb106de10a008142882aa" title="Append a CCN_CLOSE.">ccn_charbuf_append_closer</a>(cb); <span class="comment">/* &lt;/MaxSuffixComponents&gt; */</span>
<a name="l00171"></a>00171     <a class="code" href="ccn_8h.html#ac8fba19d429bb106de10a008142882aa" title="Append a CCN_CLOSE.">ccn_charbuf_append_closer</a>(cb); <span class="comment">/* &lt;/Interest&gt; */</span>
<a name="l00172"></a>00172     <span class="keywordflow">return</span>(cb);
<a name="l00173"></a>00173 }
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="keyword">static</span> <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a>
<a name="l00176"></a><a class="code" href="ccn__fetch_8c.html#a953728c7a0521e732c80f76916f85c68">00176</a> <a class="code" href="ccn__fetch_8c.html#a953728c7a0521e732c80f76916f85c68">GetNumberFromInfo</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ccnb,
<a name="l00177"></a>00177                                   <span class="keyword">enum</span> <a class="code" href="coding_8h.html#a720ee1182276ef229dcf775366d84f33" title="DTAG identifies ccnb-encoded elements.">ccn_dtag</a> tt, <span class="keywordtype">size_t</span> start, <span class="keywordtype">size_t</span> stop) {
<a name="l00178"></a>00178         <span class="comment">// gets the binary number for the info</span>
<a name="l00179"></a>00179         <span class="comment">// based on the tag and the start and stop indexes</span>
<a name="l00180"></a>00180         <span class="comment">// returns -1 if the number does not appear to exist</span>
<a name="l00181"></a>00181         <span class="comment">// must be called from inside of CallMe</span>
<a name="l00182"></a>00182         <span class="keywordflow">if</span> (start &lt; stop) {
<a name="l00183"></a>00183                 <span class="keywordtype">size_t</span> len = 0;
<a name="l00184"></a>00184                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data = NULL;
<a name="l00185"></a>00185                 <a class="code" href="ccn_8h.html#af630540ae5874ba0b17f1960482a85a9">ccn_ref_tagged_BLOB</a>(tt, ccnb, start, stop, &amp;data, &amp;len);
<a name="l00186"></a>00186                 <span class="keywordflow">if</span> (len &gt; 0 &amp;&amp; data != NULL) {
<a name="l00187"></a>00187                         <span class="comment">// parse big-endian encoded number</span>
<a name="l00188"></a>00188                         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> n = 0;
<a name="l00189"></a>00189                         <span class="keywordtype">size_t</span> i;
<a name="l00190"></a>00190             <span class="keywordflow">for</span> (i = 0; i &lt; len; i++) {
<a name="l00191"></a>00191                                 n = n * 256 + data[i];
<a name="l00192"></a>00192                         }
<a name="l00193"></a>00193                         <span class="keywordflow">return</span> n;
<a name="l00194"></a>00194                 }
<a name="l00195"></a>00195         }
<a name="l00196"></a>00196         <span class="keywordflow">return</span> -1;
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="keyword">static</span> <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a>
<a name="l00200"></a><a class="code" href="ccn__fetch_8c.html#a625272b5d6d5ad3057f8fc8058cfdb55">00200</a> <a class="code" href="ccn__fetch_8c.html#a625272b5d6d5ad3057f8fc8058cfdb55">GetFinalSegment</a>(<span class="keyword">struct</span> <a class="code" href="structccn__upcall__info.html" title="Additional information provided in the upcall.">ccn_upcall_info</a> *info) {
<a name="l00201"></a>00201         <span class="comment">// gets the final segment number for the content</span>
<a name="l00202"></a>00202         <span class="comment">// returns -1 if it is not yet known</span>
<a name="l00203"></a>00203         <span class="comment">// must be called from inside of CallMe</span>
<a name="l00204"></a>00204         <span class="keywordflow">if</span> (info == NULL) <span class="keywordflow">return</span> -1;
<a name="l00205"></a>00205         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ccnb = info-&gt;<a class="code" href="structccn__upcall__info.html#a226aa6acbc2fe85ee7d400b52ef3664a">content_ccnb</a>;
<a name="l00206"></a>00206         <span class="keywordflow">if</span> (ccnb == NULL || info-&gt;<a class="code" href="structccn__upcall__info.html#a5483525206dfb80f831040d0d9602906">pco</a> == NULL) <span class="keywordflow">return</span> -1;
<a name="l00207"></a>00207         <span class="keywordtype">int</span> start = info-&gt;<a class="code" href="structccn__upcall__info.html#a5483525206dfb80f831040d0d9602906">pco</a>-&gt;<a class="code" href="structccn__parsed___content_object.html#a9812a65809374954710cb98556230d19">offset</a>[<a class="code" href="ccn_8h.html#a8bb16876590e11ec0ef1af93415b0387a430043d1637e992d68972dca8e349847">CCN_PCO_B_FinalBlockID</a>];
<a name="l00208"></a>00208         <span class="keywordtype">int</span> stop = info-&gt;<a class="code" href="structccn__upcall__info.html#a5483525206dfb80f831040d0d9602906">pco</a>-&gt;<a class="code" href="structccn__parsed___content_object.html#a9812a65809374954710cb98556230d19">offset</a>[<a class="code" href="ccn_8h.html#a8bb16876590e11ec0ef1af93415b0387a3324e176405ad15bd5c56205d98dc4c3">CCN_PCO_E_FinalBlockID</a>];
<a name="l00209"></a>00209         <span class="keywordflow">return</span> <a class="code" href="ccn__fetch_8c.html#a953728c7a0521e732c80f76916f85c68">GetNumberFromInfo</a>(ccnb, <a class="code" href="coding_8h.html#a720ee1182276ef229dcf775366d84f33a392fb90d4f87c192bf7847ca04562880">CCN_DTAG_FinalBlockID</a>, start, stop);
<a name="l00210"></a>00210 }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="keyword">static</span> <span class="keyword">struct </span>localClosure *
<a name="l00213"></a><a class="code" href="ccn__fetch_8c.html#ae7385fbae93ba851ede9d26f5551294c">00213</a> <a class="code" href="ccn__fetch_8c.html#ae7385fbae93ba851ede9d26f5551294c">AddSegRequest</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs, <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> seg) {
<a name="l00214"></a>00214         <span class="comment">// adds a segment request, returns NULL if already present</span>
<a name="l00215"></a>00215         <span class="comment">// or if the seg given is outside the valid range</span>
<a name="l00216"></a>00216         <span class="comment">// returns the new request if it was created</span>
<a name="l00217"></a>00217         FILE *<a class="code" href="ccnc_8c.html#ac3e1795766a80ec63b157951b4b9a7d4">debug</a> = fs-&gt;parent-&gt;debug;
<a name="l00218"></a>00218         <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0">ccn_fetch_flags</a> flags = fs-&gt;parent-&gt;debugFlags;
<a name="l00219"></a>00219         <span class="keywordflow">if</span> (seg &lt; 0) <span class="keywordflow">return</span> NULL;
<a name="l00220"></a>00220         <span class="keywordflow">if</span> (fs-&gt;finalSeg &gt;= 0 &amp;&amp; seg &gt; fs-&gt;finalSeg) <span class="keywordflow">return</span> NULL;
<a name="l00221"></a>00221         <span class="keyword">struct </span>localClosure *req = fs-&gt;requests;
<a name="l00222"></a>00222         <span class="keywordflow">while</span> (req != NULL) {
<a name="l00223"></a>00223                 <span class="keywordflow">if</span> (req-&gt;reqSeg == seg) <span class="keywordflow">return</span> NULL;
<a name="l00224"></a>00224                 req = req-&gt;next;
<a name="l00225"></a>00225         }
<a name="l00226"></a>00226         req = calloc(1, <span class="keyword">sizeof</span>(*req));
<a name="l00227"></a>00227         req-&gt;fs = fs;
<a name="l00228"></a>00228         req-&gt;reqSeg = seg;
<a name="l00229"></a>00229         req-&gt;startClock = <a class="code" href="ccn__fetch_8c.html#aff3b0edd6cf94b3fc5b9f042147c9181">GetCurrentTimeUSecs</a>();
<a name="l00230"></a>00230         req-&gt;next = fs-&gt;requests;
<a name="l00231"></a>00231         fs-&gt;requests = req;
<a name="l00232"></a>00232         <span class="keywordflow">if</span> (debug != NULL &amp;&amp; (flags &amp; <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0a577637c764de954385a9aff67dd58c99">ccn_fetch_flags_NoteAddRem</a>)) {
<a name="l00233"></a>00233                 fprintf(debug, <span class="stringliteral">&quot;-- ccn_fetch AddSegRequest %s, seg %jd\n&quot;</span>,
<a name="l00234"></a>00234                                 fs-&gt;id, seg);
<a name="l00235"></a>00235                 fflush(debug);
<a name="l00236"></a>00236         }
<a name="l00237"></a>00237         <span class="keywordflow">return</span> req;
<a name="l00238"></a>00238 }
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 <span class="keyword">static</span> <span class="keyword">struct </span>localClosure *
<a name="l00241"></a><a class="code" href="ccn__fetch_8c.html#adaac7b2bfe93c9fbfb1ac63f91453634">00241</a> <a class="code" href="ccn__fetch_8c.html#adaac7b2bfe93c9fbfb1ac63f91453634">RemSegRequest</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs, <span class="keyword">struct</span> localClosure *req) {
<a name="l00242"></a>00242         <span class="comment">// removes a segment request</span>
<a name="l00243"></a>00243         <span class="comment">// returns NULL if the request was removed</span>
<a name="l00244"></a>00244         <span class="comment">// if not found then just returns the request</span>
<a name="l00245"></a>00245         FILE *<a class="code" href="ccnc_8c.html#ac3e1795766a80ec63b157951b4b9a7d4">debug</a> = fs-&gt;parent-&gt;debug;
<a name="l00246"></a>00246         <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0">ccn_fetch_flags</a> flags = fs-&gt;parent-&gt;debugFlags;
<a name="l00247"></a>00247         <span class="keyword">struct </span>localClosure *<span class="keyword">this</span> = fs-&gt;requests;
<a name="l00248"></a>00248         <span class="keyword">struct </span>localClosure *lag = NULL;
<a name="l00249"></a>00249         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> seg = req-&gt;reqSeg;
<a name="l00250"></a>00250         <span class="keywordflow">while</span> (<span class="keyword">this</span> != NULL) {
<a name="l00251"></a>00251                 <span class="keyword">struct </span>localClosure *next = this-&gt;next;
<a name="l00252"></a>00252                 <span class="keywordflow">if</span> (<span class="keyword">this</span> == req) {
<a name="l00253"></a>00253                         <span class="keywordflow">if</span> (lag == NULL) {
<a name="l00254"></a>00254                                 fs-&gt;requests = next;
<a name="l00255"></a>00255                         } <span class="keywordflow">else</span> {
<a name="l00256"></a>00256                                 lag-&gt;next = next;
<a name="l00257"></a>00257                         }
<a name="l00258"></a>00258                         req-&gt;fs = NULL;
<a name="l00259"></a>00259                         <span class="keywordflow">if</span> (debug != NULL &amp;&amp; (flags &amp; <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0a577637c764de954385a9aff67dd58c99">ccn_fetch_flags_NoteAddRem</a>)) {
<a name="l00260"></a>00260                                 fprintf(debug, <span class="stringliteral">&quot;-- ccn_fetch RemSegRequest %s, seg %jd\n&quot;</span>,
<a name="l00261"></a>00261                                                 fs-&gt;id, seg);
<a name="l00262"></a>00262                                 fflush(debug);
<a name="l00263"></a>00263                         }
<a name="l00264"></a>00264                         <span class="keywordflow">return</span> NULL;
<a name="l00265"></a>00265                 }
<a name="l00266"></a>00266                 lag = <span class="keyword">this</span>;
<a name="l00267"></a>00267                 <span class="keyword">this</span> = next;
<a name="l00268"></a>00268         }
<a name="l00269"></a>00269         <span class="keywordflow">if</span> (debug != NULL &amp;&amp; (flags &amp; <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0a577637c764de954385a9aff67dd58c99">ccn_fetch_flags_NoteAddRem</a>)) {
<a name="l00270"></a>00270                 fprintf(debug, <span class="stringliteral">&quot;-- ccn_fetch RemSegRequest %s, seg %jd, NOT FOUND!\n&quot;</span>,
<a name="l00271"></a>00271                                 fs-&gt;id, seg);
<a name="l00272"></a>00272                 fflush(debug);
<a name="l00273"></a>00273         }
<a name="l00274"></a>00274         <span class="keywordflow">return</span> req;
<a name="l00275"></a>00275 }
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="keyword">static</span> <span class="keyword">struct </span>ccn_fetch_buffer *
<a name="l00278"></a><a class="code" href="ccn__fetch_8c.html#a4fd2d607c7cf61d64ebfaaf4c03fafac">00278</a> <a class="code" href="ccn__fetch_8c.html#a4fd2d607c7cf61d64ebfaaf4c03fafac">FindBufferForSeg</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs, <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> seg) {
<a name="l00279"></a>00279         <span class="comment">// finds the buffer object given the seg</span>
<a name="l00280"></a>00280         <span class="keyword">struct </span>ccn_fetch_buffer *fb = fs-&gt;bufList;
<a name="l00281"></a>00281         <span class="keywordflow">for</span> (;;) {
<a name="l00282"></a>00282                 <span class="keywordflow">if</span> (fb == NULL) <span class="keywordflow">break</span>;
<a name="l00283"></a>00283                 <span class="keywordflow">if</span> (fb-&gt;seg == seg) <span class="keywordflow">break</span>;
<a name="l00284"></a>00284                 fb = fb-&gt;next;
<a name="l00285"></a>00285         } 
<a name="l00286"></a>00286         <span class="keywordflow">return</span> fb;
<a name="l00287"></a>00287 }
<a name="l00288"></a>00288 
<a name="l00289"></a>00289 <span class="keyword">static</span> <span class="keyword">struct </span>ccn_fetch_buffer *
<a name="l00290"></a><a class="code" href="ccn__fetch_8c.html#af8eb6d3b33bc70e0c2d2e0245a6ab115">00290</a> <a class="code" href="ccn__fetch_8c.html#af8eb6d3b33bc70e0c2d2e0245a6ab115">FindBufferForPosition</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs, intmax_t pos) {
<a name="l00291"></a>00291         <span class="comment">// finds the buffer object given the seg</span>
<a name="l00292"></a>00292         <span class="keyword">struct </span>ccn_fetch_buffer *fb = fs-&gt;bufList;
<a name="l00293"></a>00293         <span class="keywordflow">for</span> (;;) {
<a name="l00294"></a>00294                 <span class="keywordflow">if</span> (fb == NULL) <span class="keywordflow">break</span>;
<a name="l00295"></a>00295                 intmax_t fp = fb-&gt;pos;
<a name="l00296"></a>00296                 <span class="keywordflow">if</span> (fp &gt;= 0 &amp;&amp; pos &gt;= fp &amp;&amp; pos &lt; fp+fb-&gt;len) <span class="keywordflow">break</span>;
<a name="l00297"></a>00297                 fb = fb-&gt;next;
<a name="l00298"></a>00298         } 
<a name="l00299"></a>00299         <span class="keywordflow">return</span> fb;
<a name="l00300"></a>00300 }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 <span class="keyword">static</span> intmax_t
<a name="l00303"></a><a class="code" href="ccn__fetch_8c.html#a7c5bd841d687141e25c74f3132274bef">00303</a> <a class="code" href="ccn__fetch_8c.html#a7c5bd841d687141e25c74f3132274bef">InferPosition</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs, <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> seg) {
<a name="l00304"></a>00304         intmax_t pos = -1; <span class="comment">// by default, size is unknown</span>
<a name="l00305"></a>00305         <span class="keywordflow">if</span> (seg == 0) {
<a name="l00306"></a>00306                 <span class="comment">// initial seg is easy, size regardless</span>
<a name="l00307"></a>00307                 pos = 0;
<a name="l00308"></a>00308         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fs-&gt;segSize &gt; 0) {
<a name="l00309"></a>00309                 <span class="comment">// fixed size is almost as easy</span>
<a name="l00310"></a>00310                 pos = seg*fs-&gt;segSize;
<a name="l00311"></a>00311         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (seg == fs-&gt;readSeg) {
<a name="l00312"></a>00312                 <span class="comment">// position is based on the current read position </span>
<a name="l00313"></a>00313                 pos = fs-&gt;readStart;
<a name="l00314"></a>00314         } <span class="keywordflow">else</span> {
<a name="l00315"></a>00315                 <span class="comment">// try to get the position from the previous buffer</span>
<a name="l00316"></a>00316                 <span class="keyword">struct </span>ccn_fetch_buffer *ofb = <a class="code" href="ccn__fetch_8c.html#a4fd2d607c7cf61d64ebfaaf4c03fafac">FindBufferForSeg</a>(fs, seg-1);
<a name="l00317"></a>00317                 <span class="keywordflow">if</span> (ofb != NULL &amp;&amp; ofb-&gt;pos &gt;= 0)
<a name="l00318"></a>00318                         pos = ofb-&gt;pos+ofb-&gt;len;
<a name="l00319"></a>00319         }
<a name="l00320"></a>00320         <span class="keywordflow">return</span> pos;
<a name="l00321"></a>00321 }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="keyword">static</span> <span class="keyword">struct </span>ccn_fetch_buffer *
<a name="l00324"></a><a class="code" href="ccn__fetch_8c.html#ade5ac015226bb2c5a77c2fcfa5fc1aca">00324</a> <a class="code" href="ccn__fetch_8c.html#ade5ac015226bb2c5a77c2fcfa5fc1aca">NewBufferForSeg</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs, <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> seg, <span class="keywordtype">size_t</span> len) {
<a name="l00325"></a>00325         <span class="comment">// makes a new buffer for the segment</span>
<a name="l00326"></a>00326         <span class="keyword">struct </span>ccn_fetch_buffer *fb = calloc(1, <span class="keyword">sizeof</span>(*fb));
<a name="l00327"></a>00327         <span class="keywordflow">if</span> (len &gt; 0) fb-&gt;buf = calloc(len, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>));
<a name="l00328"></a>00328         fb-&gt;seg = seg;
<a name="l00329"></a>00329         intmax_t pos = <a class="code" href="ccn__fetch_8c.html#a7c5bd841d687141e25c74f3132274bef">InferPosition</a>(fs, seg);
<a name="l00330"></a>00330         fb-&gt;pos = pos;
<a name="l00331"></a>00331         fb-&gt;len = len;
<a name="l00332"></a>00332         fs-&gt;nBufs++;
<a name="l00333"></a>00333         fb-&gt;next = fs-&gt;bufList;
<a name="l00334"></a>00334         fs-&gt;bufList = fb;
<a name="l00335"></a>00335         fs-&gt;segsAhead++;
<a name="l00336"></a>00336         <span class="keywordflow">if</span> (fs-&gt;segsAhead &gt;= fs-&gt;maxBufs) fs-&gt;segsAhead = fs-&gt;maxBufs-1;
<a name="l00337"></a>00337         <span class="keywordflow">if</span> (fs-&gt;segSize &lt;= 0 &amp;&amp; pos &gt;= 0) {
<a name="l00338"></a>00338                 <span class="comment">// segment size is variable or unknown</span>
<a name="l00339"></a>00339                 <span class="comment">// position for buffer is known, so propagate forwards</span>
<a name="l00340"></a>00340                 <span class="keywordflow">for</span> (;;) {
<a name="l00341"></a>00341                         <span class="keywordflow">if</span> (fs-&gt;fileSize &lt; 0) {
<a name="l00342"></a>00342                                 <span class="comment">// maybe we just found the file size</span>
<a name="l00343"></a>00343                                 <span class="keywordflow">if</span> (seg == fs-&gt;finalSeg
<a name="l00344"></a>00344                                         || (seg+1 == fs-&gt;finalSeg &amp;&amp; fs-&gt;finalSegLen == 0))
<a name="l00345"></a>00345                                         fs-&gt;fileSize = pos+len;
<a name="l00346"></a>00346                         }
<a name="l00347"></a>00347                         seg++;
<a name="l00348"></a>00348                         <span class="keyword">struct </span>ccn_fetch_buffer *ofb = <a class="code" href="ccn__fetch_8c.html#a4fd2d607c7cf61d64ebfaaf4c03fafac">FindBufferForSeg</a>(fs, seg);
<a name="l00349"></a>00349                         <span class="keywordflow">if</span> (ofb == NULL || ofb-&gt;pos &gt;= 0) <span class="keywordflow">break</span>;
<a name="l00350"></a>00350                         pos = pos + len;
<a name="l00351"></a>00351                         ofb-&gt;pos = pos;
<a name="l00352"></a>00352                         len = ofb-&gt;len;
<a name="l00353"></a>00353                 }
<a name="l00354"></a>00354         }
<a name="l00355"></a>00355         <span class="keywordflow">return</span> fb;
<a name="l00356"></a>00356 }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00359"></a><a class="code" href="ccn__fetch_8c.html#a68b971a7764a77135485cb3bbf42569e">00359</a> <a class="code" href="ccn__fetch_8c.html#a68b971a7764a77135485cb3bbf42569e">PruneSegments</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs) {
<a name="l00360"></a>00360         intmax_t start = fs-&gt;readStart;
<a name="l00361"></a>00361         <span class="keyword">struct </span>ccn_fetch_buffer *lag = NULL;
<a name="l00362"></a>00362         <span class="keyword">struct </span>ccn_fetch_buffer *fb = fs-&gt;bufList;
<a name="l00363"></a>00363         <span class="keywordflow">while</span> (fb != NULL &amp;&amp; fs-&gt;nBufs &gt; fs-&gt;maxBufs) {
<a name="l00364"></a>00364                 <span class="keyword">struct </span>ccn_fetch_buffer *next = fb-&gt;next;
<a name="l00365"></a>00365                 <span class="keywordflow">if</span> (fs-&gt;maxBufs == 0 || (fb-&gt;pos &gt;= 0 &amp;&amp; start &gt; (fb-&gt;pos + fb-&gt;len))) {
<a name="l00366"></a>00366                         <span class="comment">// this buffer is going away</span>
<a name="l00367"></a>00367                         <span class="comment">// note: keep buffer immediately before readStart if possible</span>
<a name="l00368"></a>00368                         <span class="keywordflow">if</span> (lag == NULL) {
<a name="l00369"></a>00369                                 fs-&gt;bufList = next;
<a name="l00370"></a>00370                         } <span class="keywordflow">else</span> {
<a name="l00371"></a>00371                                 lag-&gt;next = next;
<a name="l00372"></a>00372                         }
<a name="l00373"></a>00373                         <span class="keywordflow">if</span> (fb-&gt;buf != NULL) free(fb-&gt;buf);
<a name="l00374"></a>00374                         free(fb);
<a name="l00375"></a>00375                         fs-&gt;nBufs--;
<a name="l00376"></a>00376                 } <span class="keywordflow">else</span> {
<a name="l00377"></a>00377                         <span class="comment">// keep this buffer in play</span>
<a name="l00378"></a>00378                         lag = fb;
<a name="l00379"></a>00379                 }
<a name="l00380"></a>00380                 fb = next;
<a name="l00381"></a>00381         }
<a name="l00382"></a>00382 }
<a name="l00383"></a>00383 
<a name="l00384"></a>00384 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00385"></a><a class="code" href="ccn__fetch_8c.html#aed971b7efb9c939e2788eb5dff2c16e0">00385</a> <a class="code" href="ccn__fetch_8c.html#aed971b7efb9c939e2788eb5dff2c16e0">NeedSegment</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs, <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> seg) {
<a name="l00386"></a>00386         <span class="comment">// requests that a specific segment interest be registered</span>
<a name="l00387"></a>00387         <span class="comment">// but ONLY if it the request not already in flight</span>
<a name="l00388"></a>00388         <span class="comment">// AND the segment is not already in a buffer</span>
<a name="l00389"></a>00389         <span class="keyword">struct </span>ccn_fetch_buffer *fb = <a class="code" href="ccn__fetch_8c.html#a4fd2d607c7cf61d64ebfaaf4c03fafac">FindBufferForSeg</a>(fs, seg);
<a name="l00390"></a>00390         <span class="keywordflow">if</span> (fb != NULL)
<a name="l00391"></a>00391                 <span class="comment">// no point in requesting what we have</span>
<a name="l00392"></a>00392                 <span class="keywordflow">return</span>;
<a name="l00393"></a>00393         <span class="keywordflow">if</span> (fs-&gt;finalSeg &gt;= 0 &amp;&amp; seg &gt; fs-&gt;finalSeg)
<a name="l00394"></a>00394                 <span class="comment">// no point in requesting off the end, either</span>
<a name="l00395"></a>00395                 <span class="keywordflow">return</span>;
<a name="l00396"></a>00396         <span class="keywordflow">if</span> (fs-&gt;timeoutSeg &gt; 0 &amp;&amp; seg &gt;= fs-&gt;timeoutSeg)
<a name="l00397"></a>00397                 <span class="comment">// don&#39;t request a timed-out segment</span>
<a name="l00398"></a>00398                 <span class="keywordflow">return</span>;
<a name="l00399"></a>00399         <span class="keywordflow">if</span> (fs-&gt;zeroLenSeg &gt; 0 &amp;&amp; seg &gt;= fs-&gt;zeroLenSeg)
<a name="l00400"></a>00400                 <span class="comment">// don&#39;t request a zero-length segment</span>
<a name="l00401"></a>00401                 <span class="keywordflow">return</span>;
<a name="l00402"></a>00402         <span class="keyword">struct </span>localClosure *req = <a class="code" href="ccn__fetch_8c.html#ae7385fbae93ba851ede9d26f5551294c">AddSegRequest</a>(fs, seg);
<a name="l00403"></a>00403         <span class="keywordflow">if</span> (req != NULL) {
<a name="l00404"></a>00404                 FILE *<a class="code" href="ccnc_8c.html#ac3e1795766a80ec63b157951b4b9a7d4">debug</a> = fs-&gt;parent-&gt;debug;
<a name="l00405"></a>00405                 <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0">ccn_fetch_flags</a> flags = fs-&gt;parent-&gt;debugFlags;
<a name="l00406"></a>00406                 <span class="keyword">struct </span><a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *temp = <a class="code" href="ccn__fetch_8c.html#afee16db233fb7e8ee6e65dfe10bbaff5">sequenced_name</a>(fs-&gt;name, seg);
<a name="l00407"></a>00407                 <span class="keyword">struct </span>ccn *h = fs-&gt;parent-&gt;h;
<a name="l00408"></a>00408                 <span class="keyword">struct </span><a class="code" href="structccn__closure.html" title="Handle for upcalls that allow clients receive notifications of incoming interests...">ccn_closure</a> *action = calloc(1, <span class="keyword">sizeof</span>(*action));
<a name="l00409"></a>00409                 action-&gt;<a class="code" href="structccn__closure.html#a7173ea9b9dde3c4bbded120b90ae788c" title="for client use">data</a> = req;
<a name="l00410"></a>00410                 action-&gt;<a class="code" href="structccn__closure.html#a48dca74271023e0caf287ad31dd1e66c" title="client-supplied handler">p</a> = &amp;<a class="code" href="ccn__fetch_8c.html#a05048f9a77fdc4341b88e8a89a3be7fa">CallMe</a>;
<a name="l00411"></a>00411                 <span class="keywordtype">int</span> res = <a class="code" href="ccn_8h.html#a9f2d6eede46c8aac3dbb4b6e22e1d492">ccn_express_interest</a>(h, temp, action, fs-&gt;interest);
<a name="l00412"></a>00412                 <a class="code" href="charbuf_8h.html#a699030e7cb3c51ca2cde46af0ba6e1bb">ccn_charbuf_destroy</a>(&amp;temp);
<a name="l00413"></a>00413                 <span class="keywordflow">if</span> (res &gt;= 0) {
<a name="l00414"></a>00414                         <span class="comment">// the ccn connection accepted our request</span>
<a name="l00415"></a>00415                         fs-&gt;reqBusy++;
<a name="l00416"></a>00416                         fs-&gt;segsRequested++;
<a name="l00417"></a>00417                         <span class="keywordflow">if</span> (debug != NULL &amp;&amp; (flags &amp; <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0ac8f2f5a456615ca8a2cd9f27c5025d52">ccn_fetch_flags_NoteNeed</a>)) {
<a name="l00418"></a>00418                                 fprintf(debug,
<a name="l00419"></a>00419                                                 <span class="stringliteral">&quot;-- ccn_fetch NeedSegment %s, seg %jd&quot;</span>,
<a name="l00420"></a>00420                                                 fs-&gt;id, seg);
<a name="l00421"></a>00421                                 <span class="keywordflow">if</span> (fs-&gt;finalSeg &gt;= 0)
<a name="l00422"></a>00422                                         fprintf(debug, <span class="stringliteral">&quot;, final %jd&quot;</span>, fs-&gt;finalSeg);
<a name="l00423"></a>00423                                 fprintf(debug, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l00424"></a>00424                                 fflush(debug);
<a name="l00425"></a>00425                         }
<a name="l00426"></a>00426                         <span class="keywordflow">return</span>;
<a name="l00427"></a>00427                 }
<a name="l00428"></a>00428                 <span class="comment">// the request was not placed, so get rid of the evidence</span>
<a name="l00429"></a>00429                 <span class="comment">// CallMe won&#39;t get a chance to free it</span>
<a name="l00430"></a>00430                 <span class="keywordflow">if</span> (debug != NULL &amp;&amp; (flags &amp; <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0ac8f2f5a456615ca8a2cd9f27c5025d52">ccn_fetch_flags_NoteNeed</a>)) {
<a name="l00431"></a>00431                         fprintf(debug,
<a name="l00432"></a>00432                                         <span class="stringliteral">&quot;** ccn_fetch NeedSegment failed, %s, seg %jd\n&quot;</span>,
<a name="l00433"></a>00433                                         fs-&gt;id, seg);
<a name="l00434"></a>00434                         fflush(debug);
<a name="l00435"></a>00435                 }
<a name="l00436"></a>00436                 <a class="code" href="ccn__fetch_8c.html#adaac7b2bfe93c9fbfb1ac63f91453634">RemSegRequest</a>(fs, req);
<a name="l00437"></a>00437                 free(req);
<a name="l00438"></a>00438                 free(action);
<a name="l00439"></a>00439         
<a name="l00440"></a>00440         }
<a name="l00441"></a>00441 }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00444"></a><a class="code" href="ccn__fetch_8c.html#a0a389d694ce4fb464d4327c74b8bee1b">00444</a> <a class="code" href="ccn__fetch_8c.html#a0a389d694ce4fb464d4327c74b8bee1b">NeedSegments</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs) {
<a name="l00445"></a>00445         <span class="comment">// determines which segments should be requested</span>
<a name="l00446"></a>00446         <span class="comment">// based on the current readSeg and maxBufs </span>
<a name="l00447"></a>00447         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> loSeg = fs-&gt;readSeg;
<a name="l00448"></a>00448         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> hiSeg = loSeg+fs-&gt;segsAhead;
<a name="l00449"></a>00449         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> finalSeg = fs-&gt;finalSeg;
<a name="l00450"></a>00450         <span class="keywordflow">if</span> (finalSeg &gt;= 0 &amp;&amp; hiSeg &gt; finalSeg) hiSeg = finalSeg;
<a name="l00451"></a>00451         <span class="keywordflow">if</span> (loSeg &gt; hiSeg) hiSeg = loSeg;
<a name="l00452"></a>00452         <span class="keywordflow">while</span> (loSeg &lt;= hiSeg) {
<a name="l00453"></a>00453                 <span class="comment">// try to request needed segments</span>
<a name="l00454"></a>00454                 <a class="code" href="ccn__fetch_8c.html#aed971b7efb9c939e2788eb5dff2c16e0">NeedSegment</a>(fs, loSeg);
<a name="l00455"></a>00455                 loSeg++;
<a name="l00456"></a>00456         }
<a name="l00457"></a>00457 }
<a name="l00458"></a>00458 
<a name="l00459"></a>00459 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00460"></a><a class="code" href="ccn__fetch_8c.html#a430d1422e27507e3b926f3b13efa3830">00460</a> <a class="code" href="ccn__fetch_8c.html#a430d1422e27507e3b926f3b13efa3830">ShowDelta</a>(FILE *f, <a class="code" href="ccn__fetch_8c.html#a1f969ace41b81f43e4b15f4a80906503">TimeMarker</a> from) {
<a name="l00461"></a>00461         intmax_t dt = <a class="code" href="ccn__fetch_8c.html#a43f0ed286bea5e2b05ccb70da559a8d1">DeltaTime</a>(from, <a class="code" href="ccn__fetch_8c.html#aff3b0edd6cf94b3fc5b9f042147c9181">GetCurrentTimeUSecs</a>());
<a name="l00462"></a>00462         fprintf(f, <span class="stringliteral">&quot;, dt %jd.%06d\n&quot;</span>, dt / 1000000, (<span class="keywordtype">int</span>) (dt % 1000000));
<a name="l00463"></a>00463         fflush(f);
<a name="l00464"></a>00464 }
<a name="l00465"></a>00465 
<a name="l00466"></a>00466 <span class="keyword">static</span> <span class="keyword">enum</span> <a class="code" href="ccn_8h.html#ac4cc3fdb432fd23cdc0c5642276b0ddc" title="Upcalls return one of these values.">ccn_upcall_res</a>
<a name="l00467"></a><a class="code" href="ccn__fetch_8c.html#a05048f9a77fdc4341b88e8a89a3be7fa">00467</a> <a class="code" href="ccn__fetch_8c.html#a05048f9a77fdc4341b88e8a89a3be7fa">CallMe</a>(<span class="keyword">struct</span> <a class="code" href="structccn__closure.html" title="Handle for upcalls that allow clients receive notifications of incoming interests...">ccn_closure</a> *selfp,
<a name="l00468"></a>00468            <span class="keyword">enum</span> <a class="code" href="ccn_8h.html#a5fcebad21626ea80c67775c092011c92" title="This tells what kind of event the upcall is handling.">ccn_upcall_kind</a> kind,
<a name="l00469"></a>00469            <span class="keyword">struct</span> <a class="code" href="structccn__upcall__info.html" title="Additional information provided in the upcall.">ccn_upcall_info</a> *info) {
<a name="l00470"></a>00470         <span class="comment">// CallMe is the callback routine invoked by ccn_run when a registered</span>
<a name="l00471"></a>00471         <span class="comment">// interest has something interesting happen.</span>
<a name="l00472"></a>00472     <span class="keyword">struct </span>localClosure *req = (<span class="keyword">struct </span>localClosure *)selfp-&gt;<a class="code" href="structccn__closure.html#a7173ea9b9dde3c4bbded120b90ae788c" title="for client use">data</a>;
<a name="l00473"></a>00473         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> thisSeg = req-&gt;reqSeg;
<a name="l00474"></a>00474     <span class="keyword">struct</span> ccn_fetch_stream *fs = (<span class="keyword">struct</span> ccn_fetch_stream *) req-&gt;fs;
<a name="l00475"></a>00475         <span class="keywordflow">if</span> (fs == NULL) {
<a name="l00476"></a>00476                 <span class="keywordflow">if</span> (kind == <a class="code" href="ccn_8h.html#a5fcebad21626ea80c67775c092011c92ad00afdf8a89c718f4c451600b115b5e0" title="handler is about to be deregistered">CCN_UPCALL_FINAL</a>) {
<a name="l00477"></a>00477                         <span class="comment">// orphaned, so just get rid of it</span>
<a name="l00478"></a>00478                         free(req);
<a name="l00479"></a>00479                         free(selfp);
<a name="l00480"></a>00480                 }
<a name="l00481"></a>00481                 <span class="keywordflow">return</span>(<a class="code" href="ccn_8h.html#ac4cc3fdb432fd23cdc0c5642276b0ddcadadb47635316f12c6542c33cebcfa727" title="normal upcall return">CCN_UPCALL_RESULT_OK</a>);
<a name="l00482"></a>00482         }
<a name="l00483"></a>00483         FILE *<a class="code" href="ccnc_8c.html#ac3e1795766a80ec63b157951b4b9a7d4">debug</a> = fs-&gt;parent-&gt;debug;
<a name="l00484"></a>00484         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> finalSeg = fs-&gt;finalSeg;
<a name="l00485"></a>00485         <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0">ccn_fetch_flags</a> flags = fs-&gt;parent-&gt;debugFlags;
<a name="l00486"></a>00486         <span class="keywordflow">if</span> (finalSeg &lt; 0) {
<a name="l00487"></a>00487                 <span class="comment">// worth a try to find the last segment</span>
<a name="l00488"></a>00488                 finalSeg = <a class="code" href="ccn__fetch_8c.html#a625272b5d6d5ad3057f8fc8058cfdb55">GetFinalSegment</a>(info);
<a name="l00489"></a>00489                 fs-&gt;finalSeg = finalSeg;
<a name="l00490"></a>00490         }
<a name="l00491"></a>00491     
<a name="l00492"></a>00492         <span class="keywordflow">switch</span> (kind) {
<a name="l00493"></a>00493                 <span class="keywordflow">case</span> <a class="code" href="ccn_8h.html#a5fcebad21626ea80c67775c092011c92ad00afdf8a89c718f4c451600b115b5e0" title="handler is about to be deregistered">CCN_UPCALL_FINAL</a>:
<a name="l00494"></a>00494                         <span class="comment">// this is the cleanup for an expressed interest</span>
<a name="l00495"></a>00495                         req = <a class="code" href="ccn__fetch_8c.html#adaac7b2bfe93c9fbfb1ac63f91453634">RemSegRequest</a>(fs, req);
<a name="l00496"></a>00496                         <span class="keywordflow">if</span> (fs-&gt;reqBusy &gt; 0) fs-&gt;reqBusy--;
<a name="l00497"></a>00497                         free(selfp);
<a name="l00498"></a>00498                         <span class="keywordflow">return</span>(<a class="code" href="ccn_8h.html#ac4cc3fdb432fd23cdc0c5642276b0ddcadadb47635316f12c6542c33cebcfa727" title="normal upcall return">CCN_UPCALL_RESULT_OK</a>);
<a name="l00499"></a>00499                 <span class="keywordflow">case</span> <a class="code" href="ccn_8h.html#a5fcebad21626ea80c67775c092011c92a3c7ef9861eb5ba1529b4d05630e83c88" title="interest timed out">CCN_UPCALL_INTEREST_TIMED_OUT</a>: {
<a name="l00500"></a>00500                         <span class="keywordflow">if</span> (finalSeg &gt;= 0 &amp;&amp; thisSeg &gt; finalSeg)
<a name="l00501"></a>00501                                 <span class="comment">// ignore this timeout quickly</span>
<a name="l00502"></a>00502                                 <span class="keywordflow">return</span>(<a class="code" href="ccn_8h.html#ac4cc3fdb432fd23cdc0c5642276b0ddcadadb47635316f12c6542c33cebcfa727" title="normal upcall return">CCN_UPCALL_RESULT_OK</a>);
<a name="l00503"></a>00503                         intmax_t dt = <a class="code" href="ccn__fetch_8c.html#a43f0ed286bea5e2b05ccb70da559a8d1">DeltaTime</a>(req-&gt;startClock, <a class="code" href="ccn__fetch_8c.html#aff3b0edd6cf94b3fc5b9f042147c9181">GetCurrentTimeUSecs</a>());
<a name="l00504"></a>00504                         <span class="keywordflow">if</span> (dt &gt;= fs-&gt;timeoutUSecs) {
<a name="l00505"></a>00505                                 <span class="comment">// timed out, too many retries</span>
<a name="l00506"></a>00506                                 <span class="comment">// assume that this interest will never produce</span>
<a name="l00507"></a>00507                                 <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> timeoutSeg = fs-&gt;timeoutSeg;
<a name="l00508"></a>00508                                 fs-&gt;timeoutsSeen++;
<a name="l00509"></a>00509                                 fs-&gt;segsAhead = 0;
<a name="l00510"></a>00510                                 <span class="keywordflow">if</span> (timeoutSeg &lt; 0 || thisSeg &lt; timeoutSeg) {
<a name="l00511"></a>00511                                         <span class="comment">// we can infer a new timeoutSeg</span>
<a name="l00512"></a>00512                                         fs-&gt;timeoutSeg = thisSeg;
<a name="l00513"></a>00513                                 }
<a name="l00514"></a>00514                                 <span class="keywordflow">if</span> (debug != NULL &amp;&amp; (flags &amp; <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0aaf99b49dc30582fbfa2b0f09503a9736">ccn_fetch_flags_NoteTimeout</a>)) {
<a name="l00515"></a>00515                                         fprintf(debug, 
<a name="l00516"></a>00516                                                         <span class="stringliteral">&quot;** ccn_fetch timeout, %s, seg %jd&quot;</span>,
<a name="l00517"></a>00517                                                         fs-&gt;id, thisSeg);
<a name="l00518"></a>00518                                         fprintf(debug, 
<a name="l00519"></a>00519                                                         <span class="stringliteral">&quot;, dt %jd us, timeoutUSecs %jd\n&quot;</span>,
<a name="l00520"></a>00520                                                         dt, fs-&gt;timeoutUSecs);
<a name="l00521"></a>00521                                         fflush(debug);
<a name="l00522"></a>00522                                 }
<a name="l00523"></a>00523                                 <span class="keywordflow">return</span>(<a class="code" href="ccn_8h.html#ac4cc3fdb432fd23cdc0c5642276b0ddcadadb47635316f12c6542c33cebcfa727" title="normal upcall return">CCN_UPCALL_RESULT_OK</a>);
<a name="l00524"></a>00524                         }
<a name="l00525"></a>00525                         <span class="comment">// TBD: may need to reseed bloom filter?  who to ask?</span>
<a name="l00526"></a>00526                         <span class="keywordflow">return</span>(<a class="code" href="ccn_8h.html#ac4cc3fdb432fd23cdc0c5642276b0ddca686785df48ac222ef31beea39eebd404" title="reexpress the same interest again">CCN_UPCALL_RESULT_REEXPRESS</a>);
<a name="l00527"></a>00527                 }
<a name="l00528"></a>00528                 <span class="keywordflow">case</span> <a class="code" href="ccn_8h.html#a5fcebad21626ea80c67775c092011c92a8db121649c55820013bfaaf65e436f5c" title="content that has not been verified">CCN_UPCALL_CONTENT_UNVERIFIED</a>:
<a name="l00529"></a>00529                         <span class="keywordflow">return</span> (<a class="code" href="ccn_8h.html#ac4cc3fdb432fd23cdc0c5642276b0ddcaacded567eed5b8559bd0e6b30ab241ce" title="force an unverified result to be verified">CCN_UPCALL_RESULT_VERIFY</a>);
<a name="l00530"></a>00530                 <span class="keywordflow">case</span> <a class="code" href="ccn_8h.html#a5fcebad21626ea80c67775c092011c92a1b0d17f15edd2e43d9a026d19498ab7c" title="key has not been fetched">CCN_UPCALL_CONTENT_KEYMISSING</a>:
<a name="l00531"></a>00531                         <span class="keywordflow">return</span> (<a class="code" href="ccn_8h.html#ac4cc3fdb432fd23cdc0c5642276b0ddcacd6ea884bd093194e63bb68acbb784d1" title="request fetching of an unfetched key">CCN_UPCALL_RESULT_FETCHKEY</a>);
<a name="l00532"></a>00532                 <span class="keywordflow">case</span> <a class="code" href="ccn_8h.html#a5fcebad21626ea80c67775c092011c92a28260b0a25b7046e6930f0b13a718db0" title="incoming verified content">CCN_UPCALL_CONTENT</a>:
<a name="l00533"></a>00533                 <span class="keywordflow">case</span> <a class="code" href="ccn_8h.html#a5fcebad21626ea80c67775c092011c92aa96e60c7c64a5a65145b918cf6fcb4b4" title="verification has not been attempted">CCN_UPCALL_CONTENT_RAW</a>:
<a name="l00534"></a>00534                         <span class="keywordflow">if</span> (fs-&gt;timeoutSeg &gt;= 0 &amp;&amp; fs-&gt;timeoutSeg &lt;= thisSeg)
<a name="l00535"></a>00535                                 <span class="comment">// we will ignore this, since we are blocked</span>
<a name="l00536"></a>00536                                 <span class="keywordflow">return</span>(<a class="code" href="ccn_8h.html#ac4cc3fdb432fd23cdc0c5642276b0ddcadadb47635316f12c6542c33cebcfa727" title="normal upcall return">CCN_UPCALL_RESULT_OK</a>);
<a name="l00537"></a>00537                         <span class="keywordflow">break</span>;
<a name="l00538"></a>00538                 <span class="keywordflow">default</span>:
<a name="l00539"></a>00539                         <span class="comment">// SHOULD NOT HAPPEN</span>
<a name="l00540"></a>00540                         <span class="keywordflow">return</span>(<a class="code" href="ccn_8h.html#ac4cc3fdb432fd23cdc0c5642276b0ddca66af9fd66092212c05d898ca20d3c6f2" title="upcall detected an error">CCN_UPCALL_RESULT_ERR</a>);
<a name="l00541"></a>00541     }
<a name="l00542"></a>00542         
<a name="l00543"></a>00543         <span class="keyword">struct </span>ccn_fetch_buffer *fb = <a class="code" href="ccn__fetch_8c.html#a4fd2d607c7cf61d64ebfaaf4c03fafac">FindBufferForSeg</a>(fs, thisSeg);
<a name="l00544"></a>00544         <span class="keywordflow">if</span> (fb == NULL) {
<a name="l00545"></a>00545                 <span class="comment">// we don&#39;t already have the data yet</span>
<a name="l00546"></a>00546                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *data = NULL;
<a name="l00547"></a>00547                 <span class="keywordtype">size_t</span> dataLen = 0;
<a name="l00548"></a>00548                 <span class="keywordtype">size_t</span> ccnb_size = info-&gt;<a class="code" href="structccn__upcall__info.html#a5483525206dfb80f831040d0d9602906">pco</a>-&gt;<a class="code" href="structccn__parsed___content_object.html#a9812a65809374954710cb98556230d19">offset</a>[<a class="code" href="ccn_8h.html#a8bb16876590e11ec0ef1af93415b0387a1d25adf694c64b4ae597b26abe6b30fc">CCN_PCO_E</a>];
<a name="l00549"></a>00549                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ccnb = info-&gt;<a class="code" href="structccn__upcall__info.html#a226aa6acbc2fe85ee7d400b52ef3664a">content_ccnb</a>;
<a name="l00550"></a>00550                 <span class="keywordtype">int</span> res = <a class="code" href="ccn_8h.html#ac3a7a8cad96caf34fc73240b20f07cd2">ccn_content_get_value</a>(ccnb, ccnb_size, info-&gt;<a class="code" href="structccn__upcall__info.html#a5483525206dfb80f831040d0d9602906">pco</a>,
<a name="l00551"></a>00551                                                                                 &amp;data, &amp;dataLen);
<a name="l00552"></a>00552                 
<a name="l00553"></a>00553                 <span class="keywordflow">if</span> (res &lt; 0 || (thisSeg != finalSeg &amp;&amp; dataLen == 0)) {
<a name="l00554"></a>00554                         <span class="comment">// we got a bogus result, no data in this content!</span>
<a name="l00555"></a>00555                         <span class="keywordflow">if</span> (debug != NULL &amp;&amp; (flags &amp; <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0a577637c764de954385a9aff67dd58c99">ccn_fetch_flags_NoteAddRem</a>)) {
<a name="l00556"></a>00556                                 fprintf(debug, 
<a name="l00557"></a>00557                                                 <span class="stringliteral">&quot;-- ccn_fetch no data, %s, seg %jd, final %jd&quot;</span>,
<a name="l00558"></a>00558                                                 fs-&gt;id, thisSeg, finalSeg);
<a name="l00559"></a>00559                                 <a class="code" href="ccn__fetch_8c.html#a430d1422e27507e3b926f3b13efa3830">ShowDelta</a>(debug, req-&gt;startClock);
<a name="l00560"></a>00560                         }
<a name="l00561"></a>00561                         <span class="keywordflow">if</span> (fs-&gt;zeroLenSeg &lt; 0 || thisSeg &lt; fs-&gt;zeroLenSeg)
<a name="l00562"></a>00562                                 <span class="comment">// note this problem for future reporting</span>
<a name="l00563"></a>00563                                 fs-&gt;zeroLenSeg = thisSeg;
<a name="l00564"></a>00564                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (thisSeg == finalSeg &amp;&amp; dataLen == 0) {
<a name="l00565"></a>00565                         <span class="comment">// EOF, but no buffer needed</span>
<a name="l00566"></a>00566                         <span class="keywordflow">if</span> (fs-&gt;fileSize &lt; 0)
<a name="l00567"></a>00567                                 fs-&gt;fileSize = <a class="code" href="ccn__fetch_8c.html#a7c5bd841d687141e25c74f3132274bef">InferPosition</a>(fs, thisSeg);
<a name="l00568"></a>00568                         fs-&gt;finalSeg = finalSeg-1;
<a name="l00569"></a>00569                         <span class="keywordflow">if</span> (debug != NULL &amp;&amp; (flags &amp; <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0ab01ffa8a797b2d78fdf20efd78c26330">ccn_fetch_flags_NoteFinal</a>)) {
<a name="l00570"></a>00570                                 fprintf(debug, 
<a name="l00571"></a>00571                                                 <span class="stringliteral">&quot;-- ccn_fetch EOF, %s, seg %jd, len %d, fs %jd&quot;</span>,
<a name="l00572"></a>00572                                                 fs-&gt;id, thisSeg,
<a name="l00573"></a>00573                                                 (<span class="keywordtype">int</span>) dataLen,
<a name="l00574"></a>00574                                                 fs-&gt;fileSize);
<a name="l00575"></a>00575                                 <a class="code" href="ccn__fetch_8c.html#a430d1422e27507e3b926f3b13efa3830">ShowDelta</a>(debug, req-&gt;startClock);
<a name="l00576"></a>00576                         }
<a name="l00577"></a>00577                         
<a name="l00578"></a>00578                 } <span class="keywordflow">else</span> {
<a name="l00579"></a>00579                         <span class="comment">// alloc a buffer and transfer the data</span>
<a name="l00580"></a>00580                         
<a name="l00581"></a>00581                         <span class="keywordflow">if</span> (fs-&gt;segSize == 0) {
<a name="l00582"></a>00582                                 <span class="comment">// assuming fixed size segments, so any should do</span>
<a name="l00583"></a>00583                                 <span class="comment">// EXCEPT for an incomplete final segment</span>
<a name="l00584"></a>00584                                 <span class="keywordflow">if</span> (thisSeg == 0 || thisSeg &lt; finalSeg)
<a name="l00585"></a>00585                                         fs-&gt;segSize = dataLen;
<a name="l00586"></a>00586                         }
<a name="l00587"></a>00587                         <span class="keywordflow">if</span> (thisSeg == finalSeg) fs-&gt;finalSegLen = dataLen;
<a name="l00588"></a>00588                         <span class="keyword">struct </span>ccn_fetch_buffer *fb = <a class="code" href="ccn__fetch_8c.html#ade5ac015226bb2c5a77c2fcfa5fc1aca">NewBufferForSeg</a>(fs, thisSeg, dataLen);
<a name="l00589"></a>00589                         memcpy(fb-&gt;buf, data, dataLen);
<a name="l00590"></a>00590                         <span class="keywordflow">if</span> (debug != NULL &amp;&amp; (flags &amp; <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0aa0fced39c39406a233be83c10cb908f6">ccn_fetch_flags_NoteFill</a>)) {
<a name="l00591"></a>00591                                 fprintf(debug, 
<a name="l00592"></a>00592                                                 <span class="stringliteral">&quot;-- ccn_fetch FillSeg, %s, seg %jd, len %d, nbuf %d&quot;</span>,
<a name="l00593"></a>00593                                                 fs-&gt;id, thisSeg, (<span class="keywordtype">int</span>) dataLen, (<span class="keywordtype">int</span>) fs-&gt;nBufs);
<a name="l00594"></a>00594                                 <a class="code" href="ccn__fetch_8c.html#a430d1422e27507e3b926f3b13efa3830">ShowDelta</a>(debug, req-&gt;startClock);
<a name="l00595"></a>00595                         }
<a name="l00596"></a>00596                         <span class="keywordflow">if</span> (thisSeg == finalSeg) {
<a name="l00597"></a>00597                                 <span class="comment">// the file size is known in segments</span>
<a name="l00598"></a>00598                                 <span class="keywordflow">if</span> (fs-&gt;segSize &lt;= 0) {
<a name="l00599"></a>00599                                         <span class="comment">// variable or unknown segment size</span>
<a name="l00600"></a>00600                                         <span class="keywordflow">if</span> (fb-&gt;pos &gt;= 0) {
<a name="l00601"></a>00601                                                 fs-&gt;fileSize = fb-&gt;pos + dataLen;
<a name="l00602"></a>00602                                         }
<a name="l00603"></a>00603                                 } <span class="keywordflow">else</span> {
<a name="l00604"></a>00604                                         <span class="comment">// fixed segment size, so file size is now known</span>
<a name="l00605"></a>00605                                         fs-&gt;fileSize = thisSeg * fs-&gt;segSize + dataLen;
<a name="l00606"></a>00606                                 }
<a name="l00607"></a>00607                                 <span class="keywordflow">if</span> (debug != NULL &amp;&amp; (flags &amp; <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0ab01ffa8a797b2d78fdf20efd78c26330">ccn_fetch_flags_NoteFinal</a>)) {
<a name="l00608"></a>00608                                         fprintf(debug, 
<a name="l00609"></a>00609                                                         <span class="stringliteral">&quot;-- ccn_fetch EOF, %s, seg %jd, len %d, fs %jd&quot;</span>,
<a name="l00610"></a>00610                                                         fs-&gt;id, thisSeg, (<span class="keywordtype">int</span>) dataLen, fs-&gt;fileSize);
<a name="l00611"></a>00611                                         <a class="code" href="ccn__fetch_8c.html#a430d1422e27507e3b926f3b13efa3830">ShowDelta</a>(debug, req-&gt;startClock);
<a name="l00612"></a>00612                                 }
<a name="l00613"></a>00613                         }
<a name="l00614"></a>00614                         fs-&gt;segsRead++;
<a name="l00615"></a>00615                 }
<a name="l00616"></a>00616         }
<a name="l00617"></a>00617         
<a name="l00618"></a>00618         <a class="code" href="ccn_8h.html#a1f48aec24780ebc7f0ee8f6305ba8246" title="Modify ccn_run timeout.">ccn_set_run_timeout</a>(fs-&gt;parent-&gt;h, 0);
<a name="l00619"></a>00619         <span class="keywordflow">return</span>(<a class="code" href="ccn_8h.html#ac4cc3fdb432fd23cdc0c5642276b0ddcadadb47635316f12c6542c33cebcfa727" title="normal upcall return">CCN_UPCALL_RESULT_OK</a>);
<a name="l00620"></a>00620 }
<a name="l00621"></a>00621 <span class="comment"></span>
<a name="l00622"></a>00622 <span class="comment">///////////////////////////////////////////////////////</span>
<a name="l00623"></a>00623 <span class="comment"></span><span class="comment">// External routines</span><span class="comment"></span>
<a name="l00624"></a>00624 <span class="comment">///////////////////////////////////////////////////////</span>
<a name="l00625"></a>00625 <span class="comment"></span><span class="comment"></span>
<a name="l00626"></a>00626 <span class="comment">/**</span>
<a name="l00627"></a>00627 <span class="comment"> * Creates a new ccn_fetch object using the given ccn connection.</span>
<a name="l00628"></a>00628 <span class="comment"> * If h == NULL, attempts to create a new connection automatically.</span>
<a name="l00629"></a>00629 <span class="comment"> * @returns NULL if the creation was not successful</span>
<a name="l00630"></a>00630 <span class="comment"> * (only can happen for the h == NULL case).</span>
<a name="l00631"></a>00631 <span class="comment"> */</span>
<a name="l00632"></a>00632 <span class="keyword">extern</span> <span class="keyword">struct </span>ccn_fetch *
<a name="l00633"></a><a class="code" href="ccn__fetch_8c.html#a3f4d28268e28e1d44bfbeefcdc4caba8">00633</a> <a class="code" href="fetch_8h.html#a3f4d28268e28e1d44bfbeefcdc4caba8" title="Creates a new ccn_fetch object using the given ccn connection.">ccn_fetch_new</a>(<span class="keyword">struct</span> ccn *h) {
<a name="l00634"></a>00634         <span class="keyword">struct </span>ccn_fetch *f = calloc(1, <span class="keyword">sizeof</span>(*f));
<a name="l00635"></a>00635         <span class="keywordflow">if</span> (h == NULL) {
<a name="l00636"></a>00636                 h = <a class="code" href="ccn_8h.html#aabd4b8732f28cfec43435b455a6eec7e" title="Create a client handle.">ccn_create</a>();
<a name="l00637"></a>00637                 <span class="keywordtype">int</span> connRes = <a class="code" href="ccn_8h.html#a0819949d7e37dc90360b46b861dc409b" title="Connect to local ccnd.">ccn_connect</a>(h, NULL);
<a name="l00638"></a>00638                 <span class="keywordflow">if</span> (connRes &lt; 0) {
<a name="l00639"></a>00639                         <a class="code" href="ccn_8h.html#adac19e5f8dd6cf3ecd73b85f77f161ae">ccn_destroy</a>(&amp;h);
<a name="l00640"></a>00640                         free(f);
<a name="l00641"></a>00641                         <span class="keywordflow">return</span> NULL;
<a name="l00642"></a>00642                 }
<a name="l00643"></a>00643                 f-&gt;localConnect = 1;
<a name="l00644"></a>00644         }
<a name="l00645"></a>00645         f-&gt;h = h;
<a name="l00646"></a>00646         <span class="keywordflow">return</span> f;
<a name="l00647"></a>00647 }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 <span class="keywordtype">void</span>
<a name="l00650"></a><a class="code" href="ccn__fetch_8c.html#acbea1189239642671e3dbb8f04562712">00650</a> <a class="code" href="fetch_8h.html#acbea1189239642671e3dbb8f04562712" title="Sets the destination for debug output.">ccn_fetch_set_debug</a>(<span class="keyword">struct</span> ccn_fetch *f, FILE *<a class="code" href="ccnc_8c.html#ac3e1795766a80ec63b157951b4b9a7d4">debug</a>, <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0">ccn_fetch_flags</a> flags) {
<a name="l00651"></a>00651         f-&gt;debug = debug;
<a name="l00652"></a>00652         f-&gt;debugFlags = flags;
<a name="l00653"></a>00653 }
<a name="l00654"></a>00654 <span class="comment"></span>
<a name="l00655"></a>00655 <span class="comment">/**</span>
<a name="l00656"></a>00656 <span class="comment"> * Destroys a ccn_fetch object.</span>
<a name="l00657"></a>00657 <span class="comment"> * Only destroys the underlying ccn connection if it was automatically created.</span>
<a name="l00658"></a>00658 <span class="comment"> * Forces all underlying streams to close immediately.</span>
<a name="l00659"></a>00659 <span class="comment"> * @returns NULL in all cases.</span>
<a name="l00660"></a>00660 <span class="comment"> */</span>
<a name="l00661"></a>00661 <span class="keyword">extern</span> <span class="keyword">struct </span>ccn_fetch *
<a name="l00662"></a><a class="code" href="ccn__fetch_8c.html#ac394c367e466a8916c518b621704c6c1">00662</a> <a class="code" href="fetch_8h.html#ac394c367e466a8916c518b621704c6c1" title="Destroys a ccn_fetch object.">ccn_fetch_destroy</a>(<span class="keyword">struct</span> ccn_fetch *f) {
<a name="l00663"></a>00663         <span class="comment">// destroys a ccn_fetch object</span>
<a name="l00664"></a>00664         <span class="comment">// always returns NULL</span>
<a name="l00665"></a>00665         <span class="comment">// only destroys the underlying ccn connection if it was</span>
<a name="l00666"></a>00666         <span class="comment">// automatically created, otherwise does not alter it</span>
<a name="l00667"></a>00667         <span class="keywordflow">if</span> (f != NULL) {
<a name="l00668"></a>00668                 <span class="keyword">struct </span>ccn *h = f-&gt;h;
<a name="l00669"></a>00669                 <span class="keywordflow">if</span> (h != NULL &amp;&amp; f-&gt;localConnect) {
<a name="l00670"></a>00670                         <a class="code" href="ccn_8h.html#a0bbd9a8ad8414a8f7f955cca679f4d9c">ccn_disconnect</a>(h);
<a name="l00671"></a>00671                         <a class="code" href="ccn_8h.html#adac19e5f8dd6cf3ecd73b85f77f161ae">ccn_destroy</a>(&amp;f-&gt;h);
<a name="l00672"></a>00672                 }
<a name="l00673"></a>00673                 <span class="comment">// take down all of the streams</span>
<a name="l00674"></a>00674                 <span class="keywordflow">while</span> (f-&gt;nStreams &gt; 0) {
<a name="l00675"></a>00675                         <span class="keyword">struct </span>ccn_fetch_stream *fs = f-&gt;streams[0];
<a name="l00676"></a>00676                         <span class="keywordflow">if</span> (fs == NULL) <span class="keywordflow">break</span>;
<a name="l00677"></a>00677                         <a class="code" href="fetch_8h.html#afee1cf7387fe7eb64f1f9ecfdc47691b" title="Closes the stream and reclaims any resources used by the stream.">ccn_fetch_close</a>(fs);
<a name="l00678"></a>00678                 }
<a name="l00679"></a>00679                 free(f);
<a name="l00680"></a>00680         }
<a name="l00681"></a>00681         <span class="keywordflow">return</span> NULL;
<a name="l00682"></a>00682 }
<a name="l00683"></a>00683 <span class="comment"></span>
<a name="l00684"></a>00684 <span class="comment">/**</span>
<a name="l00685"></a>00685 <span class="comment"> * Polls the underlying streams and attempts to make progress.</span>
<a name="l00686"></a>00686 <span class="comment"> * Scans the streams for those that have data already present, or are at the end</span>
<a name="l00687"></a>00687 <span class="comment"> * of the stream.  If the count is 0, perfoms a ccn_poll on the underlying</span>
<a name="l00688"></a>00688 <span class="comment"> * ccn connection with a 0 timeout.</span>
<a name="l00689"></a>00689 <span class="comment"> *</span>
<a name="l00690"></a>00690 <span class="comment"> * NOTE: periodic calls to ccn_fetch_poll should be performed to update</span>
<a name="l00691"></a>00691 <span class="comment"> * the contents of the streams UNLESS the client is calling ccn_run for</span>
<a name="l00692"></a>00692 <span class="comment"> * the underlying ccn connection.</span>
<a name="l00693"></a>00693 <span class="comment"> * @returns the count of streams that have pending data or have ended.</span>
<a name="l00694"></a>00694 <span class="comment"> */</span>
<a name="l00695"></a>00695 <span class="keyword">extern</span> <span class="keywordtype">int</span>
<a name="l00696"></a><a class="code" href="ccn__fetch_8c.html#a5399497a89f58255148f139baa464e3c">00696</a> <a class="code" href="fetch_8h.html#a5399497a89f58255148f139baa464e3c" title="Polls the underlying streams and attempts to make progress.">ccn_fetch_poll</a>(<span class="keyword">struct</span> ccn_fetch *f) {
<a name="l00697"></a>00697         <span class="keywordtype">int</span> i;
<a name="l00698"></a>00698     <span class="keywordtype">int</span> count = 0;
<a name="l00699"></a>00699         <span class="keywordtype">int</span> ns = f-&gt;nStreams;
<a name="l00700"></a>00700         <span class="keywordflow">for</span> (i = 0; i &lt; ns; i++) {
<a name="l00701"></a>00701                 <span class="keyword">struct </span>ccn_fetch_stream *fs = f-&gt;streams[i];
<a name="l00702"></a>00702                 <span class="keywordflow">if</span> (fs != NULL) {
<a name="l00703"></a>00703                         intmax_t avail = <a class="code" href="fetch_8h.html#abb773f0a37b15995f849a1058b5abc90" title="Tests for available bytes in the stream.">ccn_fetch_avail</a>(fs);
<a name="l00704"></a>00704                         <span class="keywordflow">if</span> (avail &gt;= 0) count++;
<a name="l00705"></a>00705                 }
<a name="l00706"></a>00706         }
<a name="l00707"></a>00707         <span class="comment">// we should try for more progress</span>
<a name="l00708"></a>00708         <a class="code" href="ccn_8h.html#a3efe1659b5387eb385044bcd48619603" title="Run the ccn client event loop.">ccn_run</a>(f-&gt;h, 0);
<a name="l00709"></a>00709         <span class="keywordflow">return</span> count;
<a name="l00710"></a>00710 }
<a name="l00711"></a>00711 <span class="comment"></span>
<a name="l00712"></a>00712 <span class="comment">/**</span>
<a name="l00713"></a>00713 <span class="comment"> * Provides an iterator through the underlying streams.</span>
<a name="l00714"></a>00714 <span class="comment"> * Use fs == NULL to start the iteration, and an existing stream to continue</span>
<a name="l00715"></a>00715 <span class="comment"> * the iteration.</span>
<a name="l00716"></a>00716 <span class="comment"> * @returns the next stream in the iteration, or NULL at the end.</span>
<a name="l00717"></a>00717 <span class="comment"> * Note that providing a stale (closed) stream handle will return NULL.</span>
<a name="l00718"></a>00718 <span class="comment"> */</span>
<a name="l00719"></a>00719 <span class="keyword">extern</span> <span class="keyword">struct </span>ccn_fetch_stream *
<a name="l00720"></a><a class="code" href="ccn__fetch_8c.html#a0acb80818341b3efa4ddcd53e694e23f">00720</a> <a class="code" href="fetch_8h.html#a0acb80818341b3efa4ddcd53e694e23f" title="Provides an iterator through the underlying streams.">ccn_fetch_next</a>(<span class="keyword">struct</span> ccn_fetch *f, <span class="keyword">struct</span> ccn_fetch_stream *fs) {
<a name="l00721"></a>00721         <span class="keywordtype">int</span> i;
<a name="l00722"></a>00722     <span class="keywordtype">int</span> ns = f-&gt;nStreams;
<a name="l00723"></a>00723     <span class="keyword">struct </span>ccn_fetch_stream *lag = NULL;
<a name="l00724"></a>00724         <span class="keywordflow">for</span> (i = 0; i &lt; ns; i++) {
<a name="l00725"></a>00725                 <span class="keyword">struct </span>ccn_fetch_stream *tfs = f-&gt;streams[i];
<a name="l00726"></a>00726                 <span class="keywordflow">if</span> (tfs != NULL) {
<a name="l00727"></a>00727                         <span class="keywordflow">if</span> (lag == fs) <span class="keywordflow">return</span> tfs;
<a name="l00728"></a>00728                         lag = tfs;
<a name="l00729"></a>00729                 }
<a name="l00730"></a>00730         }
<a name="l00731"></a>00731         <span class="keywordflow">return</span> NULL;
<a name="l00732"></a>00732 }
<a name="l00733"></a>00733 <span class="comment"></span>
<a name="l00734"></a>00734 <span class="comment">/**</span>
<a name="l00735"></a>00735 <span class="comment"> * @returns the underlying ccn connection.</span>
<a name="l00736"></a>00736 <span class="comment"> */</span>
<a name="l00737"></a>00737 <span class="keyword">extern</span> <span class="keyword">struct </span>ccn *
<a name="l00738"></a><a class="code" href="ccn__fetch_8c.html#ae3a272ee0f985d826ec041f4179c3a1c">00738</a> <a class="code" href="fetch_8h.html#ae3a272ee0f985d826ec041f4179c3a1c">ccn_fetch_get_ccn</a>(<span class="keyword">struct</span> ccn_fetch *f) {
<a name="l00739"></a>00739         <span class="keywordflow">return</span> f-&gt;h;
<a name="l00740"></a>00740 }
<a name="l00741"></a>00741 <span class="comment"></span>
<a name="l00742"></a>00742 <span class="comment">/**</span>
<a name="l00743"></a>00743 <span class="comment"> * Creates a stream for a named interest.</span>
<a name="l00744"></a>00744 <span class="comment"> * The name should be a ccnb encoded interest.</span>
<a name="l00745"></a>00745 <span class="comment"> * If resolveVersion, then we assume that the version is unresolved, </span>
<a name="l00746"></a>00746 <span class="comment"> * and an attempt is made to determine the version number using the highest</span>
<a name="l00747"></a>00747 <span class="comment"> * version.</span>
<a name="l00748"></a>00748 <span class="comment"> * The number of buffers (nBufs) may be silently limited.</span>
<a name="l00749"></a>00749 <span class="comment"> * @returns NULL if the stream creation failed,</span>
<a name="l00750"></a>00750 <span class="comment"> * otherwise returns the new stream.</span>
<a name="l00751"></a>00751 <span class="comment"> */</span>
<a name="l00752"></a>00752 <span class="keyword">extern</span> <span class="keyword">struct </span>ccn_fetch_stream *
<a name="l00753"></a><a class="code" href="ccn__fetch_8c.html#a3255d1f2ea2efca90b3a3715d643eb6a">00753</a> <a class="code" href="fetch_8h.html#a3255d1f2ea2efca90b3a3715d643eb6a" title="Creates a stream for a named interest.">ccn_fetch_open</a>(<span class="keyword">struct</span> ccn_fetch *f,
<a name="l00754"></a>00754                            <span class="keyword">struct</span> <a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *name,
<a name="l00755"></a>00755                            <span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">id</span>,
<a name="l00756"></a>00756                            <span class="keyword">struct</span> <a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *interestTemplate,
<a name="l00757"></a>00757                            <span class="keywordtype">int</span> maxBufs,
<a name="l00758"></a>00758                            <span class="keywordtype">int</span> resolveVersion,
<a name="l00759"></a>00759                            <span class="keywordtype">int</span> assumeFixed) {
<a name="l00760"></a>00760         <span class="comment">// returns a new ccn_fetch_stream object based on the arguments</span>
<a name="l00761"></a>00761         <span class="comment">// returns NULL if not successful</span>
<a name="l00762"></a>00762     <span class="keywordflow">if</span> (maxBufs &lt;= 0) <span class="keywordflow">return</span> NULL;
<a name="l00763"></a>00763         <span class="keywordflow">if</span> (maxBufs &gt; 16) maxBufs = 16;
<a name="l00764"></a>00764         <span class="keywordtype">int</span> res = 0;
<a name="l00765"></a>00765         FILE *<a class="code" href="ccnc_8c.html#ac3e1795766a80ec63b157951b4b9a7d4">debug</a> = f-&gt;debug;
<a name="l00766"></a>00766         <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0">ccn_fetch_flags</a> flags = f-&gt;debugFlags;
<a name="l00767"></a>00767     
<a name="l00768"></a>00768         <span class="comment">// first, resolve the version</span>
<a name="l00769"></a>00769         <span class="keyword">struct </span>ccn_fetch_stream *fs = calloc(1, <span class="keyword">sizeof</span>(*fs));
<a name="l00770"></a>00770         fs-&gt;segSize = (assumeFixed ? 0 : -1);
<a name="l00771"></a>00771         fs-&gt;name = <a class="code" href="charbuf_8h.html#a6db2918ed16206ad07920ab26aac9da6">ccn_charbuf_create</a>();
<a name="l00772"></a>00772         fs-&gt;id = <a class="code" href="ccn__fetch_8c.html#a4caa1664e6311c2eb82a5ef980e9890f">newStringCopy</a>(<span class="keywordtype">id</span>);
<a name="l00773"></a>00773         <a class="code" href="charbuf_8h.html#aca88638b2e81602eb4a1da9be923dad7">ccn_charbuf_append_charbuf</a>(fs-&gt;name, name);
<a name="l00774"></a>00774         <span class="keywordflow">if</span> (resolveVersion) {
<a name="l00775"></a>00775                 <span class="keywordtype">int</span> tmInc = 40; <span class="comment">// TBD: need better strategy for version timeout</span>
<a name="l00776"></a>00776                 <span class="keywordtype">int</span> tm = 0;
<a name="l00777"></a>00777                 <span class="keywordflow">while</span> (tm &lt; <a class="code" href="ccn__fetch_8c.html#ae5c2a797e9f60944a884d7410a69ce80" title="Streaming access for fetching segmented CCNx data.">CCN_VERSION_TIMEOUT</a>) {
<a name="l00778"></a>00778                         res = <a class="code" href="ccn_8h.html#ac6285f1a77360610cb68ddfe9769f495" title="Resolve the version, based on existing ccn content.">ccn_resolve_version</a>(f-&gt;h, fs-&gt;name, resolveVersion, tmInc);
<a name="l00779"></a>00779                         <span class="keywordflow">if</span> (res &gt;= 0) <span class="keywordflow">break</span>;
<a name="l00780"></a>00780                         tm = tm + tmInc;
<a name="l00781"></a>00781                 }
<a name="l00782"></a>00782                 <span class="keywordflow">if</span> (res &lt; 0) {
<a name="l00783"></a>00783                         <span class="comment">// could not resolve version for this name</span>
<a name="l00784"></a>00784                         <span class="comment">// get rid of allocations so far and bail out</span>
<a name="l00785"></a>00785                         <span class="keywordflow">if</span> (debug != NULL &amp;&amp; (flags &amp; <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0adeea8c9d05adf034e8c3d6eb5210527e">ccn_fetch_flags_NoteOpenClose</a>)) {
<a name="l00786"></a>00786                                 fprintf(debug, 
<a name="l00787"></a>00787                                                 <span class="stringliteral">&quot;-- ccn_fetch open, %s, failed to resolve version\n&quot;</span>,
<a name="l00788"></a>00788                                                 fs-&gt;id);
<a name="l00789"></a>00789                                 fflush(debug);
<a name="l00790"></a>00790                         }
<a name="l00791"></a>00791                         <a class="code" href="charbuf_8h.html#a699030e7cb3c51ca2cde46af0ba6e1bb">ccn_charbuf_destroy</a>(&amp;fs-&gt;name);
<a name="l00792"></a>00792                         <a class="code" href="ccn__fetch_8c.html#a6a63cd67624ab55e9bc78ce7af769cdf">freeString</a>(fs-&gt;id);
<a name="l00793"></a>00793                         free(fs);
<a name="l00794"></a>00794                         <span class="keywordflow">return</span> NULL;
<a name="l00795"></a>00795                 }
<a name="l00796"></a>00796         }
<a name="l00797"></a>00797         fs-&gt;maxBufs = maxBufs;
<a name="l00798"></a>00798         fs-&gt;segsAhead = 0;
<a name="l00799"></a>00799         fs-&gt;fileSize = -1;
<a name="l00800"></a>00800         fs-&gt;finalSeg = -1;
<a name="l00801"></a>00801         fs-&gt;timeoutSeg = -1;
<a name="l00802"></a>00802         fs-&gt;zeroLenSeg = -1;
<a name="l00803"></a>00803         fs-&gt;parent = f;
<a name="l00804"></a>00804         fs-&gt;timeoutUSecs = <a class="code" href="ccn__fetch_8c.html#afde4a7a5e602643b1d97eaf2a862f8b1">CCN_INTEREST_TIMEOUT_USECS</a>;  <span class="comment">// TBD: how to get better timeout?</span>
<a name="l00805"></a>00805         
<a name="l00806"></a>00806         <span class="comment">// use the supplied template or the default</span>
<a name="l00807"></a>00807         <span class="keywordflow">if</span> (interestTemplate != NULL) {
<a name="l00808"></a>00808                 <span class="keyword">struct </span><a class="code" href="structccn__charbuf.html">ccn_charbuf</a> *cb = <a class="code" href="charbuf_8h.html#a6db2918ed16206ad07920ab26aac9da6">ccn_charbuf_create</a>();
<a name="l00809"></a>00809                 <a class="code" href="charbuf_8h.html#aca88638b2e81602eb4a1da9be923dad7">ccn_charbuf_append_charbuf</a>(cb, interestTemplate);
<a name="l00810"></a>00810                 fs-&gt;interest = cb;
<a name="l00811"></a>00811         } <span class="keywordflow">else</span>
<a name="l00812"></a>00812                 fs-&gt;interest = <a class="code" href="ccn__fetch_8c.html#af6a2ec5f85d883e13a03691902b3f644">make_data_template</a>(<a class="code" href="ccn__fetch_8c.html#ad9e1439bf63dbf29957d1c676008ec24">MaxSuffixDefault</a>);
<a name="l00813"></a>00813         
<a name="l00814"></a>00814         
<a name="l00815"></a>00815         <span class="comment">// remember the stream in the parent</span>
<a name="l00816"></a>00816         <span class="keywordtype">int</span> ns = f-&gt;nStreams;
<a name="l00817"></a>00817         <span class="keywordtype">int</span> max = f-&gt;maxStreams;
<a name="l00818"></a>00818         <span class="keywordflow">if</span> (ns &gt;= max) {
<a name="l00819"></a>00819                 <span class="comment">// extend the vector</span>
<a name="l00820"></a>00820                 <span class="keywordtype">int</span> nMax = max+max/2+4;
<a name="l00821"></a>00821         <span class="keyword">struct </span>ccn_fetch_stream **streams;
<a name="l00822"></a>00822         streams = realloc(f-&gt;streams, <span class="keyword">sizeof</span>(*(f-&gt;streams)) * nMax);
<a name="l00823"></a>00823         <span class="keywordflow">if</span> (streams == NULL) {
<a name="l00824"></a>00824             <span class="keywordflow">return</span> (NULL); <span class="comment">// TBD: should this be handled differently?</span>
<a name="l00825"></a>00825         }
<a name="l00826"></a>00826         f-&gt;streams = streams;
<a name="l00827"></a>00827                 f-&gt;maxStreams = nMax;
<a name="l00828"></a>00828         }
<a name="l00829"></a>00829         <span class="comment">// guaranteed room to add at the end</span>
<a name="l00830"></a>00830         f-&gt;streams[ns] = fs;
<a name="l00831"></a>00831         f-&gt;nStreams = ns+1;
<a name="l00832"></a>00832         
<a name="l00833"></a>00833         <span class="keywordflow">if</span> (debug != NULL &amp;&amp; (flags &amp; <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0adeea8c9d05adf034e8c3d6eb5210527e">ccn_fetch_flags_NoteOpenClose</a>)) {
<a name="l00834"></a>00834                 fprintf(debug, 
<a name="l00835"></a>00835                                 <span class="stringliteral">&quot;-- ccn_fetch open, %s\n&quot;</span>,
<a name="l00836"></a>00836                                 fs-&gt;id);
<a name="l00837"></a>00837                 fflush(debug);
<a name="l00838"></a>00838         }
<a name="l00839"></a>00839         <span class="comment">// prep for the first segment</span>
<a name="l00840"></a>00840         <a class="code" href="ccn__fetch_8c.html#aed971b7efb9c939e2788eb5dff2c16e0">NeedSegment</a>(fs, 0);
<a name="l00841"></a>00841         <span class="keywordflow">return</span> fs;
<a name="l00842"></a>00842 }
<a name="l00843"></a>00843 <span class="comment"></span>
<a name="l00844"></a>00844 <span class="comment">/**</span>
<a name="l00845"></a>00845 <span class="comment"> * Closes the stream and reclaims any resources used by the stream.</span>
<a name="l00846"></a>00846 <span class="comment"> * The stream object will be freed, so the client must not access it again.</span>
<a name="l00847"></a>00847 <span class="comment"> * @returns NULL in all cases.</span>
<a name="l00848"></a>00848 <span class="comment"> */</span>
<a name="l00849"></a>00849 <span class="keyword">extern</span> <span class="keyword">struct </span>ccn_fetch_stream *
<a name="l00850"></a><a class="code" href="ccn__fetch_8c.html#afee1cf7387fe7eb64f1f9ecfdc47691b">00850</a> <a class="code" href="fetch_8h.html#afee1cf7387fe7eb64f1f9ecfdc47691b" title="Closes the stream and reclaims any resources used by the stream.">ccn_fetch_close</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs) {
<a name="l00851"></a>00851         <span class="comment">// destroys a ccn_fetch_stream object</span>
<a name="l00852"></a>00852         <span class="comment">// implicit abort of any outstanding fetches</span>
<a name="l00853"></a>00853         <span class="comment">// always returns NULL</span>
<a name="l00854"></a>00854         <span class="keywordtype">int</span> i;
<a name="l00855"></a>00855     FILE *<a class="code" href="ccnc_8c.html#ac3e1795766a80ec63b157951b4b9a7d4">debug</a> = fs-&gt;parent-&gt;debug;
<a name="l00856"></a>00856         <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0">ccn_fetch_flags</a> flags = fs-&gt;parent-&gt;debugFlags;
<a name="l00857"></a>00857     
<a name="l00858"></a>00858         <span class="comment">// make orphans of all outstanding requests</span>
<a name="l00859"></a>00859         <span class="comment">// CallMe should handle the cleanup</span>
<a name="l00860"></a>00860         <span class="keyword">struct </span>localClosure * <span class="keyword">this</span> = fs-&gt;requests;
<a name="l00861"></a>00861         fs-&gt;requests = NULL;
<a name="l00862"></a>00862         <span class="keywordflow">while</span> (<span class="keyword">this</span> != NULL) {
<a name="l00863"></a>00863                 this-&gt;fs = NULL;
<a name="l00864"></a>00864                 <span class="keyword">this</span> = this-&gt;next;
<a name="l00865"></a>00865         }
<a name="l00866"></a>00866         <span class="comment">// free up the buffers</span>
<a name="l00867"></a>00867         fs-&gt;maxBufs = 0;
<a name="l00868"></a>00868         <a class="code" href="ccn__fetch_8c.html#a68b971a7764a77135485cb3bbf42569e">PruneSegments</a>(fs);
<a name="l00869"></a>00869         
<a name="l00870"></a>00870         <span class="keywordflow">if</span> (fs-&gt;name != NULL)
<a name="l00871"></a>00871                 <a class="code" href="charbuf_8h.html#a699030e7cb3c51ca2cde46af0ba6e1bb">ccn_charbuf_destroy</a>(&amp;fs-&gt;name);
<a name="l00872"></a>00872         <span class="keywordflow">if</span> (fs-&gt;interest != NULL)
<a name="l00873"></a>00873                 <a class="code" href="charbuf_8h.html#a699030e7cb3c51ca2cde46af0ba6e1bb">ccn_charbuf_destroy</a>(&amp;fs-&gt;interest);
<a name="l00874"></a>00874         <span class="keyword">struct </span>ccn_fetch *f = fs-&gt;parent;
<a name="l00875"></a>00875         <span class="keywordflow">if</span> (f != NULL) {
<a name="l00876"></a>00876                 <span class="keywordtype">int</span> ns = f-&gt;nStreams;
<a name="l00877"></a>00877                 fs-&gt;parent = NULL;
<a name="l00878"></a>00878                 <span class="keywordflow">for</span> (i = 0; i &lt; ns; i++) {
<a name="l00879"></a>00879                         <span class="keyword">struct </span>ccn_fetch_stream *tfs = f-&gt;streams[i];
<a name="l00880"></a>00880                         <span class="keywordflow">if</span> (tfs == fs) {
<a name="l00881"></a>00881                                 <span class="comment">// found it, so get rid of it</span>
<a name="l00882"></a>00882                                 ns--;
<a name="l00883"></a>00883                                 f-&gt;nStreams = ns;
<a name="l00884"></a>00884                                 f-&gt;streams[i] = NULL;
<a name="l00885"></a>00885                                 f-&gt;streams[i] = f-&gt;streams[ns];
<a name="l00886"></a>00886                                 f-&gt;streams[ns] = NULL;  
<a name="l00887"></a>00887                                 <span class="keywordflow">break</span>;  
<a name="l00888"></a>00888                         }
<a name="l00889"></a>00889                 }
<a name="l00890"></a>00890         }
<a name="l00891"></a>00891         <span class="keywordflow">if</span> (debug != NULL &amp;&amp; (flags &amp; <a class="code" href="fetch_8h.html#a0ed6579cfdae4fc38e27df172076d4f0adeea8c9d05adf034e8c3d6eb5210527e">ccn_fetch_flags_NoteOpenClose</a>)) {
<a name="l00892"></a>00892                 fprintf(debug, 
<a name="l00893"></a>00893                                 <span class="stringliteral">&quot;-- ccn_fetch close, %s, segReq %jd, segsRead %jd, timeouts %jd\n&quot;</span>,
<a name="l00894"></a>00894                                 fs-&gt;id,
<a name="l00895"></a>00895                                 fs-&gt;segsRequested,
<a name="l00896"></a>00896                                 fs-&gt;segsRead,
<a name="l00897"></a>00897                                 fs-&gt;timeoutsSeen);
<a name="l00898"></a>00898                 fflush(debug);
<a name="l00899"></a>00899         }
<a name="l00900"></a>00900         <span class="comment">// finally, get rid of the stream object</span>
<a name="l00901"></a>00901         <a class="code" href="ccn__fetch_8c.html#a6a63cd67624ab55e9bc78ce7af769cdf">freeString</a>(fs-&gt;id);
<a name="l00902"></a>00902         free(fs);
<a name="l00903"></a>00903         <span class="keywordflow">return</span> NULL;
<a name="l00904"></a>00904 }
<a name="l00905"></a>00905 <span class="comment"></span>
<a name="l00906"></a>00906 <span class="comment">/**</span>
<a name="l00907"></a>00907 <span class="comment"> * Tests for available bytes in the stream.</span>
<a name="l00908"></a>00908 <span class="comment"> */</span>
<a name="l00909"></a>00909 <span class="keyword">extern</span> intmax_t
<a name="l00910"></a><a class="code" href="ccn__fetch_8c.html#abb773f0a37b15995f849a1058b5abc90">00910</a> <a class="code" href="fetch_8h.html#abb773f0a37b15995f849a1058b5abc90" title="Tests for available bytes in the stream.">ccn_fetch_avail</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs) {
<a name="l00911"></a>00911         intmax_t pos = fs-&gt;readPosition;
<a name="l00912"></a>00912         <span class="keywordflow">if</span> (fs-&gt;fileSize &gt;= 0 &amp;&amp; pos &gt;= fs-&gt;fileSize) {
<a name="l00913"></a>00913                 <span class="comment">// file size known, and we are at the limit</span>
<a name="l00914"></a>00914                 <span class="keywordflow">return</span> <a class="code" href="fetch_8h.html#a34f08e63f73f4b541b03c1f1e02e77ba">CCN_FETCH_READ_END</a>;
<a name="l00915"></a>00915         }
<a name="l00916"></a>00916         intmax_t avail = 0;
<a name="l00917"></a>00917         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> seg = fs-&gt;readSeg;
<a name="l00918"></a>00918         <span class="keywordflow">if</span> (fs-&gt;timeoutSeg &gt;= 0 &amp;&amp; seg &gt;= fs-&gt;timeoutSeg)
<a name="l00919"></a>00919                 <span class="comment">// timeout indication</span>
<a name="l00920"></a>00920                 <span class="keywordflow">return</span> <a class="code" href="fetch_8h.html#a7e3ad5bb3d947965dd4127c43b51b03f">CCN_FETCH_READ_TIMEOUT</a>;
<a name="l00921"></a>00921         <span class="keywordflow">if</span> (fs-&gt;zeroLenSeg &gt;= 0 &amp;&amp; seg &gt;= fs-&gt;zeroLenSeg)
<a name="l00922"></a>00922                 <span class="comment">// zero len indication</span>
<a name="l00923"></a>00923                 <span class="keywordflow">return</span> <a class="code" href="fetch_8h.html#a85485d9b133c96fb4d04241fcfb3f76f">CCN_FETCH_READ_ZERO</a>;
<a name="l00924"></a>00924         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> finalSeg = fs-&gt;finalSeg;
<a name="l00925"></a>00925         <span class="keywordflow">if</span> (seg &gt; finalSeg &amp;&amp; fs-&gt;finalSeg &gt;= 0)
<a name="l00926"></a>00926                 <span class="comment">// seek beyond EOF may cause this</span>
<a name="l00927"></a>00927                 <span class="keywordflow">return</span> <a class="code" href="fetch_8h.html#a4d5dd412f2754dbd40189a7e4517432b">CCN_FETCH_READ_NONE</a>;
<a name="l00928"></a>00928         
<a name="l00929"></a>00929         <span class="keywordflow">for</span> (;;) {
<a name="l00930"></a>00930                 <span class="keyword">struct </span>ccn_fetch_buffer *fb = <a class="code" href="ccn__fetch_8c.html#a4fd2d607c7cf61d64ebfaaf4c03fafac">FindBufferForSeg</a>(fs, seg);
<a name="l00931"></a>00931                 <span class="keywordflow">if</span> (fb == NULL) <span class="keywordflow">break</span>;
<a name="l00932"></a>00932                 <span class="keywordflow">if</span> (fb-&gt;pos &lt; 0) fb-&gt;pos = pos;
<a name="l00933"></a>00933                 <span class="keywordtype">int</span> len = fb-&gt;len;
<a name="l00934"></a>00934                 <span class="keywordflow">if</span> (seg == fs-&gt;readSeg) {
<a name="l00935"></a>00935                         <span class="comment">// adjust for offset into the buffer</span>
<a name="l00936"></a>00936                         intmax_t off = pos - fb-&gt;pos;
<a name="l00937"></a>00937                         <span class="keywordflow">if</span> (off &gt; 0) len = len - off;
<a name="l00938"></a>00938                 }
<a name="l00939"></a>00939                 avail = avail + len;
<a name="l00940"></a>00940                 pos = pos + len;
<a name="l00941"></a>00941                 seg++;
<a name="l00942"></a>00942         }
<a name="l00943"></a>00943         <span class="keywordflow">if</span> (avail == 0)
<a name="l00944"></a>00944                 <span class="comment">// nothing available at this time, but not at the end, we think</span>
<a name="l00945"></a>00945                 <span class="keywordflow">return</span> <a class="code" href="fetch_8h.html#a4d5dd412f2754dbd40189a7e4517432b">CCN_FETCH_READ_NONE</a>;
<a name="l00946"></a>00946         <span class="keywordflow">return</span> avail;
<a name="l00947"></a>00947 }
<a name="l00948"></a>00948 <span class="comment"></span>
<a name="l00949"></a>00949 <span class="comment">/**</span>
<a name="l00950"></a>00950 <span class="comment"> * Reads bytes from a stream.</span>
<a name="l00951"></a>00951 <span class="comment"> * Reads at most len bytes into buf from the given stream.</span>
<a name="l00952"></a>00952 <span class="comment"> * Will not wait for bytes to arrive.</span>
<a name="l00953"></a>00953 <span class="comment"> * Advances the read position on a successful read.</span>
<a name="l00954"></a>00954 <span class="comment"> * @returns</span>
<a name="l00955"></a>00955 <span class="comment"> *    CCN_FETCH_READ_TIMEOUT if a timeout occurred,</span>
<a name="l00956"></a>00956 <span class="comment"> *    CCN_FETCH_READ_ZERO if a zero-length segment was found</span>
<a name="l00957"></a>00957 <span class="comment"> *    CCN_FETCH_READ_NONE if no bytes are immediately available</span>
<a name="l00958"></a>00958 <span class="comment"> *    CCN_FETCH_READ_END if the stream is at the end,</span>
<a name="l00959"></a>00959 <span class="comment"> *    and N &gt; 0 if N bytes were read.</span>
<a name="l00960"></a>00960 <span class="comment"> */</span>
<a name="l00961"></a>00961 <span class="keyword">extern</span> intmax_t
<a name="l00962"></a><a class="code" href="ccn__fetch_8c.html#abc8030c946fed58635c051ffa9b7b2a5">00962</a> <a class="code" href="fetch_8h.html#abc8030c946fed58635c051ffa9b7b2a5" title="Reads bytes from a stream.">ccn_fetch_read</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs,
<a name="l00963"></a>00963                            <span class="keywordtype">void</span> *buf,
<a name="l00964"></a>00964                            intmax_t len) {
<a name="l00965"></a>00965         <span class="keywordflow">if</span> (len &lt; 0 || buf == NULL) {
<a name="l00966"></a>00966                 <span class="keywordflow">return</span> <a class="code" href="fetch_8h.html#a4d5dd412f2754dbd40189a7e4517432b">CCN_FETCH_READ_NONE</a>;
<a name="l00967"></a>00967         }
<a name="l00968"></a>00968         intmax_t off = 0;
<a name="l00969"></a>00969         intmax_t pos = fs-&gt;readPosition;
<a name="l00970"></a>00970         <span class="keywordflow">if</span> (fs-&gt;fileSize &gt;= 0 &amp;&amp; pos &gt;= fs-&gt;fileSize) {
<a name="l00971"></a>00971                 <span class="comment">// file size known, and we are at the limit</span>
<a name="l00972"></a>00972                 <span class="keywordflow">return</span> <a class="code" href="fetch_8h.html#a34f08e63f73f4b541b03c1f1e02e77ba">CCN_FETCH_READ_END</a>;
<a name="l00973"></a>00973         }
<a name="l00974"></a>00974         intmax_t nr = 0;
<a name="l00975"></a>00975         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *dst = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *) buf;
<a name="l00976"></a>00976         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> seg = fs-&gt;readSeg;
<a name="l00977"></a>00977         
<a name="l00978"></a>00978         <span class="keywordflow">if</span> (fs-&gt;timeoutSeg &gt;= 0 &amp;&amp; seg &gt;= fs-&gt;timeoutSeg)
<a name="l00979"></a>00979                 <span class="comment">// if a needed read timed out, then we say so</span>
<a name="l00980"></a>00980                 <span class="keywordflow">return</span> <a class="code" href="fetch_8h.html#a7e3ad5bb3d947965dd4127c43b51b03f">CCN_FETCH_READ_TIMEOUT</a>;
<a name="l00981"></a>00981         <span class="keywordflow">if</span> (fs-&gt;zeroLenSeg &gt;= 0 &amp;&amp; seg &gt;= fs-&gt;zeroLenSeg)
<a name="l00982"></a>00982                 <span class="comment">// if we got a zero length segment, report it</span>
<a name="l00983"></a>00983                 <span class="keywordflow">return</span> <a class="code" href="fetch_8h.html#a85485d9b133c96fb4d04241fcfb3f76f">CCN_FETCH_READ_ZERO</a>;
<a name="l00984"></a>00984         <span class="keywordflow">while</span> (len &gt; 0) {
<a name="l00985"></a>00985                 <span class="keyword">struct </span>ccn_fetch_buffer *fb = <a class="code" href="ccn__fetch_8c.html#a4fd2d607c7cf61d64ebfaaf4c03fafac">FindBufferForSeg</a>(fs, seg);
<a name="l00986"></a>00986                 <span class="keywordflow">if</span> (fb == NULL) <span class="keywordflow">break</span>;
<a name="l00987"></a>00987                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *src = fb-&gt;buf;
<a name="l00988"></a>00988                 intmax_t start = fb-&gt;pos;
<a name="l00989"></a>00989                 intmax_t lo = start;
<a name="l00990"></a>00990                 <span class="keywordflow">if</span> (lo &lt; 0) {
<a name="l00991"></a>00991                         <span class="comment">// segments delivered at random might cause this</span>
<a name="l00992"></a>00992                         lo = pos;
<a name="l00993"></a>00993                         fb-&gt;pos = pos;
<a name="l00994"></a>00994                 }
<a name="l00995"></a>00995                 intmax_t hi = lo + fb-&gt;len;
<a name="l00996"></a>00996                 <span class="keywordflow">if</span> (pos &lt; lo || pos &gt;= hi || seg != fb-&gt;seg) {
<a name="l00997"></a>00997                         <span class="comment">// this SHOULD NOT HAPPEN!</span>
<a name="l00998"></a>00998                         FILE *<a class="code" href="ccnc_8c.html#ac3e1795766a80ec63b157951b4b9a7d4">debug</a> = fs-&gt;parent-&gt;debug;
<a name="l00999"></a>00999                         <span class="keywordflow">if</span> (debug != NULL) {
<a name="l01000"></a>01000                                 fprintf(debug, 
<a name="l01001"></a>01001                                                 <span class="stringliteral">&quot;** ccn_fetch read, %s, seg %jd, pos %jd, lo %jd, hi %jd\n&quot;</span>,
<a name="l01002"></a>01002                                                 fs-&gt;id, seg, pos, (intmax_t) lo, (intmax_t) hi);
<a name="l01003"></a>01003                                 fflush(debug);
<a name="l01004"></a>01004                         }
<a name="l01005"></a>01005                         <span class="keywordflow">break</span>;
<a name="l01006"></a>01006                 }
<a name="l01007"></a>01007                 intmax_t d = hi - pos;
<a name="l01008"></a>01008                 <span class="keywordflow">if</span> (d &gt; len) d = len;
<a name="l01009"></a>01009                 memcpy(dst+off, src+(pos-lo), d);
<a name="l01010"></a>01010                 nr = nr + d;
<a name="l01011"></a>01011                 pos = pos + d;
<a name="l01012"></a>01012                 off = off + d;
<a name="l01013"></a>01013                 len = len - d;
<a name="l01014"></a>01014                 fs-&gt;readPosition = pos;
<a name="l01015"></a>01015                 fs-&gt;readStart = start;
<a name="l01016"></a>01016                 <span class="keywordflow">if</span> (pos == hi) {
<a name="l01017"></a>01017                         <span class="comment">// finished the bytes in this segment</span>
<a name="l01018"></a>01018                         seg++;
<a name="l01019"></a>01019                         fs-&gt;readSeg = seg;
<a name="l01020"></a>01020                         fs-&gt;readStart = pos;
<a name="l01021"></a>01021                 }
<a name="l01022"></a>01022         }
<a name="l01023"></a>01023         <a class="code" href="ccn__fetch_8c.html#a0a389d694ce4fb464d4327c74b8bee1b">NeedSegments</a>(fs);
<a name="l01024"></a>01024         <a class="code" href="ccn__fetch_8c.html#a68b971a7764a77135485cb3bbf42569e">PruneSegments</a>(fs);
<a name="l01025"></a>01025         <span class="keywordflow">if</span> (nr == 0) {
<a name="l01026"></a>01026                 <span class="keywordflow">return</span> <a class="code" href="fetch_8h.html#a4d5dd412f2754dbd40189a7e4517432b">CCN_FETCH_READ_NONE</a>;
<a name="l01027"></a>01027         }
<a name="l01028"></a>01028         <span class="keywordflow">return</span> nr;
<a name="l01029"></a>01029 }
<a name="l01030"></a>01030 <span class="comment"></span>
<a name="l01031"></a>01031 <span class="comment">/**</span>
<a name="l01032"></a>01032 <span class="comment"> * Resets the timeout marker.</span>
<a name="l01033"></a>01033 <span class="comment"> */</span>
<a name="l01034"></a>01034 <span class="keyword">extern</span> <span class="keywordtype">void</span>
<a name="l01035"></a><a class="code" href="ccn__fetch_8c.html#ac209124a24a126810f32009a6da7376c">01035</a> <a class="code" href="fetch_8h.html#ac209124a24a126810f32009a6da7376c" title="Resets the timeout indicator, which will cause pending interests to be retried.">ccn_reset_timeout</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs) {
<a name="l01036"></a>01036         fs-&gt;timeoutSeg = -1;
<a name="l01037"></a>01037         fs-&gt;segsAhead = 0;
<a name="l01038"></a>01038 }
<a name="l01039"></a>01039 <span class="comment"></span>
<a name="l01040"></a>01040 <span class="comment">/**</span>
<a name="l01041"></a>01041 <span class="comment"> * Seeks to a position in a stream.</span>
<a name="l01042"></a>01042 <span class="comment"> * Sets the read position.</span>
<a name="l01043"></a>01043 <span class="comment"> * It is strongly recommended that the seek is only done to a position that</span>
<a name="l01044"></a>01044 <span class="comment"> * is either 0 or has resulted from a successful read.  Otherwise</span>
<a name="l01045"></a>01045 <span class="comment"> * end of stream indicators may be returned for a seek beyond the end.</span>
<a name="l01046"></a>01046 <span class="comment"> * @returns -1 if the seek is to a bad position, otherwise returns 0.</span>
<a name="l01047"></a>01047 <span class="comment"> */</span>
<a name="l01048"></a>01048 <span class="keyword">extern</span> <span class="keywordtype">int</span>
<a name="l01049"></a><a class="code" href="ccn__fetch_8c.html#a994f9d08ecdd25e10b1b84523118214a">01049</a> <a class="code" href="fetch_8h.html#a994f9d08ecdd25e10b1b84523118214a" title="Seeks to a position in a stream.">ccn_fetch_seek</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs, intmax_t pos) {
<a name="l01050"></a>01050         <span class="comment">// seeks to the given position in the input stream</span>
<a name="l01051"></a>01051         <a class="code" href="ccn__fetch_8c.html#adea6360cc4f857e8d2f09c1f46e9f0fb">seg_t</a> seg = 0;
<a name="l01052"></a>01052         intmax_t start = 0;
<a name="l01053"></a>01053         <span class="keywordflow">if</span> (pos == 0) {
<a name="l01054"></a>01054                 <span class="comment">// seek to the start should always be OK</span>
<a name="l01055"></a>01055                 <span class="comment">// (also resets bad segment indicators)</span>
<a name="l01056"></a>01056                 fs-&gt;timeoutSeg = -1;
<a name="l01057"></a>01057                 fs-&gt;zeroLenSeg = -1;
<a name="l01058"></a>01058                 fs-&gt;segsAhead = 0;
<a name="l01059"></a>01059         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pos == fs-&gt;readPosition) {
<a name="l01060"></a>01060                 <span class="comment">// no change</span>
<a name="l01061"></a>01061                 <span class="keywordflow">return</span> 0;
<a name="l01062"></a>01062         } <span class="keywordflow">else</span> {
<a name="l01063"></a>01063                 <span class="comment">// seek elsewhere</span>
<a name="l01064"></a>01064                 <span class="keyword">struct </span>ccn_fetch_buffer *fb = <a class="code" href="ccn__fetch_8c.html#af8eb6d3b33bc70e0c2d2e0245a6ab115">FindBufferForPosition</a>(fs, pos);
<a name="l01065"></a>01065                 <span class="keywordflow">if</span> (fb != NULL) {
<a name="l01066"></a>01066                         <span class="comment">// an existing segment, so this is easy</span>
<a name="l01067"></a>01067                         seg = fb-&gt;seg;
<a name="l01068"></a>01068                         start = fb-&gt;pos;
<a name="l01069"></a>01069                 } <span class="keywordflow">else</span> {
<a name="l01070"></a>01070                         <span class="keywordtype">int</span> ss = fs-&gt;segSize;
<a name="l01071"></a>01071                         <span class="keywordflow">if</span> (pos &lt; 0 || ss &lt;= 0)
<a name="l01072"></a>01072                                 <span class="comment">// segment size is not known, so indicate that seek fails</span>
<a name="l01073"></a>01073                                 <span class="keywordflow">return</span> -1;
<a name="l01074"></a>01074                         intmax_t fileSize = fs-&gt;fileSize;
<a name="l01075"></a>01075                         <span class="keywordflow">if</span> (fileSize &gt;= 0 &amp;&amp; pos &gt; fileSize) {
<a name="l01076"></a>01076                                 <span class="comment">// file size is known exactly, and we have gone too far</span>
<a name="l01077"></a>01077                                 <span class="keywordflow">return</span> -1;
<a name="l01078"></a>01078                         }
<a name="l01079"></a>01079                         <span class="comment">// at this point we can set the position (failure can occur later on the read)</span>
<a name="l01080"></a>01080                         seg = pos / ss;
<a name="l01081"></a>01081                         start = seg * ss;
<a name="l01082"></a>01082                 }
<a name="l01083"></a>01083         }
<a name="l01084"></a>01084         fs-&gt;readPosition = pos;
<a name="l01085"></a>01085         fs-&gt;readStart = start;
<a name="l01086"></a>01086         fs-&gt;readSeg = seg;
<a name="l01087"></a>01087         <a class="code" href="ccn__fetch_8c.html#aed971b7efb9c939e2788eb5dff2c16e0">NeedSegment</a>(fs, seg);
<a name="l01088"></a>01088         <a class="code" href="ccn__fetch_8c.html#a68b971a7764a77135485cb3bbf42569e">PruneSegments</a>(fs);
<a name="l01089"></a>01089         
<a name="l01090"></a>01090         <span class="keywordflow">return</span> 0;
<a name="l01091"></a>01091 }
<a name="l01092"></a>01092 <span class="comment"></span>
<a name="l01093"></a>01093 <span class="comment">/**</span>
<a name="l01094"></a>01094 <span class="comment"> * @returns the current read position.</span>
<a name="l01095"></a>01095 <span class="comment"> */</span>
<a name="l01096"></a>01096 <span class="keyword">extern</span> intmax_t
<a name="l01097"></a><a class="code" href="ccn__fetch_8c.html#acdb3b506baf522838f83fd53f9527145">01097</a> <a class="code" href="fetch_8h.html#acdb3b506baf522838f83fd53f9527145">ccn_fetch_position</a>(<span class="keyword">struct</span> ccn_fetch_stream *fs) {
<a name="l01098"></a>01098         <span class="keywordflow">return</span> fs-&gt;readPosition;
<a name="l01099"></a>01099 }
<a name="l01100"></a>01100 
<a name="l01101"></a>01101 
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Feb 4 11:56:47 2013 for Content-Centric Networking in C by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

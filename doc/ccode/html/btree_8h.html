<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Content-Centric Networking in C: include/ccn/btree.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_41e250420098d3193238c2ec3f91d540.html">include</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_fb678123179ff8fa3164fd7f81a7d8bd.html">ccn</a>
  </div>
</div>
<div class="contents">
<h1>btree.h File Reference</h1>
<p>BTree.  
<a href="#_details">More...</a></p>

<p><a href="btree_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structccn__btree__io.html">ccn_btree_io</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds the methods and the associated common data.  <a href="structccn__btree__io.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structccn__btree__node.html">ccn_btree_node</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">State associated with a btree node.  <a href="structccn__btree__node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structccn__btree.html">ccn_btree</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">State associated with a btree as a whole.  <a href="structccn__btree.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structccn__btree__node__header.html">ccn_btree_node_header</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure of a node.  <a href="structccn__btree__node__header.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structccn__btree__entry__trailer.html">ccn_btree_entry_trailer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure of a node entry trailer.  <a href="structccn__btree__entry__trailer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structccn__btree__internal__payload.html">ccn_btree_internal_payload</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure of the entry payload within an internal (non-leaf) node.  <a href="structccn__btree__internal__payload.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structccn__btree__internal__entry.html">ccn_btree_internal_entry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logical structure of the entry within an internal (non-leaf) node.  <a href="structccn__btree__internal__entry.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#ac297bf7bfe64d6b5630bbf06a121522a">CCN_BT_ACTIVITY_REFERENCE_BUMP</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment to node-&gt;activity when node is referenced but not changed.  <a href="#ac297bf7bfe64d6b5630bbf06a121522a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a50e9391b5fb45ba91f394aeba15de2a7">CCN_BT_ACTIVITY_READ_BUMP</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment to node-&gt;activity when node is read from disk.  <a href="#a50e9391b5fb45ba91f394aeba15de2a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a7c84776165eab9313f3db95a575d2eee">CCN_BT_ACTIVITY_UPDATE_BUMP</a>&nbsp;&nbsp;&nbsp;16</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment to node-&gt;activity when node is modified.  <a href="#a7c84776165eab9313f3db95a575d2eee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#adf5b6ce2d1428889ca2630907c6555ec">CCN_BT_OPEN_NODES_IDLE</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limit to the number of btree nodes kept open when idle.  <a href="#adf5b6ce2d1428889ca2630907c6555ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#adf5041f237d6de12af12a00b53837765">CCN_BT_OPEN_NODES_LIMIT</a>&nbsp;&nbsp;&nbsp;13</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limit to the number of file descriptors the btree should use at a time.  <a href="#adf5041f237d6de12af12a00b53837765"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#ad16e925eb7979e11d8c914d71291269d">CCN_BT_SIZE_UNITS</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a8118d42f2b6b916a43a67bd5969f6e63">CCN_BT_MAX_KEY_SIZE</a>&nbsp;&nbsp;&nbsp;65535</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum key size, dictated by size of above size fields.  <a href="#a8118d42f2b6b916a43a67bd5969f6e63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a2d3a0f06ae2b7081b41783ee881882fd">CCN_BT_INTERNAL_MAGIC</a>&nbsp;&nbsp;&nbsp;0xCC</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#ae049b8a0f5ba72ef645c77996e1e3dbf">CCN_BT_ENCRES</a>(ndx, success)&nbsp;&nbsp;&nbsp;(2 * (ndx) + ((success) || 0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#aa96ab187e6de12451cfec3cb3276fbad">CCN_BT_SRCH_FOUND</a>(res)&nbsp;&nbsp;&nbsp;((res) &amp; 1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#ae81f5445d9059cdb49f88700c6be6260">CCN_BT_SRCH_INDEX</a>(res)&nbsp;&nbsp;&nbsp;((res) &gt;&gt; 1)</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a628c27764e073796aedd050177687739">ccn_btree_io_openfn</a> )(struct <a class="el" href="structccn__btree__io.html">ccn_btree_io</a> *, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Methods for external I/O of btree nodes.  <a href="#a628c27764e073796aedd050177687739"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#aed3cdb2c73d1e73793c29e291b448d19">ccn_btree_io_readfn</a> )(struct <a class="el" href="structccn__btree__io.html">ccn_btree_io</a> *, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *, unsigned)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a6e565d97846b55ef29672b0d83746235">ccn_btree_io_writefn</a> )(struct <a class="el" href="structccn__btree__io.html">ccn_btree_io</a> *, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a3ee5f6483145126788377228d5c67480">ccn_btree_io_closefn</a> )(struct <a class="el" href="structccn__btree__io.html">ccn_btree_io</a> *, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#af88152e1fdaca4413140f345bbb931d8">ccn_btree_io_destroyfn</a> )(struct <a class="el" href="structccn__btree__io.html">ccn_btree_io</a> **)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a53f0208267d2b7670b87da0d125cc793">ccn_btree_node_nent</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of entries within the btree node.  <a href="#a53f0208267d2b7670b87da0d125cc793"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a964ab008628d589088d51a77c172fcc0">ccn_btree_node_level</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Node level (leaves are at level 0).  <a href="#a964ab008628d589088d51a77c172fcc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a3810b46c06c6c009dd65e100ba3aeb89">ccn_btree_node_getentrysize</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size, in bytes, of entries within the node.  <a href="#a3810b46c06c6c009dd65e100ba3aeb89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a91cc11d6d11d050e53dc3d314eef4fe3">ccn_btree_node_payloadsize</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size, in bytes, of payloads within the node.  <a href="#a91cc11d6d11d050e53dc3d314eef4fe3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a12c112fedde6f330541a5894cf3a345c">ccn_btree_node_getentry</a> (size_t payload_bytes, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the address of the indexed entry within the node.  <a href="#a12c112fedde6f330541a5894cf3a345c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#ad478f017de60f13b836c49bf80da0bf7">ccn_btree_key_fetch</a> (struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *dst, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the key within the indexed entry of node.  <a href="#ad478f017de60f13b836c49bf80da0bf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#adbbf114a7a7ab71685ab9f7ef7d4a3e6">ccn_btree_key_append</a> (struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *dst, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the key within the indexed entry of node to dst.  <a href="#adbbf114a7a7ab71685ab9f7ef7d4a3e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a16d8c91d021ee1b50cd683dc7d4d53a9">ccn_btree_compare</a> (const unsigned char *key, size_t size, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare given key with the key in the indexed entry of the node.  <a href="#a16d8c91d021ee1b50cd683dc7d4d53a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a962030880972eb33cffa68a8dcc7a67e">ccn_btree_searchnode</a> (const unsigned char *key, size_t size, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search the node for the given key.  <a href="#a962030880972eb33cffa68a8dcc7a67e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a4e37f446a434a87cbb9543e4255938ec">ccn_btree_insert_entry</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i, const unsigned char *key, size_t keysize, void *payload, size_t payload_bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a new entry into a node.  <a href="#a4e37f446a434a87cbb9543e4255938ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a76dee0722b2c356763f9a1e58e8b0762">ccn_btree_delete_entry</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an entry from a btree node.  <a href="#a76dee0722b2c356763f9a1e58e8b0762"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#aba692270580d406f7f881d5d40cfdf8a">ccn_btree_init_node</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int level, unsigned char nodetype, unsigned char extsz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the btree node.  <a href="#aba692270580d406f7f881d5d40cfdf8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a0d606bd6911b6d69aa8560d6e4af5fc5">ccn_btree_oversize</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for an oversize node.  <a href="#a0d606bd6911b6d69aa8560d6e4af5fc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a171342df16ccfe550df84f3b74d35ae9">ccn_btree_unbalance</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for an unbalanced node.  <a href="#a171342df16ccfe550df84f3b74d35ae9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#af338eb7f9360355c0aa0f6745247aa27">ccn_btree_chknode</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check a node for internal consistency.  <a href="#af338eb7f9360355c0aa0f6745247aa27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#aaab88f1077912aeeb0eec02181dfa303">ccn_btree_create</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new btree handle, not attached to any external files.  <a href="#aaab88f1077912aeeb0eec02181dfa303"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a3f0626bf0f9bd713268568ac778c07e1">ccn_btree_destroy</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> **)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a btree handle, shutting things down cleanly.  <a href="#a3f0626bf0f9bd713268568ac778c07e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a1545710226fd52d5add9693d8e5d94bb">ccn_btree_note_error</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *bt, int info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keep count of noticed errors.  <a href="#a1545710226fd52d5add9693d8e5d94bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a1d338dc49af6a334450d5ea747b30f7b">ccn_btree_getnode</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *bt, <a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a> nodeid, <a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a> parentid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a btree node, creating or reading it if necessary.  <a href="#a1d338dc49af6a334450d5ea747b30f7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#ab6f6b815d73dcd1ba2f3c06e8909aa90">ccn_btree_rnode</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *bt, <a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a> nodeid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a btree node that is already resident.  <a href="#ab6f6b815d73dcd1ba2f3c06e8909aa90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a101a77d88dfcd78834bcb18afb2726b9">ccn_btree_close_node</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write out any pending changes, mark the node clean, and release node iodata.  <a href="#a101a77d88dfcd78834bcb18afb2726b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#ac7c8275b9cf7e77bd98e783bcaad3bb4">ccn_btree_lookup</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, const unsigned char *key, size_t size, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **leafp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do a btree lookup, starting from the default root.  <a href="#ac7c8275b9cf7e77bd98e783bcaad3bb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#ab09151e71d638467fdf8c5a21d659ca8">ccn_btree_lookup_internal</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *root, int stoplevel, const unsigned char *key, size_t size, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **ansp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do a btree lookup, starting from the provided root and stopping at stoplevel.  <a href="#ab09151e71d638467fdf8c5a21d659ca8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a1660ef8caf7bdd794d775b235647815d">ccn_btree_index_in_parent</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *parent, <a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a> nodeid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for nodeid in parent.  <a href="#a1660ef8caf7bdd794d775b235647815d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a920dcb30f9b5ce208c144d2eec63bd78">ccn_btree_next_leaf</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **ansp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the leaf that comes after the given node.  <a href="#a920dcb30f9b5ce208c144d2eec63bd78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a746c4c3b7a0431c3353b79aff534d2e8">ccn_btree_prev_leaf</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **ansp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the leaf that comes before the given node.  <a href="#a746c4c3b7a0431c3353b79aff534d2e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a881bc0f4b86daa2a7a0291382f4865de">ccn_btree_split</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split a btree node.  <a href="#a881bc0f4b86daa2a7a0291382f4865de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a7293cf11a568723bda92cb5cd61caa41">ccn_btree_spill</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Eliminate a node by combining it with a sibling.  <a href="#a7293cf11a568723bda92cb5cd61caa41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#aa2e6c5c102528fc84744dec2a10f08e1">ccn_btree_prepare_for_update</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *bt, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get ready to update a btree node.  <a href="#aa2e6c5c102528fc84744dec2a10f08e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#ac518380f0561d0852cd9ba6ebaee2811">ccn_btree_check</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, FILE *outfp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the structure of the btree for consistency.  <a href="#ac518380f0561d0852cd9ba6ebaee2811"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structccn__btree__io.html">ccn_btree_io</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#ad5b664c9c2e9fd535b11a7ce6aaf116d">ccn_btree_io_from_directory</a> (const char *path, struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *msgs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a btree storage layer from a directory.  <a href="#ad5b664c9c2e9fd535b11a7ce6aaf116d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#aab31ae32858e3cca2559fc2ab36480da">ccn_btree_fetchval</a> (const unsigned char *p, int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="btree_8h.html#a21d4909338c9f22738daca415c2bf89e">ccn_btree_storeval</a> (unsigned char *p, int size, unsigned v)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>BTree. </p>

<p>Definition in file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a50e9391b5fb45ba91f394aeba15de2a7"></a><!-- doxytag: member="btree.h::CCN_BT_ACTIVITY_READ_BUMP" ref="a50e9391b5fb45ba91f394aeba15de2a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BT_ACTIVITY_READ_BUMP&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increment to node-&gt;activity when node is read from disk. </p>

<p>Definition at line <a class="el" href="btree_8h_source.html#l00111">111</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01368">ccn_btree_getnode()</a>.</p>

</div>
</div>
<a class="anchor" id="ac297bf7bfe64d6b5630bbf06a121522a"></a><!-- doxytag: member="btree.h::CCN_BT_ACTIVITY_REFERENCE_BUMP" ref="ac297bf7bfe64d6b5630bbf06a121522a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BT_ACTIVITY_REFERENCE_BUMP&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increment to node-&gt;activity when node is referenced but not changed. </p>

<p>Definition at line <a class="el" href="btree_8h_source.html#l00109">109</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01368">ccn_btree_getnode()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c84776165eab9313f3db95a575d2eee"></a><!-- doxytag: member="btree.h::CCN_BT_ACTIVITY_UPDATE_BUMP" ref="a7c84776165eab9313f3db95a575d2eee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BT_ACTIVITY_UPDATE_BUMP&nbsp;&nbsp;&nbsp;16</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increment to node-&gt;activity when node is modified. </p>

<p>Definition at line <a class="el" href="btree_8h_source.html#l00113">113</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01537">ccn_btree_prepare_for_update()</a>.</p>

</div>
</div>
<a class="anchor" id="ae049b8a0f5ba72ef645c77996e1e3dbf"></a><!-- doxytag: member="btree.h::CCN_BT_ENCRES" ref="ae049b8a0f5ba72ef645c77996e1e3dbf" args="(ndx, success)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BT_ENCRES</td>
          <td>(</td>
          <td class="paramtype">ndx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">success&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(2 * (ndx) + ((success) || 0))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="btree_8h_source.html#l00245">245</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00332">ccn_btree_searchnode()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00450">test_btree_lookup()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00348">test_btree_searchnode()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d3a0f06ae2b7081b41783ee881882fd"></a><!-- doxytag: member="btree.h::CCN_BT_INTERNAL_MAGIC" ref="a2d3a0f06ae2b7081b41783ee881882fd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BT_INTERNAL_MAGIC&nbsp;&nbsp;&nbsp;0xCC</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="btree_8h_source.html#l00206">206</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00126">ccn_btree_node_internal_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00797">ccn_btree_update_cached_parent()</a>.</p>

</div>
</div>
<a class="anchor" id="a8118d42f2b6b916a43a67bd5969f6e63"></a><!-- doxytag: member="btree.h::CCN_BT_MAX_KEY_SIZE" ref="a8118d42f2b6b916a43a67bd5969f6e63" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BT_MAX_KEY_SIZE&nbsp;&nbsp;&nbsp;65535</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum key size, dictated by size of above size fields. </p>

<p>Definition at line <a class="el" href="btree_8h_source.html#l00196">196</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>.</p>

</div>
</div>
<a class="anchor" id="adf5b6ce2d1428889ca2630907c6555ec"></a><!-- doxytag: member="btree.h::CCN_BT_OPEN_NODES_IDLE" ref="adf5b6ce2d1428889ca2630907c6555ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BT_OPEN_NODES_IDLE&nbsp;&nbsp;&nbsp;5</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Limit to the number of btree nodes kept open when idle. </p>

<p>Definition at line <a class="el" href="btree_8h_source.html#l00116">116</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l01527">r_store_index_cleaner()</a>.</p>

</div>
</div>
<a class="anchor" id="adf5041f237d6de12af12a00b53837765"></a><!-- doxytag: member="btree.h::CCN_BT_OPEN_NODES_LIMIT" ref="adf5041f237d6de12af12a00b53837765" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BT_OPEN_NODES_LIMIT&nbsp;&nbsp;&nbsp;13</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Limit to the number of file descriptors the btree should use at a time. </p>

<p>Definition at line <a class="el" href="btree_8h_source.html#l00118">118</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01368">ccn_btree_getnode()</a>, and <a class="el" href="ccnr__store_8c_source.html#l01622">r_store_index_needs_cleaning()</a>.</p>

</div>
</div>
<a class="anchor" id="ad16e925eb7979e11d8c914d71291269d"></a><!-- doxytag: member="btree.h::CCN_BT_SIZE_UNITS" ref="ad16e925eb7979e11d8c914d71291269d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BT_SIZE_UNITS&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="btree_8h_source.html#l00194">194</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01450">ccn_btree_chknode()</a>, <a class="el" href="ccn__btree_8c_source.html#l00598">ccn_btree_delete_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l01331">ccn_btree_init_node()</a>, <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00108">ccn_btree_node_getentry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00166">ccn_btree_node_getentrysize()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00146">check_structure_size()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00074">seek_trailer()</a>.</p>

</div>
</div>
<a class="anchor" id="aa96ab187e6de12451cfec3cb3276fbad"></a><!-- doxytag: member="btree.h::CCN_BT_SRCH_FOUND" ref="aa96ab187e6de12451cfec3cb3276fbad" args="(res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BT_SRCH_FOUND</td>
          <td>(</td>
          <td class="paramtype">res&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((res) &amp; 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="btree_8h_source.html#l00246">246</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00395">ccn_btree_lookup_internal()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnr__store_8c_source.html#l00706">r_store_content_btree_insert()</a>, <a class="el" href="ccnr__store_8c_source.html#l01095">r_store_lookup()</a>, <a class="el" href="ccnr__store_8c_source.html#l01413">r_store_set_accession_from_offset()</a>, <a class="el" href="ccnr__sync_8c_source.html#l00221">r_sync_enumerate_action()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00555">test_basic_btree_delete_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00492">test_basic_btree_insert_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00875">test_insert_content()</a>.</p>

</div>
</div>
<a class="anchor" id="ae81f5445d9059cdb49f88700c6be6260"></a><!-- doxytag: member="btree.h::CCN_BT_SRCH_INDEX" ref="ae81f5445d9059cdb49f88700c6be6260" args="(res)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BT_SRCH_INDEX</td>
          <td>(</td>
          <td class="paramtype">res&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((res) &gt;&gt; 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="btree_8h_source.html#l00247">247</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00395">ccn_btree_lookup_internal()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnr__store_8c_source.html#l00706">r_store_content_btree_insert()</a>, <a class="el" href="ccnr__store_8c_source.html#l00810">r_store_look()</a>, <a class="el" href="ccnr__store_8c_source.html#l01095">r_store_lookup()</a>, <a class="el" href="ccnr__store_8c_source.html#l00928">r_store_lookup_backwards()</a>, <a class="el" href="ccnr__store_8c_source.html#l01413">r_store_set_accession_from_offset()</a>, <a class="el" href="ccnr__sync_8c_source.html#l00221">r_sync_enumerate_action()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00555">test_basic_btree_delete_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00492">test_basic_btree_insert_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00875">test_insert_content()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00805">testhelp_count_matches()</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aa302edee5118eed1881dac5108371a09"></a><!-- doxytag: member="btree.h::ccn_btnodeid" ref="aa302edee5118eed1881dac5108371a09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="btree_8h_source.html#l00075">75</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ee5f6483145126788377228d5c67480"></a><!-- doxytag: member="btree.h::ccn_btree_io_closefn" ref="a3ee5f6483145126788377228d5c67480" args=")(struct ccn_btree_io *, struct ccn_btree_node *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="btree_8h.html#a3ee5f6483145126788377228d5c67480">ccn_btree_io_closefn</a>)(struct <a class="el" href="structccn__btree__io.html">ccn_btree_io</a> *, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="btree_8h_source.html#l00070">70</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

</div>
</div>
<a class="anchor" id="af88152e1fdaca4413140f345bbb931d8"></a><!-- doxytag: member="btree.h::ccn_btree_io_destroyfn" ref="af88152e1fdaca4413140f345bbb931d8" args=")(struct ccn_btree_io **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="btree_8h.html#af88152e1fdaca4413140f345bbb931d8">ccn_btree_io_destroyfn</a>)(struct <a class="el" href="structccn__btree__io.html">ccn_btree_io</a> **)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="btree_8h_source.html#l00072">72</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a628c27764e073796aedd050177687739"></a><!-- doxytag: member="btree.h::ccn_btree_io_openfn" ref="a628c27764e073796aedd050177687739" args=")(struct ccn_btree_io *, struct ccn_btree_node *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="btree_8h.html#a628c27764e073796aedd050177687739">ccn_btree_io_openfn</a>)(struct <a class="el" href="structccn__btree__io.html">ccn_btree_io</a> *, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Methods for external I/O of btree nodes. </p>
<p>These are supplied by the client, and provide an abstraction to hold the persistent representation of the btree.</p>
<p>Each node has a nodeid that serves as its filename. These start as 1 and are assigned consecutively. The node may correspond to a file in a file system, or to some other abstraction as appropriate.</p>
<p>Open should prepare for I/O to a node. It may use the iodata slot to keep track of its state, and should set iodata to a non-NULL value. It should update the count of openfds as appropriate.</p>
<p>Read gets bytes from the file and places it into the buffer at the corresponding position. The parameter is a limit for the max buffer size. Bytes prior to the clean mark do not need to be read. The buffer should be extended, if necessary, to hold the data. Read is not responsible for updating the clean mark.</p>
<p>Write puts bytes from the buffer into the file, and truncates the file according to the buffer length. Bytes prior to the clean mork do not need to be written, since they should be the same in the buffer and the file. Write is not responsible for updating the clean mark.</p>
<p>Close is called at the obvious time. It should free any node io state and set iodata to NULL, updating openfds as appropriate. It should not change the other parts of the node.</p>
<p>Negative return values indicate errors. </p>

<p>Definition at line <a class="el" href="btree_8h_source.html#l00064">64</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

</div>
</div>
<a class="anchor" id="aed3cdb2c73d1e73793c29e291b448d19"></a><!-- doxytag: member="btree.h::ccn_btree_io_readfn" ref="aed3cdb2c73d1e73793c29e291b448d19" args=")(struct ccn_btree_io *, struct ccn_btree_node *, unsigned)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="btree_8h.html#aed3cdb2c73d1e73793c29e291b448d19">ccn_btree_io_readfn</a>)(struct <a class="el" href="structccn__btree__io.html">ccn_btree_io</a> *, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *, unsigned)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="btree_8h_source.html#l00066">66</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6e565d97846b55ef29672b0d83746235"></a><!-- doxytag: member="btree.h::ccn_btree_io_writefn" ref="a6e565d97846b55ef29672b0d83746235" args=")(struct ccn_btree_io *, struct ccn_btree_node *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="btree_8h.html#a6e565d97846b55ef29672b0d83746235">ccn_btree_io_writefn</a>)(struct <a class="el" href="structccn__btree__io.html">ccn_btree_io</a> *, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="btree_8h_source.html#l00068">68</a> of file <a class="el" href="btree_8h_source.html">btree.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac518380f0561d0852cd9ba6ebaee2811"></a><!-- doxytag: member="btree.h::ccn_btree_check" ref="ac518380f0561d0852cd9ba6ebaee2811" args="(struct ccn_btree *btree, FILE *outfp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_check </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>outfp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the structure of the btree for consistency. </p>
<p>If outfp is not NULL, information about structure will be written. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 if an error was found. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01597">1597</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l00487">r_store_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00450">test_btree_lookup()</a>.</p>

</div>
</div>
<a class="anchor" id="af338eb7f9360355c0aa0f6745247aa27"></a><!-- doxytag: member="btree.h::ccn_btree_chknode" ref="af338eb7f9360355c0aa0f6745247aa27" args="(struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_chknode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check a node for internal consistency. </p>
<p>Sets or clears node-&gt;corrupt as appropriate. In case of success, sets the correct value for node-&gt;freelow</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>old value of node-&gt;corrupt if the node looks OK, otherwise -1 </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01450">1450</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l01368">ccn_btree_getnode()</a>, <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l01537">ccn_btree_prepare_for_update()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00421">example_btree_small()</a>, <a class="el" href="ccnr__store_8c_source.html#l01527">r_store_index_cleaner()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00555">test_basic_btree_delete_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00492">test_basic_btree_insert_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00242">test_btree_chknode()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00875">test_insert_content()</a>.</p>

</div>
</div>
<a class="anchor" id="a101a77d88dfcd78834bcb18afb2726b9"></a><!-- doxytag: member="btree.h::ccn_btree_close_node" ref="a101a77d88dfcd78834bcb18afb2726b9" args="(struct ccn_btree *btree, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_close_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out any pending changes, mark the node clean, and release node iodata. </p>
<p>Retains the cached node data in memory.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success or -1 for error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01221">1221</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l01246">finalize_node()</a>, and <a class="el" href="ccnr__store_8c_source.html#l01527">r_store_index_cleaner()</a>.</p>

</div>
</div>
<a class="anchor" id="a16d8c91d021ee1b50cd683dc7d4d53a9"></a><!-- doxytag: member="btree.h::ccn_btree_compare" ref="a16d8c91d021ee1b50cd683dc7d4d53a9" args="(const unsigned char *key, size_t size, struct ccn_btree_node *node, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_compare </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare given key with the key in the indexed entry of the node. </p>
<p>The comparison is a standard lexicographic one on unsigned bytes; that is, there is no assumption of what the bytes actually encode.</p>
<p>The special return value -9999 indicates the key is a strict prefix. This does not matter to the btree lookup, but is useful for higher levels.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>negative, zero, or positive to indicate less, equal, or greater </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00271">271</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l00332">ccn_btree_searchnode()</a>, <a class="el" href="ccnr__store_8c_source.html#l00928">r_store_lookup_backwards()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00318">test_btree_compare()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00805">testhelp_count_matches()</a>.</p>

</div>
</div>
<a class="anchor" id="aaab88f1077912aeeb0eec02181dfa303"></a><!-- doxytag: member="btree.h::ccn_btree_create" ref="aaab88f1077912aeeb0eec02181dfa303" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structccn__btree.html">ccn_btree</a>* ccn_btree_create </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new btree handle, not attached to any external files. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>new handle, or NULL in case of error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01273">1273</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnbtreetest_8c_source.html#l00421">example_btree_small()</a>, <a class="el" href="ccnr__store_8c_source.html#l00487">r_store_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00394">test_btree_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00875">test_insert_content()</a>.</p>

</div>
</div>
<a class="anchor" id="a76dee0722b2c356763f9a1e58e8b0762"></a><!-- doxytag: member="btree.h::ccn_btree_delete_entry" ref="a76dee0722b2c356763f9a1e58e8b0762" args="(struct ccn_btree_node *node, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_delete_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an entry from a btree node. </p>
<p>The caller is responsible for triggering a merge.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the new entry count, or -1 in case of error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00598">598</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00555">test_basic_btree_delete_entry()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="a3f0626bf0f9bd713268568ac778c07e1"></a><!-- doxytag: member="btree.h::ccn_btree_destroy" ref="a3f0626bf0f9bd713268568ac778c07e1" args="(struct ccn_btree **)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> **&nbsp;</td>
          <td class="paramname"> <em>pbt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroys a btree handle, shutting things down cleanly. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a negative value in case of error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01301">1301</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l00605">r_store_final()</a>, <a class="el" href="ccnr__store_8c_source.html#l00487">r_store_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00555">test_basic_btree_delete_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00492">test_basic_btree_insert_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00394">test_btree_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00450">test_btree_lookup()</a>.</p>

</div>
</div>
<a class="anchor" id="aab31ae32858e3cca2559fc2ab36480da"></a><!-- doxytag: member="btree.h::ccn_btree_fetchval" ref="aab31ae32858e3cca2559fc2ab36480da" args="(const unsigned char *p, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ccn_btree_fetchval </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00040">40</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

</div>
</div>
<a class="anchor" id="a1d338dc49af6a334450d5ea747b30f7b"></a><!-- doxytag: member="btree.h::ccn_btree_getnode" ref="a1d338dc49af6a334450d5ea747b30f7b" args="(struct ccn_btree *bt, ccn_btnodeid nodeid, ccn_btnodeid parentid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a>* ccn_btree_getnode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>bt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a>&nbsp;</td>
          <td class="paramname"> <em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a>&nbsp;</td>
          <td class="paramname"> <em>parentid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access a btree node, creating or reading it if necessary. </p>
<p>Care should be taken to not store the node handle in data structures, since it will become invalid when the node gets flushed from the resident cache.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>node handle </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01368">1368</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00371">ccn_btree_lookup()</a>, <a class="el" href="ccn__btree_8c_source.html#l00395">ccn_btree_lookup_internal()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l01168">ccn_btree_prev_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00421">example_btree_small()</a>, <a class="el" href="ccnr__store_8c_source.html#l00706">r_store_content_btree_insert()</a>, <a class="el" href="ccnr__store_8c_source.html#l00487">r_store_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00394">test_btree_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00875">test_insert_content()</a>.</p>

</div>
</div>
<a class="anchor" id="a1660ef8caf7bdd794d775b235647815d"></a><!-- doxytag: member="btree.h::ccn_btree_index_in_parent" ref="a1660ef8caf7bdd794d775b235647815d" args="(struct ccn_btree_node *parent, ccn_btnodeid nodeid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_index_in_parent </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a>&nbsp;</td>
          <td class="paramname"> <em>nodeid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for nodeid in parent. </p>
<p>This does not rely on the keys, but just scans the entries.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index within parent, or -1 if there is an error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00970">970</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01168">ccn_btree_prev_leaf()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>.</p>

</div>
</div>
<a class="anchor" id="aba692270580d406f7f881d5d40cfdf8a"></a><!-- doxytag: member="btree.h::ccn_btree_init_node" ref="aba692270580d406f7f881d5d40cfdf8a" args="(struct ccn_btree_node *node, int level, unsigned char nodetype, unsigned char extsz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_init_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>nodetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>extsz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the btree node. </p>
<p>It is the caller's responsibility to be sure that the node does not contain any useful information.</p>
<p>Leaves alone nodeid, iodata, and activity fields.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 for error, 0 for success </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01331">1331</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnr__store_8c_source.html#l00487">r_store_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00875">test_insert_content()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e37f446a434a87cbb9543e4255938ec"></a><!-- doxytag: member="btree.h::ccn_btree_insert_entry" ref="a4e37f446a434a87cbb9543e4255938ec" args="(struct ccn_btree_node *node, int i, const unsigned char *key, size_t keysize, void *payload, size_t payload_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_insert_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>keysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>payload_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a new entry into a node. </p>
<p>The caller is responsible for providing the correct index i, which will become the index of the new entry.</p>
<p>The caller is also responsible for triggering a split.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the new entry count, or -1 in case of error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00491">491</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree__content_8c_source.html#l00076">ccn_btree_insert_content()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00492">test_basic_btree_insert_entry()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="ad5b664c9c2e9fd535b11a7ce6aaf116d"></a><!-- doxytag: member="btree.h::ccn_btree_io_from_directory" ref="ad5b664c9c2e9fd535b11a7ce6aaf116d" args="(const char *path, struct ccn_charbuf *msgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structccn__btree__io.html">ccn_btree_io</a>* ccn_btree_io_from_directory </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>msgs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a btree storage layer from a directory. </p>
<p>In this implementation of the storage layer, each btree block is stored as a separate file. The files are named using the decimal representation of the nodeid.</p>
<p>If msgs is not NULL, diagnostics may be recorded there.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>is the name of the directory, which must exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the new <a class="el" href="structccn__btree__io.html" title="Holds the methods and the associated common data.">ccn_btree_io</a> handle, or sets errno and returns NULL. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree__store_8c_source.html#l00057">57</a> of file <a class="el" href="ccn__btree__store_8c_source.html">ccn_btree_store.c</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l00487">r_store_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00088">test_btree_io()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00175">test_btree_lockfile()</a>.</p>

</div>
</div>
<a class="anchor" id="adbbf114a7a7ab71685ab9f7ef7d4a3e6"></a><!-- doxytag: member="btree.h::ccn_btree_key_append" ref="adbbf114a7a7ab71685ab9f7ef7d4a3e6" args="(struct ccn_charbuf *dst, struct ccn_btree_node *node, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_key_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append the key within the indexed entry of node to dst. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 in case of error </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00231">231</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00218">ccn_btree_key_fetch()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00268">test_btree_key_fetch()</a>.</p>

</div>
</div>
<a class="anchor" id="ad478f017de60f13b836c49bf80da0bf7"></a><!-- doxytag: member="btree.h::ccn_btree_key_fetch" ref="ad478f017de60f13b836c49bf80da0bf7" args="(struct ccn_charbuf *dst, struct ccn_btree_node *node, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_key_fetch </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the key within the indexed entry of node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 in case of error </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00218">218</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree__content_8c_source.html#l00143">ccn_btree_match_interest()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00452">ccn_btree_smallest_key_under()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnr__store_8c_source.html#l00810">r_store_look()</a>, <a class="el" href="ccnr__store_8c_source.html#l00928">r_store_lookup_backwards()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00268">test_btree_key_fetch()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7c8275b9cf7e77bd98e783bcaad3bb4"></a><!-- doxytag: member="btree.h::ccn_btree_lookup" ref="ac7c8275b9cf7e77bd98e783bcaad3bb4" args="(struct ccn_btree *btree, const unsigned char *key, size_t size, struct ccn_btree_node **leafp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_lookup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **&nbsp;</td>
          <td class="paramname"> <em>leafp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do a btree lookup, starting from the default root. </p>
<p>In the absence of errors, if *leafp is not NULL the handle for the appropriate leaf node will be stored. See <a class="el" href="btree_8h.html#a1d338dc49af6a334450d5ea747b30f7b" title="Access a btree node, creating or reading it if necessary.">ccn_btree_getnode()</a> for warning about lifetime of the resulting pointer.</p>
<p>The return value is encoded as for <a class="el" href="btree_8h.html#a962030880972eb33cffa68a8dcc7a67e" title="Search the node for the given key.">ccn_btree_searchnode()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="btree_8h.html#ae049b8a0f5ba72ef645c77996e1e3dbf">CCN_BT_ENCRES(index, success)</a> indication, or -1 for an error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00371">371</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l00706">r_store_content_btree_insert()</a>, <a class="el" href="ccnr__store_8c_source.html#l00810">r_store_look()</a>, <a class="el" href="ccnr__store_8c_source.html#l01095">r_store_lookup()</a>, <a class="el" href="ccnr__store_8c_source.html#l00928">r_store_lookup_backwards()</a>, <a class="el" href="ccnr__store_8c_source.html#l01413">r_store_set_accession_from_offset()</a>, <a class="el" href="ccnr__sync_8c_source.html#l00221">r_sync_enumerate_action()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00555">test_basic_btree_delete_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00492">test_basic_btree_insert_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00450">test_btree_lookup()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00875">test_insert_content()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00805">testhelp_count_matches()</a>.</p>

</div>
</div>
<a class="anchor" id="ab09151e71d638467fdf8c5a21d659ca8"></a><!-- doxytag: member="btree.h::ccn_btree_lookup_internal" ref="ab09151e71d638467fdf8c5a21d659ca8" args="(struct ccn_btree *btree, struct ccn_btree_node *root, int stoplevel, const unsigned char *key, size_t size, struct ccn_btree_node **ansp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_lookup_internal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stoplevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **&nbsp;</td>
          <td class="paramname"> <em>ansp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do a btree lookup, starting from the provided root and stopping at stoplevel. </p>
<p>In the absence of errors, if *ansp is not NULL the handle for the appropriate node will be stored. See <a class="el" href="btree_8h.html#a1d338dc49af6a334450d5ea747b30f7b" title="Access a btree node, creating or reading it if necessary.">ccn_btree_getnode()</a> for warning about lifetime of the resulting pointer.</p>
<p>The return value is encoded as for <a class="el" href="btree_8h.html#a962030880972eb33cffa68a8dcc7a67e" title="Search the node for the given key.">ccn_btree_searchnode()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="btree_8h.html#ae049b8a0f5ba72ef645c77996e1e3dbf">CCN_BT_ENCRES(index, success)</a> indication, or -1 for an error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00395">395</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00371">ccn_btree_lookup()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00452">ccn_btree_smallest_key_under()</a>.</p>

</div>
</div>
<a class="anchor" id="a920dcb30f9b5ce208c144d2eec63bd78"></a><!-- doxytag: member="btree.h::ccn_btree_next_leaf" ref="a920dcb30f9b5ce208c144d2eec63bd78" args="(struct ccn_btree *btree, struct ccn_btree_node *node, struct ccn_btree_node **ansp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_next_leaf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **&nbsp;</td>
          <td class="paramname"> <em>ansp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the leaf that comes after the given node. </p>
<p>This may be used to walk though the leaf nodes in order. If success, sets *ansp to a leaf pointer or NULL </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if at end, 1 if *ansp is not NULL, -1 if error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01101">1101</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l00810">r_store_look()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="a12c112fedde6f330541a5894cf3a345c"></a><!-- doxytag: member="btree.h::ccn_btree_node_getentry" ref="a12c112fedde6f330541a5894cf3a345c" args="(size_t payload_bytes, struct ccn_btree_node *node, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ccn_btree_node_getentry </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>payload_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the address of the indexed entry within the node. </p>
<p>payload_bytes must be divisible by CCN_BT_SIZE_UNITS.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL in case of error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00108">108</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree__content_8c_source.html#l00227">ccn_btree_content_cobid()</a>, <a class="el" href="ccn__btree__content_8c_source.html#l00266">ccn_btree_content_cobsz()</a>, <a class="el" href="ccn__btree__content_8c_source.html#l00244">ccn_btree_content_set_cobid()</a>, <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>, <a class="el" href="ccn__btree__content_8c_source.html#l00143">ccn_btree_match_interest()</a>, <a class="el" href="ccn__btree_8c_source.html#l00126">ccn_btree_node_internal_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>.</p>

</div>
</div>
<a class="anchor" id="a3810b46c06c6c009dd65e100ba3aeb89"></a><!-- doxytag: member="btree.h::ccn_btree_node_getentrysize" ref="a3810b46c06c6c009dd65e100ba3aeb89" args="(struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_node_getentrysize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size, in bytes, of entries within the node. </p>
<p>If there are no entries, returns 0. This size includes the entry trailer.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size, or -1 for error </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00166">166</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00598">ccn_btree_delete_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00189">ccn_btree_node_payloadsize()</a>.</p>

</div>
</div>
<a class="anchor" id="a964ab008628d589088d51a77c172fcc0"></a><!-- doxytag: member="btree.h::ccn_btree_node_level" ref="a964ab008628d589088d51a77c172fcc0" args="(struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_node_level </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Node level (leaves are at level 0). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the node level, or -1 for error </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00203">203</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00395">ccn_btree_lookup_internal()</a>, <a class="el" href="ccn__btree_8c_source.html#l01168">ccn_btree_prev_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccn__btree_8c_source.html#l00773">ccn_btree_unbalance()</a>, <a class="el" href="ccn__btree_8c_source.html#l00470">scan_reusable()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00450">test_btree_lookup()</a>.</p>

</div>
</div>
<a class="anchor" id="a53f0208267d2b7670b87da0d125cc793"></a><!-- doxytag: member="btree.h::ccn_btree_node_nent" ref="a53f0208267d2b7670b87da0d125cc793" args="(struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_node_nent </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of entries within the btree node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of entries, or -1 for error </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00144">144</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l01450">ccn_btree_chknode()</a>, <a class="el" href="ccn__btree_8c_source.html#l00598">ccn_btree_delete_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00970">ccn_btree_index_in_parent()</a>, <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l01168">ccn_btree_prev_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00332">ccn_btree_searchnode()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccn__btree_8c_source.html#l00773">ccn_btree_unbalance()</a>, <a class="el" href="ccnr__store_8c_source.html#l00810">r_store_look()</a>, <a class="el" href="ccnr__store_8c_source.html#l00928">r_store_lookup_backwards()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00348">test_btree_searchnode()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00805">testhelp_count_matches()</a>.</p>

</div>
</div>
<a class="anchor" id="a91cc11d6d11d050e53dc3d314eef4fe3"></a><!-- doxytag: member="btree.h::ccn_btree_node_payloadsize" ref="a91cc11d6d11d050e53dc3d314eef4fe3" args="(struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_node_payloadsize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size, in bytes, of payloads within the node. </p>
<p>If there are no entries, returns 0. This does not include the entry trailer, but will include padding to a multiple of CCN_BT_SIZE_UNITS.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size, or -1 for error </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00189">189</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>.</p>

</div>
</div>
<a class="anchor" id="a1545710226fd52d5add9693d8e5d94bb"></a><!-- doxytag: member="btree.h::ccn_btree_note_error" ref="a1545710226fd52d5add9693d8e5d94bb" args="(struct ccn_btree *bt, int info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccn_btree_note_error </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>bt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Keep count of noticed errors. </p>
<p>Do this in one place so it is easy to set a breakpoint. </p>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01263">1263</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l01221">ccn_btree_close_node()</a>, <a class="el" href="ccn__btree_8c_source.html#l01368">ccn_btree_getnode()</a>, <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00395">ccn_btree_lookup_internal()</a>, <a class="el" href="ccn__btree_8c_source.html#l01537">ccn_btree_prepare_for_update()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d606bd6911b6d69aa8560d6e4af5fc5"></a><!-- doxytag: member="btree.h::ccn_btree_oversize" ref="a0d606bd6911b6d69aa8560d6e4af5fc5" args="(struct ccn_btree *btree, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_oversize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for an oversize node. </p>
<p>This takes into account both the size of a node and the count of entries.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a boolean result. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00759">759</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, and <a class="el" href="ccnr__store_8c_source.html#l00706">r_store_content_btree_insert()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2e6c5c102528fc84744dec2a10f08e1"></a><!-- doxytag: member="btree.h::ccn_btree_prepare_for_update" ref="aa2e6c5c102528fc84744dec2a10f08e1" args="(struct ccn_btree *bt, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_prepare_for_update </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>bt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get ready to update a btree node. </p>
<p>If applicable, open the node so that it will be in a good state to write later on.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if OK, -1 for error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01537">1537</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnr__store_8c_source.html#l00706">r_store_content_btree_insert()</a>, and <a class="el" href="ccnr__store_8c_source.html#l01413">r_store_set_accession_from_offset()</a>.</p>

</div>
</div>
<a class="anchor" id="a746c4c3b7a0431c3353b79aff534d2e8"></a><!-- doxytag: member="btree.h::ccn_btree_prev_leaf" ref="a746c4c3b7a0431c3353b79aff534d2e8" args="(struct ccn_btree *btree, struct ccn_btree_node *node, struct ccn_btree_node **ansp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_prev_leaf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **&nbsp;</td>
          <td class="paramname"> <em>ansp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the leaf that comes before the given node. </p>
<p>This may be used to walk though the leaf nodes in reverse order. If success, sets *ansp to a leaf pointer or NULL </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if at beginning, 1 if *ansp is not NULL, -1 if error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01168">1168</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l00928">r_store_lookup_backwards()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="ab6f6b815d73dcd1ba2f3c06e8909aa90"></a><!-- doxytag: member="btree.h::ccn_btree_rnode" ref="ab6f6b815d73dcd1ba2f3c06e8909aa90" args="(struct ccn_btree *bt, ccn_btnodeid nodeid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a>* ccn_btree_rnode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>bt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a>&nbsp;</td>
          <td class="paramname"> <em>nodeid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access a btree node that is already resident. </p>
<p>Care should be taken to not store the node handle in data structures, since it will become invalid when the node gets flushed from the resident cache.</p>
<p>This call does not bump the activity counter.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>node handle, or NULL if the node is not currently resident. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01436">1436</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00797">ccn_btree_update_cached_parent()</a>, <a class="el" href="ccnr__store_8c_source.html#l01527">r_store_index_cleaner()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00394">test_btree_init()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="a962030880972eb33cffa68a8dcc7a67e"></a><!-- doxytag: member="btree.h::ccn_btree_searchnode" ref="a962030880972eb33cffa68a8dcc7a67e" args="(const unsigned char *key, size_t size, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_searchnode </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search the node for the given key. </p>
<p>The return value is encoded as 2 * index + (found ? 1 : 0); that is, a successful search returns an odd number and an unsuccessful search returns an even number. In the case of an unsuccessful search, the index indicates where the item would go if it were to be inserted.</p>
<p>Uses a binary search, so the keys in the node must be sorted and unique.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="btree_8h.html#ae049b8a0f5ba72ef645c77996e1e3dbf">CCN_BT_ENCRES(index, success)</a> indication, or -1 for an error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00332">332</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00395">ccn_btree_lookup_internal()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00348">test_btree_searchnode()</a>.</p>

</div>
</div>
<a class="anchor" id="a7293cf11a568723bda92cb5cd61caa41"></a><!-- doxytag: member="btree.h::ccn_btree_spill" ref="a7293cf11a568723bda92cb5cd61caa41" args="(struct ccn_btree *btree, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_spill </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Eliminate a node by combining it with a sibling. </p>
<p>In success case, the node will be emptied out completely, and The parent node will have one fewer child. It is possible for a sibling to need splitting; in this case btree-&gt;nextsplit will be set accordingly.</p>
<p>btree-&gt;nextspill will be set if there are more nodes to spill.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success, 1 if deferred to left, -1 if error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00999">999</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="a881bc0f4b86daa2a7a0291382f4865de"></a><!-- doxytag: member="btree.h::ccn_btree_split" ref="a881bc0f4b86daa2a7a0291382f4865de" args="(struct ccn_btree *btree, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_split </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a btree node. </p>
<p>This creates a new sibling, and distributes the entries of node between the two.</p>
<p>The node's parent gains a child; if in doing so, it grows too large, the parent will be noted in btree-&gt;nextsplit for the caller to deal with.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success, -1 in case of error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00828">828</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l00706">r_store_content_btree_insert()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00492">test_basic_btree_insert_entry()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="a21d4909338c9f22738daca415c2bf89e"></a><!-- doxytag: member="btree.h::ccn_btree_storeval" ref="a21d4909338c9f22738daca415c2bf89e" args="(unsigned char *p, int size, unsigned v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccn_btree_storeval </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00054">54</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

</div>
</div>
<a class="anchor" id="a171342df16ccfe550df84f3b74d35ae9"></a><!-- doxytag: member="btree.h::ccn_btree_unbalance" ref="a171342df16ccfe550df84f3b74d35ae9" args="(struct ccn_btree *btree, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_unbalance </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for an unbalanced node. </p>
<p>This takes into account both the size of a node and the count of entries.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if node is too big, -1 if too small, 0 if just right. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00773">773</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00759">ccn_btree_oversize()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Feb 4 11:57:05 2013 for Content-Centric Networking in C by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

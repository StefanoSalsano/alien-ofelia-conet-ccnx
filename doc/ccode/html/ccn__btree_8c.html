<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Content-Centric Networking in C: lib/ccn_btree.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_b8e74f80653d868cec04ba0ac37e4e28.html">lib</a>
  </div>
</div>
<div class="contents">
<h1>ccn_btree.c File Reference</h1>
<p><a href="ccn__btree_8c_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a79754b043e1074fdff84e2b9b49d16bd">MYFETCH</a>(p, f)&nbsp;&nbsp;&nbsp;ccn_btree_fetchval(&amp;((p)-&gt;f[0]), sizeof((p)-&gt;f))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a6092c6d641e9abf62ba79fbdbb580635">MYSTORE</a>(p, f, v)&nbsp;&nbsp;&nbsp;ccn_btree_storeval(&amp;((p)-&gt;f[0]), sizeof((p)-&gt;f), (v))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#ab47360d2d6dfd1c3205f7d409e17efcf">MIN_NODE_BYTES</a>&nbsp;&nbsp;&nbsp;(sizeof(struct <a class="el" href="structccn__btree__node__header.html">ccn_btree_node_header</a>) + sizeof(struct <a class="el" href="structccn__btree__entry__trailer.html">ccn_btree_entry_trailer</a>))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum size of a non-empty node.  <a href="#ab47360d2d6dfd1c3205f7d409e17efcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a3941e519b8496aa7693b48f471f85b2c">MSG</a>(fmt,...)&nbsp;&nbsp;&nbsp;((void)0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a4b03a76e6dd793e27c7719e7c405001b">CCN_BTREE_MAGIC</a>&nbsp;&nbsp;&nbsp;0x53ade78</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a3021842f9b9b491d3e2e9a37d97fc336">CCN_BTREE_VERSION</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#aeb23fa33594902c3f3525754e59ba0b8">CCN_BTREE_MAX_NODE_BYTES</a>&nbsp;&nbsp;&nbsp;(8U&lt;&lt;20)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a3941e519b8496aa7693b48f471f85b2c">MSG</a>(fmt,...)&nbsp;&nbsp;&nbsp;if (outfp != NULL) fprintf(outfp, fmt &quot;\n&quot;, __VA_ARGS__)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a095d757dfba56d75beb9f7a750df27f9">ccn_btree_update_cached_parent</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__internal__payload.html">ccn_btree_internal_payload</a> *olink, <a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a> parentid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">BTree implementation.  <a href="#a095d757dfba56d75beb9f7a750df27f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#aab31ae32858e3cca2559fc2ab36480da">ccn_btree_fetchval</a> (const unsigned char *p, int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a21d4909338c9f22738daca415c2bf89e">ccn_btree_storeval</a> (unsigned char *p, int size, unsigned v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <br class="typebreak"/>
<a class="el" href="structccn__btree__entry__trailer.html">ccn_btree_entry_trailer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a24fff72cad03ef78384980fc24d11cf9">seek_trailer</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the entry trailer associated with entry i of the btree node.  <a href="#a24fff72cad03ef78384980fc24d11cf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a12c112fedde6f330541a5894cf3a345c">ccn_btree_node_getentry</a> (size_t payload_bytes, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the address of the indexed entry within the node.  <a href="#a12c112fedde6f330541a5894cf3a345c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <br class="typebreak"/>
<a class="el" href="structccn__btree__internal__payload.html">ccn_btree_internal_payload</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#ad6315f3bf760aedf8208b7d7150e8397">ccn_btree_node_internal_entry</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the address of entry within an internal (non-leaf) node.  <a href="#ad6315f3bf760aedf8208b7d7150e8397"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a53f0208267d2b7670b87da0d125cc793">ccn_btree_node_nent</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of entries within the btree node.  <a href="#a53f0208267d2b7670b87da0d125cc793"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a3810b46c06c6c009dd65e100ba3aeb89">ccn_btree_node_getentrysize</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size, in bytes, of entries within the node.  <a href="#a3810b46c06c6c009dd65e100ba3aeb89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a91cc11d6d11d050e53dc3d314eef4fe3">ccn_btree_node_payloadsize</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size, in bytes, of payloads within the node.  <a href="#a91cc11d6d11d050e53dc3d314eef4fe3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a964ab008628d589088d51a77c172fcc0">ccn_btree_node_level</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Node level (leaves are at level 0).  <a href="#a964ab008628d589088d51a77c172fcc0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#ad478f017de60f13b836c49bf80da0bf7">ccn_btree_key_fetch</a> (struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *dst, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fetch the key within the indexed entry of node.  <a href="#ad478f017de60f13b836c49bf80da0bf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#adbbf114a7a7ab71685ab9f7ef7d4a3e6">ccn_btree_key_append</a> (struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *dst, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the key within the indexed entry of node to dst.  <a href="#adbbf114a7a7ab71685ab9f7ef7d4a3e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a16d8c91d021ee1b50cd683dc7d4d53a9">ccn_btree_compare</a> (const unsigned char *key, size_t size, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare given key with the key in the indexed entry of the node.  <a href="#a16d8c91d021ee1b50cd683dc7d4d53a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a962030880972eb33cffa68a8dcc7a67e">ccn_btree_searchnode</a> (const unsigned char *key, size_t size, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search the node for the given key.  <a href="#a962030880972eb33cffa68a8dcc7a67e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#ac7c8275b9cf7e77bd98e783bcaad3bb4">ccn_btree_lookup</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, const unsigned char *key, size_t size, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **leafp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do a btree lookup, starting from the default root.  <a href="#ac7c8275b9cf7e77bd98e783bcaad3bb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#ab09151e71d638467fdf8c5a21d659ca8">ccn_btree_lookup_internal</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *root, int stoplevel, const unsigned char *key, size_t size, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **ansp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do a btree lookup, starting from the provided root and stopping at stoplevel.  <a href="#ab09151e71d638467fdf8c5a21d659ca8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#af67ad340602d722550b0c10241468893">ccn_btree_smallest_key_under</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *result)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extracts the smallest key under the node.  <a href="#af67ad340602d722550b0c10241468893"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#adc379693dbbfc9b64d4d5c074b0524c9">scan_reusable</a> (const unsigned char *key, size_t keysize, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int ndx, unsigned reuse[2])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a4e37f446a434a87cbb9543e4255938ec">ccn_btree_insert_entry</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i, const unsigned char *key, size_t keysize, void *payload, size_t payload_bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a new entry into a node.  <a href="#a4e37f446a434a87cbb9543e4255938ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a76dee0722b2c356763f9a1e58e8b0762">ccn_btree_delete_entry</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove an entry from a btree node.  <a href="#a76dee0722b2c356763f9a1e58e8b0762"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#afa6193af580387d8138953e4d657ec8e">ccn_btree_grow_a_level</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an old root, add a level to the tree to prepare for a split.  <a href="#afa6193af580387d8138953e4d657ec8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a8880c594c74592444299ea1ea39c0697">ccn_btree_shrink_a_level</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the root is a singleton and not a leaf, remove a level.  <a href="#a8880c594c74592444299ea1ea39c0697"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a0d606bd6911b6d69aa8560d6e4af5fc5">ccn_btree_oversize</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for an oversize node.  <a href="#a0d606bd6911b6d69aa8560d6e4af5fc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a171342df16ccfe550df84f3b74d35ae9">ccn_btree_unbalance</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for an unbalanced node.  <a href="#a171342df16ccfe550df84f3b74d35ae9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a881bc0f4b86daa2a7a0291382f4865de">ccn_btree_split</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Split a btree node.  <a href="#a881bc0f4b86daa2a7a0291382f4865de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a1660ef8caf7bdd794d775b235647815d">ccn_btree_index_in_parent</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *parent, <a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a> nodeid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search for nodeid in parent.  <a href="#a1660ef8caf7bdd794d775b235647815d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a7293cf11a568723bda92cb5cd61caa41">ccn_btree_spill</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Eliminate a node by combining it with a sibling.  <a href="#a7293cf11a568723bda92cb5cd61caa41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a920dcb30f9b5ce208c144d2eec63bd78">ccn_btree_next_leaf</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **ansp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the leaf that comes after the given node.  <a href="#a920dcb30f9b5ce208c144d2eec63bd78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a746c4c3b7a0431c3353b79aff534d2e8">ccn_btree_prev_leaf</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **ansp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the leaf that comes before the given node.  <a href="#a746c4c3b7a0431c3353b79aff534d2e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a101a77d88dfcd78834bcb18afb2726b9">ccn_btree_close_node</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write out any pending changes, mark the node clean, and release node iodata.  <a href="#a101a77d88dfcd78834bcb18afb2726b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a38f1cb699b65df3017ed8688a8679671">finalize_node</a> (struct <a class="el" href="structhashtb__enumerator.html">hashtb_enumerator</a> *e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a1545710226fd52d5add9693d8e5d94bb">ccn_btree_note_error</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *bt, int info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keep count of noticed errors.  <a href="#a1545710226fd52d5add9693d8e5d94bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#aaab88f1077912aeeb0eec02181dfa303">ccn_btree_create</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new btree handle, not attached to any external files.  <a href="#aaab88f1077912aeeb0eec02181dfa303"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a9f0a62b6bb5f2ad3d9c12869b5b83de6">ccn_btree_destroy</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> **pbt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys a btree handle, shutting things down cleanly.  <a href="#a9f0a62b6bb5f2ad3d9c12869b5b83de6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#aba692270580d406f7f881d5d40cfdf8a">ccn_btree_init_node</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node, int level, unsigned char nodetype, unsigned char extsz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the btree node.  <a href="#aba692270580d406f7f881d5d40cfdf8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#a1d338dc49af6a334450d5ea747b30f7b">ccn_btree_getnode</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *bt, <a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a> nodeid, <a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a> parentid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a btree node, creating or reading it if necessary.  <a href="#a1d338dc49af6a334450d5ea747b30f7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#ab6f6b815d73dcd1ba2f3c06e8909aa90">ccn_btree_rnode</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *bt, <a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a> nodeid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access a btree node that is already resident.  <a href="#ab6f6b815d73dcd1ba2f3c06e8909aa90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#af338eb7f9360355c0aa0f6745247aa27">ccn_btree_chknode</a> (struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check a node for internal consistency.  <a href="#af338eb7f9360355c0aa0f6745247aa27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#aa2e6c5c102528fc84744dec2a10f08e1">ccn_btree_prepare_for_update</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *bt, struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get ready to update a btree node.  <a href="#aa2e6c5c102528fc84744dec2a10f08e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#aa9dca30899859909dea0b97013005b38">compare_lexical</a> (struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *a, struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#ae0a20bb7dbca3ab435aaae36ad64b122">ccn_charbuf_append_escaped</a> (struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *dst, struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccn__btree_8c.html#ac518380f0561d0852cd9ba6ebaee2811">ccn_btree_check</a> (struct <a class="el" href="structccn__btree.html">ccn_btree</a> *btree, FILE *outfp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check the structure of the btree for consistency.  <a href="#ac518380f0561d0852cd9ba6ebaee2811"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a4b03a76e6dd793e27c7719e7c405001b"></a><!-- doxytag: member="ccn_btree.c::CCN_BTREE_MAGIC" ref="a4b03a76e6dd793e27c7719e7c405001b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BTREE_MAGIC&nbsp;&nbsp;&nbsp;0x53ade78</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01210">1210</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01450">ccn_btree_chknode()</a>, <a class="el" href="ccn__btree_8c_source.html#l01273">ccn_btree_create()</a>, <a class="el" href="ccn__btree_8c_source.html#l01301">ccn_btree_destroy()</a>, <a class="el" href="ccn__btree_8c_source.html#l01368">ccn_btree_getnode()</a>, <a class="el" href="ccn__btree_8c_source.html#l01331">ccn_btree_init_node()</a>, and <a class="el" href="ccn__btree_8c_source.html#l01246">finalize_node()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb23fa33594902c3f3525754e59ba0b8"></a><!-- doxytag: member="ccn_btree.c::CCN_BTREE_MAX_NODE_BYTES" ref="aeb23fa33594902c3f3525754e59ba0b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BTREE_MAX_NODE_BYTES&nbsp;&nbsp;&nbsp;(8U&lt;&lt;20)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01356">1356</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01368">ccn_btree_getnode()</a>.</p>

</div>
</div>
<a class="anchor" id="a3021842f9b9b491d3e2e9a37d97fc336"></a><!-- doxytag: member="ccn_btree.c::CCN_BTREE_VERSION" ref="a3021842f9b9b491d3e2e9a37d97fc336" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CCN_BTREE_VERSION&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01211">1211</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01450">ccn_btree_chknode()</a>, and <a class="el" href="ccn__btree_8c_source.html#l01331">ccn_btree_init_node()</a>.</p>

</div>
</div>
<a class="anchor" id="ab47360d2d6dfd1c3205f7d409e17efcf"></a><!-- doxytag: member="ccn_btree.c::MIN_NODE_BYTES" ref="ab47360d2d6dfd1c3205f7d409e17efcf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN_NODE_BYTES&nbsp;&nbsp;&nbsp;(sizeof(struct <a class="el" href="structccn__btree__node__header.html">ccn_btree_node_header</a>) + sizeof(struct <a class="el" href="structccn__btree__entry__trailer.html">ccn_btree_entry_trailer</a>))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Minimum size of a non-empty node. </p>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00065">65</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00166">ccn_btree_node_getentrysize()</a>, <a class="el" href="ccn__btree_8c_source.html#l00144">ccn_btree_node_nent()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00074">seek_trailer()</a>.</p>

</div>
</div>
<a class="anchor" id="a3941e519b8496aa7693b48f471f85b2c"></a><!-- doxytag: member="ccn_btree.c::MSG" ref="a3941e519b8496aa7693b48f471f85b2c" args="(fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG</td>
          <td>(</td>
          <td class="paramtype">fmt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;if (outfp != NULL) fprintf(outfp, fmt &quot;\n&quot;, __VA_ARGS__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01588">1588</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3941e519b8496aa7693b48f471f85b2c"></a><!-- doxytag: member="ccn_btree.c::MSG" ref="a3941e519b8496aa7693b48f471f85b2c" args="(fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG</td>
          <td>(</td>
          <td class="paramtype">fmt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((void)0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01588">1588</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00797">ccn_btree_update_cached_parent()</a>.</p>

</div>
</div>
<a class="anchor" id="a79754b043e1074fdff84e2b9b49d16bd"></a><!-- doxytag: member="ccn_btree.c::MYFETCH" ref="a79754b043e1074fdff84e2b9b49d16bd" args="(p, f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MYFETCH</td>
          <td>(</td>
          <td class="paramtype">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;ccn_btree_fetchval(&amp;((p)-&gt;f[0]), sizeof((p)-&gt;f))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00037">37</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l01450">ccn_btree_chknode()</a>, <a class="el" href="ccn__btree_8c_source.html#l00271">ccn_btree_compare()</a>, <a class="el" href="ccn__btree__content_8c_source.html#l00266">ccn_btree_content_cobsz()</a>, <a class="el" href="ccn__btree_8c_source.html#l00598">ccn_btree_delete_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00970">ccn_btree_index_in_parent()</a>, <a class="el" href="ccn__btree_8c_source.html#l00231">ccn_btree_key_append()</a>, <a class="el" href="ccn__btree_8c_source.html#l00395">ccn_btree_lookup_internal()</a>, <a class="el" href="ccn__btree__content_8c_source.html#l00143">ccn_btree_match_interest()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00108">ccn_btree_node_getentry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00166">ccn_btree_node_getentrysize()</a>, <a class="el" href="ccn__btree_8c_source.html#l00126">ccn_btree_node_internal_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00203">ccn_btree_node_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00144">ccn_btree_node_nent()</a>, <a class="el" href="ccn__btree_8c_source.html#l01168">ccn_btree_prev_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccn__btree_8c_source.html#l00797">ccn_btree_update_cached_parent()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00074">seek_trailer()</a>.</p>

</div>
</div>
<a class="anchor" id="a6092c6d641e9abf62ba79fbdbb580635"></a><!-- doxytag: member="ccn_btree.c::MYSTORE" ref="a6092c6d641e9abf62ba79fbdbb580635" args="(p, f, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MYSTORE</td>
          <td>(</td>
          <td class="paramtype">p, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">v&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;ccn_btree_storeval(&amp;((p)-&gt;f[0]), sizeof((p)-&gt;f), (v))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00051">51</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00598">ccn_btree_delete_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l01331">ccn_btree_init_node()</a>, <a class="el" href="ccn__btree__content_8c_source.html#l00076">ccn_btree_insert_content()</a>, <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac518380f0561d0852cd9ba6ebaee2811"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_check" ref="ac518380f0561d0852cd9ba6ebaee2811" args="(struct ccn_btree *btree, FILE *outfp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_check </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>outfp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check the structure of the btree for consistency. </p>
<p>If outfp is not NULL, information about structure will be written. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 if an error was found. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01597">1597</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l00487">r_store_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00450">test_btree_lookup()</a>.</p>

</div>
</div>
<a class="anchor" id="af338eb7f9360355c0aa0f6745247aa27"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_chknode" ref="af338eb7f9360355c0aa0f6745247aa27" args="(struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_chknode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check a node for internal consistency. </p>
<p>Sets or clears node-&gt;corrupt as appropriate. In case of success, sets the correct value for node-&gt;freelow</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>old value of node-&gt;corrupt if the node looks OK, otherwise -1 </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01450">1450</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l01368">ccn_btree_getnode()</a>, <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l01537">ccn_btree_prepare_for_update()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00421">example_btree_small()</a>, <a class="el" href="ccnr__store_8c_source.html#l01527">r_store_index_cleaner()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00555">test_basic_btree_delete_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00492">test_basic_btree_insert_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00242">test_btree_chknode()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00875">test_insert_content()</a>.</p>

</div>
</div>
<a class="anchor" id="a101a77d88dfcd78834bcb18afb2726b9"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_close_node" ref="a101a77d88dfcd78834bcb18afb2726b9" args="(struct ccn_btree *btree, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_close_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write out any pending changes, mark the node clean, and release node iodata. </p>
<p>Retains the cached node data in memory.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success or -1 for error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01221">1221</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l01246">finalize_node()</a>, and <a class="el" href="ccnr__store_8c_source.html#l01527">r_store_index_cleaner()</a>.</p>

</div>
</div>
<a class="anchor" id="a16d8c91d021ee1b50cd683dc7d4d53a9"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_compare" ref="a16d8c91d021ee1b50cd683dc7d4d53a9" args="(const unsigned char *key, size_t size, struct ccn_btree_node *node, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_compare </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare given key with the key in the indexed entry of the node. </p>
<p>The comparison is a standard lexicographic one on unsigned bytes; that is, there is no assumption of what the bytes actually encode.</p>
<p>The special return value -9999 indicates the key is a strict prefix. This does not matter to the btree lookup, but is useful for higher levels.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>negative, zero, or positive to indicate less, equal, or greater </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00271">271</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l00332">ccn_btree_searchnode()</a>, <a class="el" href="ccnr__store_8c_source.html#l00928">r_store_lookup_backwards()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00318">test_btree_compare()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00805">testhelp_count_matches()</a>.</p>

</div>
</div>
<a class="anchor" id="aaab88f1077912aeeb0eec02181dfa303"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_create" ref="aaab88f1077912aeeb0eec02181dfa303" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structccn__btree.html">ccn_btree</a>* ccn_btree_create </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new btree handle, not attached to any external files. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>new handle, or NULL in case of error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01273">1273</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnbtreetest_8c_source.html#l00421">example_btree_small()</a>, <a class="el" href="ccnr__store_8c_source.html#l00487">r_store_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00394">test_btree_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00875">test_insert_content()</a>.</p>

</div>
</div>
<a class="anchor" id="a76dee0722b2c356763f9a1e58e8b0762"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_delete_entry" ref="a76dee0722b2c356763f9a1e58e8b0762" args="(struct ccn_btree_node *node, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_delete_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove an entry from a btree node. </p>
<p>The caller is responsible for triggering a merge.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the new entry count, or -1 in case of error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00598">598</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00555">test_basic_btree_delete_entry()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f0a62b6bb5f2ad3d9c12869b5b83de6"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_destroy" ref="a9f0a62b6bb5f2ad3d9c12869b5b83de6" args="(struct ccn_btree **pbt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> **&nbsp;</td>
          <td class="paramname"> <em>pbt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroys a btree handle, shutting things down cleanly. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a negative value in case of error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01301">1301</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l00605">r_store_final()</a>, <a class="el" href="ccnr__store_8c_source.html#l00487">r_store_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00555">test_basic_btree_delete_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00492">test_basic_btree_insert_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00394">test_btree_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00450">test_btree_lookup()</a>.</p>

</div>
</div>
<a class="anchor" id="aab31ae32858e3cca2559fc2ab36480da"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_fetchval" ref="aab31ae32858e3cca2559fc2ab36480da" args="(const unsigned char *p, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ccn_btree_fetchval </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00040">40</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

</div>
</div>
<a class="anchor" id="a1d338dc49af6a334450d5ea747b30f7b"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_getnode" ref="a1d338dc49af6a334450d5ea747b30f7b" args="(struct ccn_btree *bt, ccn_btnodeid nodeid, ccn_btnodeid parentid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a>* ccn_btree_getnode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>bt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a>&nbsp;</td>
          <td class="paramname"> <em>nodeid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a>&nbsp;</td>
          <td class="paramname"> <em>parentid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access a btree node, creating or reading it if necessary. </p>
<p>Care should be taken to not store the node handle in data structures, since it will become invalid when the node gets flushed from the resident cache.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>node handle </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01368">1368</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00371">ccn_btree_lookup()</a>, <a class="el" href="ccn__btree_8c_source.html#l00395">ccn_btree_lookup_internal()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l01168">ccn_btree_prev_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00421">example_btree_small()</a>, <a class="el" href="ccnr__store_8c_source.html#l00706">r_store_content_btree_insert()</a>, <a class="el" href="ccnr__store_8c_source.html#l00487">r_store_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00394">test_btree_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00875">test_insert_content()</a>.</p>

</div>
</div>
<a class="anchor" id="afa6193af580387d8138953e4d657ec8e"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_grow_a_level" ref="afa6193af580387d8138953e4d657ec8e" args="(struct ccn_btree *btree, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a>* ccn_btree_grow_a_level </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an old root, add a level to the tree to prepare for a split. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>node with a new nodeid, new singleton root, and the old contents. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00649">649</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>.</p>

</div>
</div>
<a class="anchor" id="a1660ef8caf7bdd794d775b235647815d"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_index_in_parent" ref="a1660ef8caf7bdd794d775b235647815d" args="(struct ccn_btree_node *parent, ccn_btnodeid nodeid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_index_in_parent </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a>&nbsp;</td>
          <td class="paramname"> <em>nodeid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search for nodeid in parent. </p>
<p>This does not rely on the keys, but just scans the entries.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index within parent, or -1 if there is an error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00970">970</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01168">ccn_btree_prev_leaf()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>.</p>

</div>
</div>
<a class="anchor" id="aba692270580d406f7f881d5d40cfdf8a"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_init_node" ref="aba692270580d406f7f881d5d40cfdf8a" args="(struct ccn_btree_node *node, int level, unsigned char nodetype, unsigned char extsz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_init_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>nodetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>extsz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the btree node. </p>
<p>It is the caller's responsibility to be sure that the node does not contain any useful information.</p>
<p>Leaves alone nodeid, iodata, and activity fields.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 for error, 0 for success </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01331">1331</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnr__store_8c_source.html#l00487">r_store_init()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00875">test_insert_content()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e37f446a434a87cbb9543e4255938ec"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_insert_entry" ref="a4e37f446a434a87cbb9543e4255938ec" args="(struct ccn_btree_node *node, int i, const unsigned char *key, size_t keysize, void *payload, size_t payload_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_insert_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>keysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>payload_bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert a new entry into a node. </p>
<p>The caller is responsible for providing the correct index i, which will become the index of the new entry.</p>
<p>The caller is also responsible for triggering a split.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the new entry count, or -1 in case of error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00491">491</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree__content_8c_source.html#l00076">ccn_btree_insert_content()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00492">test_basic_btree_insert_entry()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="adbbf114a7a7ab71685ab9f7ef7d4a3e6"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_key_append" ref="adbbf114a7a7ab71685ab9f7ef7d4a3e6" args="(struct ccn_charbuf *dst, struct ccn_btree_node *node, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_key_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append the key within the indexed entry of node to dst. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 in case of error </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00231">231</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00218">ccn_btree_key_fetch()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00268">test_btree_key_fetch()</a>.</p>

</div>
</div>
<a class="anchor" id="ad478f017de60f13b836c49bf80da0bf7"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_key_fetch" ref="ad478f017de60f13b836c49bf80da0bf7" args="(struct ccn_charbuf *dst, struct ccn_btree_node *node, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_key_fetch </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fetch the key within the indexed entry of node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 in case of error </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00218">218</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree__content_8c_source.html#l00143">ccn_btree_match_interest()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00452">ccn_btree_smallest_key_under()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnr__store_8c_source.html#l00810">r_store_look()</a>, <a class="el" href="ccnr__store_8c_source.html#l00928">r_store_lookup_backwards()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00268">test_btree_key_fetch()</a>.</p>

</div>
</div>
<a class="anchor" id="ac7c8275b9cf7e77bd98e783bcaad3bb4"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_lookup" ref="ac7c8275b9cf7e77bd98e783bcaad3bb4" args="(struct ccn_btree *btree, const unsigned char *key, size_t size, struct ccn_btree_node **leafp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_lookup </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **&nbsp;</td>
          <td class="paramname"> <em>leafp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do a btree lookup, starting from the default root. </p>
<p>In the absence of errors, if *leafp is not NULL the handle for the appropriate leaf node will be stored. See <a class="el" href="btree_8h.html#a1d338dc49af6a334450d5ea747b30f7b" title="Access a btree node, creating or reading it if necessary.">ccn_btree_getnode()</a> for warning about lifetime of the resulting pointer.</p>
<p>The return value is encoded as for <a class="el" href="btree_8h.html#a962030880972eb33cffa68a8dcc7a67e" title="Search the node for the given key.">ccn_btree_searchnode()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="btree_8h.html#ae049b8a0f5ba72ef645c77996e1e3dbf">CCN_BT_ENCRES(index, success)</a> indication, or -1 for an error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00371">371</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l00706">r_store_content_btree_insert()</a>, <a class="el" href="ccnr__store_8c_source.html#l00810">r_store_look()</a>, <a class="el" href="ccnr__store_8c_source.html#l01095">r_store_lookup()</a>, <a class="el" href="ccnr__store_8c_source.html#l00928">r_store_lookup_backwards()</a>, <a class="el" href="ccnr__store_8c_source.html#l01413">r_store_set_accession_from_offset()</a>, <a class="el" href="ccnr__sync_8c_source.html#l00221">r_sync_enumerate_action()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00555">test_basic_btree_delete_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00492">test_basic_btree_insert_entry()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00450">test_btree_lookup()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00875">test_insert_content()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00805">testhelp_count_matches()</a>.</p>

</div>
</div>
<a class="anchor" id="ab09151e71d638467fdf8c5a21d659ca8"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_lookup_internal" ref="ab09151e71d638467fdf8c5a21d659ca8" args="(struct ccn_btree *btree, struct ccn_btree_node *root, int stoplevel, const unsigned char *key, size_t size, struct ccn_btree_node **ansp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_lookup_internal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stoplevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **&nbsp;</td>
          <td class="paramname"> <em>ansp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Do a btree lookup, starting from the provided root and stopping at stoplevel. </p>
<p>In the absence of errors, if *ansp is not NULL the handle for the appropriate node will be stored. See <a class="el" href="btree_8h.html#a1d338dc49af6a334450d5ea747b30f7b" title="Access a btree node, creating or reading it if necessary.">ccn_btree_getnode()</a> for warning about lifetime of the resulting pointer.</p>
<p>The return value is encoded as for <a class="el" href="btree_8h.html#a962030880972eb33cffa68a8dcc7a67e" title="Search the node for the given key.">ccn_btree_searchnode()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="btree_8h.html#ae049b8a0f5ba72ef645c77996e1e3dbf">CCN_BT_ENCRES(index, success)</a> indication, or -1 for an error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00395">395</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00371">ccn_btree_lookup()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00452">ccn_btree_smallest_key_under()</a>.</p>

</div>
</div>
<a class="anchor" id="a920dcb30f9b5ce208c144d2eec63bd78"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_next_leaf" ref="a920dcb30f9b5ce208c144d2eec63bd78" args="(struct ccn_btree *btree, struct ccn_btree_node *node, struct ccn_btree_node **ansp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_next_leaf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **&nbsp;</td>
          <td class="paramname"> <em>ansp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the leaf that comes after the given node. </p>
<p>This may be used to walk though the leaf nodes in order. If success, sets *ansp to a leaf pointer or NULL </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if at end, 1 if *ansp is not NULL, -1 if error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01101">1101</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l00810">r_store_look()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="a12c112fedde6f330541a5894cf3a345c"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_node_getentry" ref="a12c112fedde6f330541a5894cf3a345c" args="(size_t payload_bytes, struct ccn_btree_node *node, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ccn_btree_node_getentry </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>payload_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the address of the indexed entry within the node. </p>
<p>payload_bytes must be divisible by CCN_BT_SIZE_UNITS.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL in case of error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00108">108</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree__content_8c_source.html#l00227">ccn_btree_content_cobid()</a>, <a class="el" href="ccn__btree__content_8c_source.html#l00266">ccn_btree_content_cobsz()</a>, <a class="el" href="ccn__btree__content_8c_source.html#l00244">ccn_btree_content_set_cobid()</a>, <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>, <a class="el" href="ccn__btree__content_8c_source.html#l00143">ccn_btree_match_interest()</a>, <a class="el" href="ccn__btree_8c_source.html#l00126">ccn_btree_node_internal_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>.</p>

</div>
</div>
<a class="anchor" id="a3810b46c06c6c009dd65e100ba3aeb89"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_node_getentrysize" ref="a3810b46c06c6c009dd65e100ba3aeb89" args="(struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_node_getentrysize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size, in bytes, of entries within the node. </p>
<p>If there are no entries, returns 0. This size includes the entry trailer.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size, or -1 for error </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00166">166</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00598">ccn_btree_delete_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00189">ccn_btree_node_payloadsize()</a>.</p>

</div>
</div>
<a class="anchor" id="ad6315f3bf760aedf8208b7d7150e8397"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_node_internal_entry" ref="ad6315f3bf760aedf8208b7d7150e8397" args="(struct ccn_btree_node *node, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structccn__btree__internal__payload.html">ccn_btree_internal_payload</a>* ccn_btree_node_internal_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the address of entry within an internal (non-leaf) node. </p>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00126">126</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l00970">ccn_btree_index_in_parent()</a>, <a class="el" href="ccn__btree_8c_source.html#l00395">ccn_btree_lookup_internal()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l01168">ccn_btree_prev_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>.</p>

</div>
</div>
<a class="anchor" id="a964ab008628d589088d51a77c172fcc0"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_node_level" ref="a964ab008628d589088d51a77c172fcc0" args="(struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_node_level </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Node level (leaves are at level 0). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the node level, or -1 for error </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00203">203</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00395">ccn_btree_lookup_internal()</a>, <a class="el" href="ccn__btree_8c_source.html#l01168">ccn_btree_prev_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccn__btree_8c_source.html#l00773">ccn_btree_unbalance()</a>, <a class="el" href="ccn__btree_8c_source.html#l00470">scan_reusable()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00450">test_btree_lookup()</a>.</p>

</div>
</div>
<a class="anchor" id="a53f0208267d2b7670b87da0d125cc793"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_node_nent" ref="a53f0208267d2b7670b87da0d125cc793" args="(struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_node_nent </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of entries within the btree node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of entries, or -1 for error </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00144">144</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l01450">ccn_btree_chknode()</a>, <a class="el" href="ccn__btree_8c_source.html#l00598">ccn_btree_delete_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l00970">ccn_btree_index_in_parent()</a>, <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l01168">ccn_btree_prev_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00332">ccn_btree_searchnode()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccn__btree_8c_source.html#l00773">ccn_btree_unbalance()</a>, <a class="el" href="ccnr__store_8c_source.html#l00810">r_store_look()</a>, <a class="el" href="ccnr__store_8c_source.html#l00928">r_store_lookup_backwards()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00348">test_btree_searchnode()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00805">testhelp_count_matches()</a>.</p>

</div>
</div>
<a class="anchor" id="a91cc11d6d11d050e53dc3d314eef4fe3"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_node_payloadsize" ref="a91cc11d6d11d050e53dc3d314eef4fe3" args="(struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_node_payloadsize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Size, in bytes, of payloads within the node. </p>
<p>If there are no entries, returns 0. This does not include the entry trailer, but will include padding to a multiple of CCN_BT_SIZE_UNITS.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size, or -1 for error </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00189">189</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>.</p>

</div>
</div>
<a class="anchor" id="a1545710226fd52d5add9693d8e5d94bb"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_note_error" ref="a1545710226fd52d5add9693d8e5d94bb" args="(struct ccn_btree *bt, int info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccn_btree_note_error </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>bt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Keep count of noticed errors. </p>
<p>Do this in one place so it is easy to set a breakpoint. </p>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01263">1263</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>, <a class="el" href="ccn__btree_8c_source.html#l01221">ccn_btree_close_node()</a>, <a class="el" href="ccn__btree_8c_source.html#l01368">ccn_btree_getnode()</a>, <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00395">ccn_btree_lookup_internal()</a>, <a class="el" href="ccn__btree_8c_source.html#l01537">ccn_btree_prepare_for_update()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d606bd6911b6d69aa8560d6e4af5fc5"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_oversize" ref="a0d606bd6911b6d69aa8560d6e4af5fc5" args="(struct ccn_btree *btree, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_oversize </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for an oversize node. </p>
<p>This takes into account both the size of a node and the count of entries.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a boolean result. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00759">759</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, and <a class="el" href="ccnr__store_8c_source.html#l00706">r_store_content_btree_insert()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2e6c5c102528fc84744dec2a10f08e1"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_prepare_for_update" ref="aa2e6c5c102528fc84744dec2a10f08e1" args="(struct ccn_btree *bt, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_prepare_for_update </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>bt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get ready to update a btree node. </p>
<p>If applicable, open the node so that it will be in a good state to write later on.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if OK, -1 for error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01537">1537</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00649">ccn_btree_grow_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, <a class="el" href="ccnr__store_8c_source.html#l00706">r_store_content_btree_insert()</a>, and <a class="el" href="ccnr__store_8c_source.html#l01413">r_store_set_accession_from_offset()</a>.</p>

</div>
</div>
<a class="anchor" id="a746c4c3b7a0431c3353b79aff534d2e8"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_prev_leaf" ref="a746c4c3b7a0431c3353b79aff534d2e8" args="(struct ccn_btree *btree, struct ccn_btree_node *node, struct ccn_btree_node **ansp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_prev_leaf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> **&nbsp;</td>
          <td class="paramname"> <em>ansp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the leaf that comes before the given node. </p>
<p>This may be used to walk though the leaf nodes in reverse order. If success, sets *ansp to a leaf pointer or NULL </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if at beginning, 1 if *ansp is not NULL, -1 if error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01168">1168</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l00928">r_store_lookup_backwards()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="ab6f6b815d73dcd1ba2f3c06e8909aa90"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_rnode" ref="ab6f6b815d73dcd1ba2f3c06e8909aa90" args="(struct ccn_btree *bt, ccn_btnodeid nodeid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a>* ccn_btree_rnode </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>bt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a>&nbsp;</td>
          <td class="paramname"> <em>nodeid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access a btree node that is already resident. </p>
<p>Care should be taken to not store the node handle in data structures, since it will become invalid when the node gets flushed from the resident cache.</p>
<p>This call does not bump the activity counter.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>node handle, or NULL if the node is not currently resident. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01436">1436</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00797">ccn_btree_update_cached_parent()</a>, <a class="el" href="ccnr__store_8c_source.html#l01527">r_store_index_cleaner()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00394">test_btree_init()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="a962030880972eb33cffa68a8dcc7a67e"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_searchnode" ref="a962030880972eb33cffa68a8dcc7a67e" args="(const unsigned char *key, size_t size, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_searchnode </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search the node for the given key. </p>
<p>The return value is encoded as 2 * index + (found ? 1 : 0); that is, a successful search returns an odd number and an unsuccessful search returns an even number. In the case of an unsuccessful search, the index indicates where the item would go if it were to be inserted.</p>
<p>Uses a binary search, so the keys in the node must be sorted and unique.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="btree_8h.html#ae049b8a0f5ba72ef645c77996e1e3dbf">CCN_BT_ENCRES(index, success)</a> indication, or -1 for an error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00332">332</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00395">ccn_btree_lookup_internal()</a>, <a class="el" href="ccn__btree_8c_source.html#l01101">ccn_btree_next_leaf()</a>, <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00348">test_btree_searchnode()</a>.</p>

</div>
</div>
<a class="anchor" id="a8880c594c74592444299ea1ea39c0697"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_shrink_a_level" ref="a8880c594c74592444299ea1ea39c0697" args="(struct ccn_btree *btree)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ccn_btree_shrink_a_level </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the root is a singleton and not a leaf, remove a level. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if nothing done, 1 if the root changed, or -1 for error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00694">694</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>.</p>

</div>
</div>
<a class="anchor" id="af67ad340602d722550b0c10241468893"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_smallest_key_under" ref="af67ad340602d722550b0c10241468893" args="(struct ccn_btree *btree, struct ccn_btree_node *node, struct ccn_charbuf *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ccn_btree_smallest_key_under </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extracts the smallest key under the node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 for an error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00452">452</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>.</p>

</div>
</div>
<a class="anchor" id="a7293cf11a568723bda92cb5cd61caa41"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_spill" ref="a7293cf11a568723bda92cb5cd61caa41" args="(struct ccn_btree *btree, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_spill </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Eliminate a node by combining it with a sibling. </p>
<p>In success case, the node will be emptied out completely, and The parent node will have one fewer child. It is possible for a sibling to need splitting; in this case btree-&gt;nextsplit will be set accordingly.</p>
<p>btree-&gt;nextspill will be set if there are more nodes to spill.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success, 1 if deferred to left, -1 if error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00999">999</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="a881bc0f4b86daa2a7a0291382f4865de"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_split" ref="a881bc0f4b86daa2a7a0291382f4865de" args="(struct ccn_btree *btree, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_split </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Split a btree node. </p>
<p>This creates a new sibling, and distributes the entries of node between the two.</p>
<p>The node's parent gains a child; if in doing so, it grows too large, the parent will be noted in btree-&gt;nextsplit for the caller to deal with.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 for success, -1 in case of error. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00828">828</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccnr__store_8c_source.html#l00706">r_store_content_btree_insert()</a>, <a class="el" href="ccnbtreetest_8c_source.html#l00492">test_basic_btree_insert_entry()</a>, and <a class="el" href="ccnbtreetest_8c_source.html#l00593">test_btree_inserts_from_stdin()</a>.</p>

</div>
</div>
<a class="anchor" id="a21d4909338c9f22738daca415c2bf89e"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_storeval" ref="a21d4909338c9f22738daca415c2bf89e" args="(unsigned char *p, int size, unsigned v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ccn_btree_storeval </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00054">54</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

</div>
</div>
<a class="anchor" id="a171342df16ccfe550df84f3b74d35ae9"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_unbalance" ref="a171342df16ccfe550df84f3b74d35ae9" args="(struct ccn_btree *btree, struct ccn_btree_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ccn_btree_unbalance </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for an unbalanced node. </p>
<p>This takes into account both the size of a node and the count of entries.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if node is too big, -1 if too small, 0 if just right. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00773">773</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00759">ccn_btree_oversize()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>.</p>

</div>
</div>
<a class="anchor" id="a095d757dfba56d75beb9f7a750df27f9"></a><!-- doxytag: member="ccn_btree.c::ccn_btree_update_cached_parent" ref="a095d757dfba56d75beb9f7a750df27f9" args="(struct ccn_btree *btree, struct ccn_btree_internal_payload *olink, ccn_btnodeid parentid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ccn_btree_update_cached_parent </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree.html">ccn_btree</a> *&nbsp;</td>
          <td class="paramname"> <em>btree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__internal__payload.html">ccn_btree_internal_payload</a> *&nbsp;</td>
          <td class="paramname"> <em>olink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="btree_8h.html#aa302edee5118eed1881dac5108371a09">ccn_btnodeid</a>&nbsp;</td>
          <td class="paramname"> <em>parentid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>BTree implementation. </p>
<p>Update the cached parent pointer if necessary. </p>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00797">797</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00694">ccn_btree_shrink_a_level()</a>, <a class="el" href="ccn__btree_8c_source.html#l00999">ccn_btree_spill()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00828">ccn_btree_split()</a>.</p>

</div>
</div>
<a class="anchor" id="ae0a20bb7dbca3ab435aaae36ad64b122"></a><!-- doxytag: member="ccn_btree.c::ccn_charbuf_append_escaped" ref="ae0a20bb7dbca3ab435aaae36ad64b122" args="(struct ccn_charbuf *dst, struct ccn_charbuf *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void ccn_charbuf_append_escaped </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01572">1572</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9dca30899859909dea0b97013005b38"></a><!-- doxytag: member="ccn_btree.c::compare_lexical" ref="aa9dca30899859909dea0b97013005b38" args="(struct ccn_charbuf *a, struct ccn_charbuf *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int compare_lexical </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__charbuf.html">ccn_charbuf</a> *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01558">1558</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01597">ccn_btree_check()</a>.</p>

</div>
</div>
<a class="anchor" id="a38f1cb699b65df3017ed8688a8679671"></a><!-- doxytag: member="ccn_btree.c::finalize_node" ref="a38f1cb699b65df3017ed8688a8679671" args="(struct hashtb_enumerator *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void finalize_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structhashtb__enumerator.html">hashtb_enumerator</a> *&nbsp;</td>
          <td class="paramname"> <em>e</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l01246">1246</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01273">ccn_btree_create()</a>.</p>

</div>
</div>
<a class="anchor" id="adc379693dbbfc9b64d4d5c074b0524c9"></a><!-- doxytag: member="ccn_btree.c::scan_reusable" ref="adc379693dbbfc9b64d4d5c074b0524c9" args="(const unsigned char *key, size_t keysize, struct ccn_btree_node *node, int ndx, unsigned reuse[2])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void scan_reusable </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>keysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>reuse</em>[2]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00470">470</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l00491">ccn_btree_insert_entry()</a>.</p>

</div>
</div>
<a class="anchor" id="a24fff72cad03ef78384980fc24d11cf9"></a><!-- doxytag: member="ccn_btree.c::seek_trailer" ref="a24fff72cad03ef78384980fc24d11cf9" args="(struct ccn_btree_node *node, int i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structccn__btree__entry__trailer.html">ccn_btree_entry_trailer</a>* seek_trailer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structccn__btree__node.html">ccn_btree_node</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the entry trailer associated with entry i of the btree node. </p>
<p>Sets node-&gt;corrupt if a problem with the node's structure is discovered. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>entry trailer pointer, or NULL if there is a problem. </dd></dl>

<p>Definition at line <a class="el" href="ccn__btree_8c_source.html#l00074">74</a> of file <a class="el" href="ccn__btree_8c_source.html">ccn_btree.c</a>.</p>

<p>Referenced by <a class="el" href="ccn__btree_8c_source.html#l01450">ccn_btree_chknode()</a>, <a class="el" href="ccn__btree_8c_source.html#l00271">ccn_btree_compare()</a>, <a class="el" href="ccn__btree_8c_source.html#l00231">ccn_btree_key_append()</a>, and <a class="el" href="ccn__btree_8c_source.html#l00108">ccn_btree_node_getentry()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Feb 4 11:57:16 2013 for Content-Centric Networking in C by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

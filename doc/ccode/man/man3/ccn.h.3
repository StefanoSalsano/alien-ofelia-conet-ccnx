.TH "include/ccn/ccn.h" 3 "4 Feb 2013" "Version 0.7.1" "Content-Centric Networking in C" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/ccn/ccn.h \- 
.PP
This is the low-level interface for CCNx clients.  

.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBccn_closure\fP"
.br
.RI "\fIHandle for upcalls that allow clients receive notifications of incoming interests and content. \fP"
.ti -1c
.RI "struct \fBccn_upcall_info\fP"
.br
.RI "\fIAdditional information provided in the upcall. \fP"
.ti -1c
.RI "struct \fBccn_buf_decoder\fP"
.br
.ti -1c
.RI "struct \fBccn_parsed_interest\fP"
.br
.ti -1c
.RI "struct \fBccn_parsed_Link\fP"
.br
.ti -1c
.RI "struct \fBccn_parsed_ContentObject\fP"
.br
.ti -1c
.RI "struct \fBccn_signing_params\fP"
.br
.RI "\fIParameters for creating signed content objects. \fP"
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBCCN_API_VERSION\fP   7001"
.br
.RI "\fIA macro that clients may use to cope with an evolving API. \fP"
.ti -1c
.RI "#define \fBCCN_INTEREST_LIFETIME_SEC\fP   4"
.br
.RI "\fIInterest lifetime default. \fP"
.ti -1c
.RI "#define \fBCCN_INTEREST_LIFETIME_MICROSEC\fP   (CCN_INTEREST_LIFETIME_SEC * 1000000)"
.br
.ti -1c
.RI "#define \fBCCN_GET_NOKEYWAIT\fP   1"
.br
.ti -1c
.RI "#define \fBCCN_AOK_CS\fP   0x1"
.br
.ti -1c
.RI "#define \fBCCN_AOK_NEW\fP   0x2"
.br
.ti -1c
.RI "#define \fBCCN_AOK_DEFAULT\fP   (CCN_AOK_CS | CCN_AOK_NEW)"
.br
.ti -1c
.RI "#define \fBCCN_AOK_STALE\fP   0x4"
.br
.ti -1c
.RI "#define \fBCCN_AOK_EXPIRE\fP   0x10"
.br
.ti -1c
.RI "#define \fBCCN_SIGNING_PARAMS_INIT\fP   { CCN_API_VERSION, 0, NULL, {0}, CCN_CONTENT_DATA, -1 }"
.br
.ti -1c
.RI "#define \fBCCN_SP_TEMPL_TIMESTAMP\fP   0x0001"
.br
.ti -1c
.RI "#define \fBCCN_SP_TEMPL_FINAL_BLOCK_ID\fP   0x0002"
.br
.ti -1c
.RI "#define \fBCCN_SP_TEMPL_FRESHNESS\fP   0x0004"
.br
.ti -1c
.RI "#define \fBCCN_SP_TEMPL_KEY_LOCATOR\fP   0x0008"
.br
.ti -1c
.RI "#define \fBCCN_SP_FINAL_BLOCK\fP   0x0010"
.br
.ti -1c
.RI "#define \fBCCN_SP_OMIT_KEY_LOCATOR\fP   0x0020"
.br
.ti -1c
.RI "#define \fBCCN_SP_TEMPL_EXT_OPT\fP   0x0040"
.br
.ti -1c
.RI "#define \fBCCN_SIGNING_DEFAULT_DIGEST_ALGORITHM\fP   'SHA256'"
.br
.ti -1c
.RI "#define \fBCCN_V_REPLACE\fP   1"
.br
.RI "\fIVersioning. \fP"
.ti -1c
.RI "#define \fBCCN_V_LOW\fP   2"
.br
.RI "\fIlook for early version \fP"
.ti -1c
.RI "#define \fBCCN_V_HIGH\fP   4"
.br
.RI "\fIlook for newer version \fP"
.ti -1c
.RI "#define \fBCCN_V_EST\fP   8"
.br
.RI "\fIlook for extreme \fP"
.ti -1c
.RI "#define \fBCCN_V_LOWEST\fP   (2|8)"
.br
.ti -1c
.RI "#define \fBCCN_V_HIGHEST\fP   (4|8)"
.br
.ti -1c
.RI "#define \fBCCN_V_NEXT\fP   (4|1)"
.br
.ti -1c
.RI "#define \fBCCN_V_PREV\fP   (2|1)"
.br
.ti -1c
.RI "#define \fBCCN_V_NOW\fP   16"
.br
.RI "\fIuse current time \fP"
.ti -1c
.RI "#define \fBCCN_V_NESTOK\fP   32"
.br
.RI "\fIversion within version is ok \fP"
.ti -1c
.RI "#define \fBCCN_V_SCOPE0\fP   64"
.br
.RI "\fIuse scope 0 \fP"
.ti -1c
.RI "#define \fBCCN_V_SCOPE1\fP   128"
.br
.RI "\fIuse scope 1 \fP"
.ti -1c
.RI "#define \fBCCN_V_SCOPE2\fP   256"
.br
.RI "\fIuse scope 2 \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBccn_upcall_res\fP(* \fBccn_handler\fP )(struct \fBccn_closure\fP *selfp, enum \fBccn_upcall_kind\fP kind, struct \fBccn_upcall_info\fP *info)"
.br
.RI "\fIccn_handler This is the procedure type for the closure's implementation. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBccn_upcall_kind\fP { \fBCCN_UPCALL_FINAL\fP, \fBCCN_UPCALL_INTEREST\fP, \fBCCN_UPCALL_CONSUMED_INTEREST\fP, \fBCCN_UPCALL_CONTENT\fP, \fBCCN_UPCALL_INTEREST_TIMED_OUT\fP, \fBCCN_UPCALL_CONTENT_UNVERIFIED\fP, \fBCCN_UPCALL_CONTENT_BAD\fP, \fBCCN_UPCALL_CONTENT_KEYMISSING\fP, \fBCCN_UPCALL_CONTENT_RAW\fP }"
.br
.RI "\fIThis tells what kind of event the upcall is handling. \fP"
.ti -1c
.RI "enum \fBccn_upcall_res\fP { \fBCCN_UPCALL_RESULT_ERR\fP =  -1, \fBCCN_UPCALL_RESULT_OK\fP =  0, \fBCCN_UPCALL_RESULT_REEXPRESS\fP =  1, \fBCCN_UPCALL_RESULT_INTEREST_CONSUMED\fP =  2, \fBCCN_UPCALL_RESULT_VERIFY\fP =  3, \fBCCN_UPCALL_RESULT_FETCHKEY\fP =  4 }"
.br
.RI "\fIUpcalls return one of these values. \fP"
.ti -1c
.RI "enum \fBccn_marker\fP { \fBCCN_MARKER_NONE\fP =  -1, \fBCCN_MARKER_SEQNUM\fP =  0x00, \fBCCN_MARKER_CONTROL\fP =  0xC1, \fBCCN_MARKER_OSEQNUM\fP =  0xF8, \fBCCN_MARKER_BLKID\fP =  0xFB, \fBCCN_MARKER_VERSION\fP =  0xFD }"
.br
.ti -1c
.RI "enum \fBccn_content_type\fP { \fBCCN_CONTENT_DATA\fP =  0x0C04C0, \fBCCN_CONTENT_ENCR\fP =  0x10D091, \fBCCN_CONTENT_GONE\fP =  0x18E344, \fBCCN_CONTENT_KEY\fP =  0x28463F, \fBCCN_CONTENT_LINK\fP =  0x2C834A, \fBCCN_CONTENT_NACK\fP =  0x34008A }"
.br
.ti -1c
.RI "enum \fBccn_parsed_interest_offsetid\fP { \fBCCN_PI_B_Name\fP, \fBCCN_PI_B_Component0\fP, \fBCCN_PI_B_LastPrefixComponent\fP, \fBCCN_PI_E_LastPrefixComponent\fP, \fBCCN_PI_E_ComponentLast\fP =  CCN_PI_E_LastPrefixComponent, \fBCCN_PI_E_Name\fP, \fBCCN_PI_B_MinSuffixComponents\fP, \fBCCN_PI_E_MinSuffixComponents\fP, \fBCCN_PI_B_MaxSuffixComponents\fP, \fBCCN_PI_E_MaxSuffixComponents\fP, \fBCCN_PI_B_PublisherID\fP, \fBCCN_PI_B_PublisherIDKeyDigest\fP, \fBCCN_PI_E_PublisherIDKeyDigest\fP, \fBCCN_PI_E_PublisherID\fP, \fBCCN_PI_B_Exclude\fP, \fBCCN_PI_E_Exclude\fP, \fBCCN_PI_B_ChildSelector\fP, \fBCCN_PI_E_ChildSelector\fP, \fBCCN_PI_B_AnswerOriginKind\fP, \fBCCN_PI_E_AnswerOriginKind\fP, \fBCCN_PI_B_Scope\fP, \fBCCN_PI_E_Scope\fP, \fBCCN_PI_B_InterestLifetime\fP, \fBCCN_PI_E_InterestLifetime\fP, \fBCCN_PI_B_Nonce\fP, \fBCCN_PI_E_Nonce\fP, \fBCCN_PI_B_OTHER\fP, \fBCCN_PI_E_OTHER\fP, \fBCCN_PI_E\fP }"
.br
.ti -1c
.RI "enum \fBccn_parsed_Link_offsetid\fP { \fBCCN_PL_B_Name\fP, \fBCCN_PL_B_Component0\fP, \fBCCN_PL_E_ComponentLast\fP, \fBCCN_PL_E_Name\fP, \fBCCN_PL_B_Label\fP, \fBCCN_PL_E_Label\fP, \fBCCN_PL_B_LinkAuthenticator\fP, \fBCCN_PL_B_PublisherID\fP, \fBCCN_PL_B_PublisherDigest\fP, \fBCCN_PL_E_PublisherDigest\fP, \fBCCN_PL_E_PublisherID\fP, \fBCCN_PL_B_NameComponentCount\fP, \fBCCN_PL_E_NameComponentCount\fP, \fBCCN_PL_B_Timestamp\fP, \fBCCN_PL_E_Timestamp\fP, \fBCCN_PL_B_Type\fP, \fBCCN_PL_E_Type\fP, \fBCCN_PL_B_ContentDigest\fP, \fBCCN_PL_E_ContentDigest\fP, \fBCCN_PL_E_LinkAuthenticator\fP, \fBCCN_PL_E\fP }"
.br
.ti -1c
.RI "enum \fBccn_parsed_content_object_offsetid\fP { \fBCCN_PCO_B_Signature\fP, \fBCCN_PCO_B_DigestAlgorithm\fP, \fBCCN_PCO_E_DigestAlgorithm\fP, \fBCCN_PCO_B_Witness\fP, \fBCCN_PCO_E_Witness\fP, \fBCCN_PCO_B_SignatureBits\fP, \fBCCN_PCO_E_SignatureBits\fP, \fBCCN_PCO_E_Signature\fP, \fBCCN_PCO_B_Name\fP, \fBCCN_PCO_B_Component0\fP, \fBCCN_PCO_E_ComponentN\fP, \fBCCN_PCO_E_ComponentLast\fP =  CCN_PCO_E_ComponentN, \fBCCN_PCO_E_Name\fP, \fBCCN_PCO_B_SignedInfo\fP, \fBCCN_PCO_B_PublisherPublicKeyDigest\fP, \fBCCN_PCO_E_PublisherPublicKeyDigest\fP, \fBCCN_PCO_B_Timestamp\fP, \fBCCN_PCO_E_Timestamp\fP, \fBCCN_PCO_B_Type\fP, \fBCCN_PCO_E_Type\fP, \fBCCN_PCO_B_FreshnessSeconds\fP, \fBCCN_PCO_E_FreshnessSeconds\fP, \fBCCN_PCO_B_FinalBlockID\fP, \fBCCN_PCO_E_FinalBlockID\fP, \fBCCN_PCO_B_KeyLocator\fP, \fBCCN_PCO_B_Key_Certificate_KeyName\fP, \fBCCN_PCO_B_KeyName_Name\fP, \fBCCN_PCO_E_KeyName_Name\fP, \fBCCN_PCO_B_KeyName_Pub\fP, \fBCCN_PCO_E_KeyName_Pub\fP, \fBCCN_PCO_E_Key_Certificate_KeyName\fP, \fBCCN_PCO_E_KeyLocator\fP, \fBCCN_PCO_B_ExtOpt\fP, \fBCCN_PCO_E_ExtOpt\fP, \fBCCN_PCO_E_SignedInfo\fP, \fBCCN_PCO_B_Content\fP, \fBCCN_PCO_E_Content\fP, \fBCCN_PCO_E\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct ccn * \fBccn_create\fP (void)"
.br
.RI "\fICreate a client handle. \fP"
.ti -1c
.RI "int \fBccn_connect\fP (struct ccn *h, const char *name)"
.br
.RI "\fIConnect to local ccnd. \fP"
.ti -1c
.RI "int \fBccn_get_connection_fd\fP (struct ccn *h)"
.br
.ti -1c
.RI "int \fBccn_disconnect\fP (struct ccn *h)"
.br
.ti -1c
.RI "void \fBccn_destroy\fP (struct ccn **hp)"
.br
.ti -1c
.RI "int \fBccn_defer_verification\fP (struct ccn *h, int defer)"
.br
.RI "\fITell the library to defer verification. \fP"
.ti -1c
.RI "int \fBccn_name_init\fP (struct \fBccn_charbuf\fP *c)"
.br
.RI "\fIReset charbuf to represent an empty Name in binary format. \fP"
.ti -1c
.RI "int \fBccn_name_append\fP (struct \fBccn_charbuf\fP *c, const void *component, size_t n)"
.br
.RI "\fIAdd a Component to a Name. \fP"
.ti -1c
.RI "int \fBccn_name_append_str\fP (struct \fBccn_charbuf\fP *c, const char *s)"
.br
.RI "\fIAdd a Component that is a NUL-terminated string. \fP"
.ti -1c
.RI "int \fBccn_name_append_components\fP (struct \fBccn_charbuf\fP *c, const unsigned char *ccnb, size_t start, size_t stop)"
.br
.RI "\fIAdd sequence of ccnb-encoded Components to a ccnb-encoded Name. \fP"
.ti -1c
.RI "int \fBccn_name_append_numeric\fP (struct \fBccn_charbuf\fP *c, enum \fBccn_marker\fP tag, uintmax_t value)"
.br
.RI "\fIAdd a binary Component to a ccnb-encoded Name. \fP"
.ti -1c
.RI "int \fBccn_name_append_nonce\fP (struct \fBccn_charbuf\fP *c)"
.br
.RI "\fIAdd nonce Component to ccnb-encoded Name. \fP"
.ti -1c
.RI "int \fBccn_name_split\fP (const struct \fBccn_charbuf\fP *c, struct \fBccn_indexbuf\fP *components)"
.br
.RI "\fIFind Component boundaries in a ccnb-encoded Name. \fP"
.ti -1c
.RI "int \fBccn_name_chop\fP (struct \fBccn_charbuf\fP *c, struct \fBccn_indexbuf\fP *components, int n)"
.br
.RI "\fIChop the name down to n components. \fP"
.ti -1c
.RI "int \fBccn_express_interest\fP (struct ccn *h, struct \fBccn_charbuf\fP *namebuf, struct \fBccn_closure\fP *action, struct \fBccn_charbuf\fP *interest_template)"
.br
.ti -1c
.RI "int \fBccn_set_interest_filter\fP (struct ccn *h, struct \fBccn_charbuf\fP *namebuf, struct \fBccn_closure\fP *action)"
.br
.RI "\fIRegister to receive interests on a prefix. \fP"
.ti -1c
.RI "int \fBccn_set_interest_filter_with_flags\fP (struct ccn *h, struct \fBccn_charbuf\fP *namebuf, struct \fBccn_closure\fP *action, int forw_flags)"
.br
.RI "\fIRegister to receive interests on a prefix, with forwarding flags. \fP"
.ti -1c
.RI "int \fBccn_put\fP (struct ccn *h, const void *p, size_t length)"
.br
.ti -1c
.RI "int \fBccn_output_is_pending\fP (struct ccn *h)"
.br
.ti -1c
.RI "int \fBccn_run\fP (struct ccn *h, int timeout)"
.br
.RI "\fIRun the ccn client event loop. \fP"
.ti -1c
.RI "int \fBccn_set_run_timeout\fP (struct ccn *h, int timeout)"
.br
.RI "\fIModify ccn_run timeout. \fP"
.ti -1c
.RI "int \fBccn_get\fP (struct ccn *h, struct \fBccn_charbuf\fP *name, struct \fBccn_charbuf\fP *interest_template, int timeout_ms, struct \fBccn_charbuf\fP *resultbuf, struct \fBccn_parsed_ContentObject\fP *pcobuf, struct \fBccn_indexbuf\fP *compsbuf, int flags)"
.br
.RI "\fIGet a single matching ContentObject This is a convenience for getting a single matching ContentObject. \fP"
.ti -1c
.RI "int \fBccn_verify_content\fP (struct ccn *h, const unsigned char *msg, struct \fBccn_parsed_ContentObject\fP *pco)"
.br
.RI "\fIVerify a ContentObject using the public key from either the object itself or our cache of keys. \fP"
.ti -1c
.RI "struct \fBccn_buf_decoder\fP * \fBccn_buf_decoder_start\fP (struct \fBccn_buf_decoder\fP *d, const unsigned char *buf, size_t size)"
.br
.ti -1c
.RI "void \fBccn_buf_advance\fP (struct \fBccn_buf_decoder\fP *d)"
.br
.ti -1c
.RI "int \fBccn_buf_advance_past_element\fP (struct \fBccn_buf_decoder\fP *d)"
.br
.ti -1c
.RI "int \fBccn_buf_match_dtag\fP (struct \fBccn_buf_decoder\fP *d, enum \fBccn_dtag\fP dtag)"
.br
.ti -1c
.RI "int \fBccn_buf_match_some_dtag\fP (struct \fBccn_buf_decoder\fP *d)"
.br
.ti -1c
.RI "int \fBccn_buf_match_some_blob\fP (struct \fBccn_buf_decoder\fP *d)"
.br
.ti -1c
.RI "int \fBccn_buf_match_blob\fP (struct \fBccn_buf_decoder\fP *d, const unsigned char **bufp, size_t *sizep)"
.br
.ti -1c
.RI "int \fBccn_buf_match_udata\fP (struct \fBccn_buf_decoder\fP *d, const char *s)"
.br
.ti -1c
.RI "int \fBccn_buf_match_attr\fP (struct \fBccn_buf_decoder\fP *d, const char *s)"
.br
.ti -1c
.RI "int \fBccn_parse_required_tagged_BLOB\fP (struct \fBccn_buf_decoder\fP *d, enum \fBccn_dtag\fP dtag, int minlen, int maxlen)"
.br
.ti -1c
.RI "int \fBccn_parse_optional_tagged_BLOB\fP (struct \fBccn_buf_decoder\fP *d, enum \fBccn_dtag\fP dtag, int minlen, int maxlen)"
.br
.ti -1c
.RI "int \fBccn_parse_nonNegativeInteger\fP (struct \fBccn_buf_decoder\fP *d)"
.br
.ti -1c
.RI "int \fBccn_parse_optional_tagged_nonNegativeInteger\fP (struct \fBccn_buf_decoder\fP *d, enum \fBccn_dtag\fP dtag)"
.br
.ti -1c
.RI "int \fBccn_parse_uintmax\fP (struct \fBccn_buf_decoder\fP *d, uintmax_t *result)"
.br
.RI "\fIParse a potentially large non-negative integer. \fP"
.ti -1c
.RI "int \fBccn_parse_tagged_string\fP (struct \fBccn_buf_decoder\fP *d, enum \fBccn_dtag\fP dtag, struct \fBccn_charbuf\fP *\fBstore\fP)"
.br
.RI "\fIParses a ccnb-encoded element expected to contain a UDATA string. \fP"
.ti -1c
.RI "uintmax_t \fBccn_parse_required_tagged_binary_number\fP (struct \fBccn_buf_decoder\fP *d, enum \fBccn_dtag\fP dtag, int minlen, int maxlen)"
.br
.ti -1c
.RI "uintmax_t \fBccn_parse_optional_tagged_binary_number\fP (struct \fBccn_buf_decoder\fP *d, enum \fBccn_dtag\fP dtag, int minlen, int maxlen, uintmax_t default_value)"
.br
.ti -1c
.RI "void \fBccn_buf_check_close\fP (struct \fBccn_buf_decoder\fP *d)"
.br
.RI "\fIEnter an error state if element closer not found. \fP"
.ti -1c
.RI "int \fBccn_ref_tagged_BLOB\fP (enum \fBccn_dtag\fP tt, const unsigned char *buf, size_t start, size_t stop, const unsigned char **presult, size_t *psize)"
.br
.ti -1c
.RI "int \fBccn_ref_tagged_string\fP (enum \fBccn_dtag\fP tt, const unsigned char *buf, size_t start, size_t stop, const unsigned char **presult, size_t *psize)"
.br
.RI "\fIProduce a pointer and length for the string in a ccnb-encoded tagged element containing a UDATA string. \fP"
.ti -1c
.RI "int \fBccn_fetch_tagged_nonNegativeInteger\fP (enum \fBccn_dtag\fP tt, const unsigned char *buf, size_t start, size_t stop)"
.br
.ti -1c
.RI "int \fBccn_parse_Link\fP (struct \fBccn_buf_decoder\fP *d, struct \fBccn_parsed_Link\fP *link, struct \fBccn_indexbuf\fP *components)"
.br
.ti -1c
.RI "int \fBccnb_append_Link\fP (struct \fBccn_charbuf\fP *buf, const struct \fBccn_charbuf\fP *name, const char *label, const struct \fBccn_charbuf\fP *linkAuthenticator)"
.br
.RI "\fIAppend a representation of a Link to a charbuf. \fP"
.ti -1c
.RI "int \fBccn_parse_LinkAuthenticator\fP (struct \fBccn_buf_decoder\fP *d, struct \fBccn_parsed_Link\fP *link)"
.br
.ti -1c
.RI "int \fBccn_parse_Collection_start\fP (struct \fBccn_buf_decoder\fP *d)"
.br
.ti -1c
.RI "int \fBccn_parse_Collection_next\fP (struct \fBccn_buf_decoder\fP *d, struct \fBccn_parsed_Link\fP *link, struct \fBccn_indexbuf\fP *components)"
.br
.ti -1c
.RI "int \fBccn_parse_interest\fP (const unsigned char *msg, size_t size, struct \fBccn_parsed_interest\fP *interest, struct \fBccn_indexbuf\fP *components)"
.br
.ti -1c
.RI "intmax_t \fBccn_interest_lifetime\fP (const unsigned char *msg, const struct \fBccn_parsed_interest\fP *pi)"
.br
.ti -1c
.RI "int \fBccn_interest_lifetime_seconds\fP (const unsigned char *msg, const struct \fBccn_parsed_interest\fP *pi)"
.br
.ti -1c
.RI "int \fBccn_parse_ContentObject\fP (const unsigned char *msg, size_t size, struct \fBccn_parsed_ContentObject\fP *x, struct \fBccn_indexbuf\fP *components)"
.br
.ti -1c
.RI "void \fBccn_digest_ContentObject\fP (const unsigned char *msg, struct \fBccn_parsed_ContentObject\fP *pc)"
.br
.RI "\fICompute the digest of the entire ContentObject if necessary, caching the result in pc->digest, pc->digest_bytes. \fP"
.ti -1c
.RI "int \fBccn_parse_Name\fP (struct \fBccn_buf_decoder\fP *d, struct \fBccn_indexbuf\fP *components)"
.br
.RI "\fIParses a ccnb-encoded name. \fP"
.ti -1c
.RI "int \fBccn_compare_names\fP (const unsigned char *a, size_t asize, const unsigned char *b, size_t bsize)"
.br
.ti -1c
.RI "int \fBccn_name_comp_strcmp\fP (const unsigned char *data, const struct \fBccn_indexbuf\fP *indexbuf, unsigned int i, const char *val)"
.br
.ti -1c
.RI "int \fBccn_name_comp_get\fP (const unsigned char *data, const struct \fBccn_indexbuf\fP *indexbuf, unsigned int i, const unsigned char **comp, size_t *size)"
.br
.RI "\fIExtract a pointer to and size of component at given index i. \fP"
.ti -1c
.RI "int \fBccn_name_next_sibling\fP (struct \fBccn_charbuf\fP *c)"
.br
.RI "\fIAdvance the last Component of a Name to the next possible value. \fP"
.ti -1c
.RI "int \fBccn_content_get_value\fP (const unsigned char *data, size_t data_size, const struct \fBccn_parsed_ContentObject\fP *content, const unsigned char **value, size_t *size)"
.br
.ti -1c
.RI "int \fBccn_is_final_block\fP (struct \fBccn_upcall_info\fP *info)"
.br
.RI "\fICheck whether content described by info is final block. \fP"
.ti -1c
.RI "int \fBccn_is_final_pco\fP (const unsigned char *ccnb, struct \fBccn_parsed_ContentObject\fP *pco, struct \fBccn_indexbuf\fP *comps)"
.br
.RI "\fIGiven a ccnb encoded content object, the parsed form, and name components report whether this is the last (FinalBlockID) segment of a stream. \fP"
.ti -1c
.RI "int \fBccn_sign_content\fP (struct ccn *h, struct \fBccn_charbuf\fP *resultbuf, const struct \fBccn_charbuf\fP *name_prefix, const struct \fBccn_signing_params\fP *params, const void *data, size_t size)"
.br
.RI "\fICreate a signed ContentObject. \fP"
.ti -1c
.RI "int \fBccn_load_private_key\fP (struct ccn *h, const char *keystore_path, const char *keystore_passphrase, struct \fBccn_charbuf\fP *pubid_out)"
.br
.RI "\fILoad a private key from a keystore file. \fP"
.ti -1c
.RI "int \fBccn_load_default_key\fP (struct ccn *h, const char *keystore_path, const char *keystore_passphrase)"
.br
.RI "\fILoad the handle's default signing key from a keystore. \fP"
.ti -1c
.RI "int \fBccn_get_public_key\fP (struct ccn *h, const struct \fBccn_signing_params\fP *params, struct \fBccn_charbuf\fP *digest_result, struct \fBccn_charbuf\fP *result)"
.br
.RI "\fIPlace the public key associated with the params into result buffer, and its digest into digest_result. \fP"
.ti -1c
.RI "int \fBccn_chk_signing_params\fP (struct ccn *h, const struct \fBccn_signing_params\fP *params, struct \fBccn_signing_params\fP *result, struct \fBccn_charbuf\fP **ptimestamp, struct \fBccn_charbuf\fP **pfinalblockid, struct \fBccn_charbuf\fP **pkeylocator, struct \fBccn_charbuf\fP **pextopt)"
.br
.RI "\fIThis is mostly for use within the library, but may be useful for some clients. \fP"
.ti -1c
.RI "int \fBccn_signed_info_create\fP (struct \fBccn_charbuf\fP *c, const void *publisher_key_id, size_t publisher_key_id_size, const struct \fBccn_charbuf\fP *timestamp, enum \fBccn_content_type\fP type, int \fBfreshness\fP, const struct \fBccn_charbuf\fP *finalblockid, const struct \fBccn_charbuf\fP *key_locator)"
.br
.RI "\fICreate SignedInfo. \fP"
.ti -1c
.RI "int \fBccn_encode_ContentObject\fP (struct \fBccn_charbuf\fP *buf, const struct \fBccn_charbuf\fP *Name, const struct \fBccn_charbuf\fP *SignedInfo, const void *data, size_t size, const char *digest_algorithm, const struct ccn_pkey *private_key)"
.br
.RI "\fIEncode and sign a ContentObject. \fP"
.ti -1c
.RI "int \fBccn_content_matches_interest\fP (const unsigned char *content_object, size_t content_object_size, int implicit_content_digest, struct \fBccn_parsed_ContentObject\fP *pc, const unsigned char *interest_msg, size_t interest_msg_size, const struct \fBccn_parsed_interest\fP *pi)"
.br
.RI "\fITest for a match between a ContentObject and an Interest. \fP"
.ti -1c
.RI "int \fBccn_excluded\fP (const unsigned char *excl, size_t excl_size, const unsigned char *nextcomp, size_t nextcomp_size)"
.br
.RI "\fITest for a match between a next component and an exclusion clause. \fP"
.ti -1c
.RI "int \fBccn_encode_StatusResponse\fP (struct \fBccn_charbuf\fP *buf, int errcode, const char *errtext)"
.br
.ti -1c
.RI "void \fBccn_perror\fP (struct ccn *h, const char *s)"
.br
.RI "\fIProduce message on standard error output describing the last error encountered during a call using the given handle. \fP"
.ti -1c
.RI "int \fBccn_seterror\fP (struct ccn *h, int error_code)"
.br
.RI "\fISet the error code in a ccn handle. \fP"
.ti -1c
.RI "int \fBccn_geterror\fP (struct ccn *h)"
.br
.RI "\fIRecover last error code. \fP"
.ti -1c
.RI "int \fBccn_charbuf_append_tt\fP (struct \fBccn_charbuf\fP *c, size_t val, enum \fBccn_tt\fP tt)"
.br
.RI "\fIAppend a ccnb start marker. \fP"
.ti -1c
.RI "int \fBccn_charbuf_append_closer\fP (struct \fBccn_charbuf\fP *c)"
.br
.RI "\fIAppend a CCN_CLOSE. \fP"
.ti -1c
.RI "int \fBccnb_append_number\fP (struct \fBccn_charbuf\fP *c, int nni)"
.br
.RI "\fIAppend a non-negative integer as a UDATA. \fP"
.ti -1c
.RI "int \fBccnb_append_timestamp_blob\fP (struct \fBccn_charbuf\fP *c, enum \fBccn_marker\fP marker, intmax_t secs, int nsecs)"
.br
.RI "\fIAppend a binary timestamp as a BLOB using the ccn binary Timestamp representation (12-bit fraction). \fP"
.ti -1c
.RI "int \fBccnb_append_now_blob\fP (struct \fBccn_charbuf\fP *c, enum \fBccn_marker\fP marker)"
.br
.RI "\fIAppend a binary timestamp, using the current time. \fP"
.ti -1c
.RI "int \fBccnb_element_begin\fP (struct \fBccn_charbuf\fP *c, enum \fBccn_dtag\fP dtag)"
.br
.RI "\fIAppend a start-of-element marker. \fP"
.ti -1c
.RI "int \fBccnb_element_end\fP (struct \fBccn_charbuf\fP *c)"
.br
.RI "\fIAppend an end-of-element marker. \fP"
.ti -1c
.RI "int \fBccnb_append_tagged_blob\fP (struct \fBccn_charbuf\fP *c, enum \fBccn_dtag\fP dtag, const void *data, size_t size)"
.br
.RI "\fIAppend a tagged BLOB. \fP"
.ti -1c
.RI "int \fBccnb_append_tagged_binary_number\fP (struct \fBccn_charbuf\fP *cb, enum \fBccn_dtag\fP dtag, uintmax_t val)"
.br
.RI "\fIAppend a tagged binary number as a blob containing the integer value. \fP"
.ti -1c
.RI "int \fBccnb_tagged_putf\fP (struct \fBccn_charbuf\fP *c, enum \fBccn_dtag\fP dtag, const char *fmt,...)"
.br
.RI "\fIAppend a tagged UDATA string, with printf-style formatting. \fP"
.ti -1c
.RI "int \fBccn_resolve_version\fP (struct ccn *h, struct \fBccn_charbuf\fP *name, int versioning_flags, int timeout_ms)"
.br
.RI "\fIResolve the version, based on existing ccn content. \fP"
.ti -1c
.RI "int \fBccn_create_version\fP (struct ccn *h, struct \fBccn_charbuf\fP *name, int versioning_flags, intmax_t secs, int nsecs)"
.br
.RI "\fIExtend a Name with a new version stamp. \fP"
.ti -1c
.RI "int \fBccn_guest_prefix\fP (struct ccn *h, struct \fBccn_charbuf\fP *result, int ms)"
.br
.RI "\fIAsk upstream for a guest prefix that will be routed to us. \fP"
.in -1c
.SH "Detailed Description"
.PP 
This is the low-level interface for CCNx clients. 

Part of the CCNx C Library.
.PP
Copyright (C) 2008-2013 Palo Alto Research Center, Inc.
.PP
This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License version 2.1 as published by the Free Software Foundation. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this library; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. 
.PP
Definition in file \fBccn.h\fP.
.SH "Define Documentation"
.PP 
.SS "#define CCN_AOK_CS   0x1"
.PP
Definition at line 608 of file ccn.h.
.PP
Referenced by answer_passive(), ccn_parse_interest(), ccnd_answer_req(), incoming_content(), and process_incoming_interest().
.SS "#define CCN_AOK_DEFAULT   (CCN_AOK_CS | CCN_AOK_NEW)"
.PP
Definition at line 610 of file ccn.h.
.PP
Referenced by ccn_parse_interest(), ccnd_debug_ccnb(), local_scope_rm_template(), main(), and make_template().
.SS "#define CCN_AOK_EXPIRE   0x10"
.PP
Definition at line 612 of file ccn.h.
.PP
Referenced by ccn_parse_interest(), local_scope_rm_template(), and process_incoming_interest().
.SS "#define CCN_AOK_NEW   0x2"
.PP
Definition at line 609 of file ccn.h.
.PP
Referenced by ccn_parse_interest(), ccnd_answer_req(), ccnr_answer_req(), incoming_interest(), r_proto_answer_req(), and SyncInterestArrived().
.SS "#define CCN_AOK_STALE   0x4"
.PP
Definition at line 611 of file ccn.h.
.PP
Referenced by answer_passive(), main(), make_template(), and process_incoming_interest().
.SS "#define CCN_API_VERSION   7001"
.PP
A macro that clients may use to cope with an evolving API. The decimal digits of this use the pattern MMVVXXX, where MM is the major release number and VV is the minor version level. XXX will be bumped when an API change is made, but it will not be directly tied to the patch level in a release number. Thus CCN_API_VERSION=1000 would have corresponded to the first public release (0.1.0), but that version did not have this macro defined. 
.PP
Definition at line 40 of file ccn.h.
.PP
Referenced by collect_stats_html(), and collect_stats_xml().
.SS "#define CCN_GET_NOKEYWAIT   1"
.PP
Definition at line 379 of file ccn.h.
.PP
Referenced by ccn_get(), ccn_resolve_version(), handle_simple_incoming_content(), and main().
.SS "#define CCN_INTEREST_LIFETIME_MICROSEC   (CCN_INTEREST_LIFETIME_SEC * 1000000)"
.PP
Definition at line 48 of file ccn.h.
.PP
Referenced by ccn_construct_interest(), ccn_process_scheduled_operations(), ccnd_internal_client_start(), ccnr_direct_client_refresh(), ccnr_direct_client_start(), ccnr_internal_client_start(), and reap().
.SS "#define CCN_INTEREST_LIFETIME_SEC   4"
.PP
Interest lifetime default. If the interest lifetime is not explicit, this is the default value. 
.PP
Definition at line 47 of file ccn.h.
.PP
Referenced by ccn_interest_lifetime(), ccn_update_refresh_us(), ccnd_debug_ccnb(), main(), and send_interest().
.SS "#define CCN_SIGNING_DEFAULT_DIGEST_ALGORITHM   'SHA256'"
.PP
Definition at line 858 of file ccn.h.
.PP
Referenced by ccn_verify_signature().
.SS "#define CCN_SIGNING_PARAMS_INIT   { CCN_API_VERSION, 0, NULL, {0}, CCN_CONTENT_DATA, -1 }"
.PP
Definition at line 817 of file ccn.h.
.PP
Referenced by ccn_get_public_key(), ccn_sign_content(), ccnd_answer_req(), ccnd_init_face_guid_cob(), ccnd_init_internal_keystore(), ccnd_init_service_ccnb(), ccnd_req_guest(), ccnr_answer_req(), ccnr_init_policy_cob(), ccnr_init_policy_link_cob(), ccnr_init_repo_keystore(), ccnr_init_service_ccnb(), generate_cob(), localStore(), main(), r_proto_bulk_import(), r_proto_continue_enumeration(), r_proto_start_write(), r_proto_start_write_checked(), seqw_next_cob(), storeHandler(), SyncSignBuf(), and write_slice().
.SS "#define CCN_SP_FINAL_BLOCK   0x0010"
.PP
Definition at line 824 of file ccn.h.
.PP
Referenced by ccn_chk_signing_params(), ccn_sign_content(), ccnd_init_face_guid_cob(), ccnd_init_service_ccnb(), ccnd_req_guest(), ccnr_init_policy_cob(), ccnr_init_policy_link_cob(), ccnr_init_service_ccnb(), generate_cob(), localStore(), main(), r_proto_continue_enumeration(), SendDeltasReply(), seqw_next_cob(), storeHandler(), SyncCacheEntryStore(), SyncInterestArrived(), and write_slice().
.SS "#define CCN_SP_OMIT_KEY_LOCATOR   0x0020"
.PP
Definition at line 825 of file ccn.h.
.PP
Referenced by ccn_chk_signing_params(), ccn_sign_content(), and main().
.SS "#define CCN_SP_TEMPL_EXT_OPT   0x0040"
.PP
Definition at line 826 of file ccn.h.
.PP
Referenced by ccn_chk_signing_params(), and main().
.SS "#define CCN_SP_TEMPL_FINAL_BLOCK_ID   0x0002"
.PP
Definition at line 821 of file ccn.h.
.PP
Referenced by ccn_chk_signing_params().
.SS "#define CCN_SP_TEMPL_FRESHNESS   0x0004"
.PP
Definition at line 822 of file ccn.h.
.PP
Referenced by ccn_chk_signing_params(), main(), and SyncSignBuf().
.SS "#define CCN_SP_TEMPL_KEY_LOCATOR   0x0008"
.PP
Definition at line 823 of file ccn.h.
.PP
Referenced by ccn_chk_signing_params(), ccnd_init_service_ccnb(), ccnr_init_service_ccnb(), and main().
.SS "#define CCN_SP_TEMPL_TIMESTAMP   0x0001"
.PP
Definition at line 820 of file ccn.h.
.PP
Referenced by ccn_chk_signing_params(), and main().
.SS "#define CCN_V_EST   8"
.PP
look for extreme 
.PP
Definition at line 1009 of file ccn.h.
.PP
Referenced by ccn_resolve_version().
.SS "#define CCN_V_HIGH   4"
.PP
look for newer version 
.PP
Definition at line 1008 of file ccn.h.
.PP
Referenced by ccn_create_version(), ccn_resolve_version(), getFile(), and main().
.SS "#define CCN_V_HIGHEST   (4|8)"
.PP
Definition at line 1011 of file ccn.h.
.PP
Referenced by ccn_get_header(), ccn_guest_prefix(), ccns_read_slice(), and main().
.SS "#define CCN_V_LOW   2"
.PP
look for early version 
.PP
Definition at line 1007 of file ccn.h.
.SS "#define CCN_V_LOWEST   (2|8)"
.PP
Definition at line 1010 of file ccn.h.
.SS "#define CCN_V_NESTOK   32"
.PP
version within version is ok 
.PP
Definition at line 1015 of file ccn.h.
.PP
Referenced by ccn_create_version(), and ccn_resolve_version().
.SS "#define CCN_V_NEXT   (4|1)"
.PP
Definition at line 1012 of file ccn.h.
.SS "#define CCN_V_NOW   16"
.PP
use current time 
.PP
Definition at line 1014 of file ccn.h.
.PP
Referenced by ccn_create_version(), ccn_seqw_create(), ccnd_init_face_guid_cob(), ccnd_req_guest(), ccnr_init_policy_link_cob(), ccns_delete_slice(), ccns_write_slice(), generate_cob(), localStore(), main(), putFile(), r_proto_begin_enumeration(), SendDeltasReply(), SyncCacheEntryStore(), and SyncInterestArrived().
.SS "#define CCN_V_PREV   (2|1)"
.PP
Definition at line 1013 of file ccn.h.
.SS "#define CCN_V_REPLACE   1"
.PP
Versioning. if last component is version, replace it 
.PP
Definition at line 1006 of file ccn.h.
.PP
Referenced by ccn_create_version(), ccns_delete_slice(), and main().
.SS "#define CCN_V_SCOPE0   64"
.PP
use scope 0 
.PP
Definition at line 1016 of file ccn.h.
.PP
Referenced by resolve_templ().
.SS "#define CCN_V_SCOPE1   128"
.PP
use scope 1 
.PP
Definition at line 1017 of file ccn.h.
.PP
Referenced by resolve_templ().
.SS "#define CCN_V_SCOPE2   256"
.PP
use scope 2 
.PP
Definition at line 1018 of file ccn.h.
.PP
Referenced by resolve_templ().
.SH "Typedef Documentation"
.PP 
.SS "typedef enum \fBccn_upcall_res\fP(* \fBccn_handler\fP)(struct \fBccn_closure\fP *selfp, enum \fBccn_upcall_kind\fP kind, struct \fBccn_upcall_info\fP *info)"
.PP
ccn_handler This is the procedure type for the closure's implementation. 
.PP
Definition at line 101 of file ccn.h.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBccn_content_type\fP"
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICCN_CONTENT_DATA \fP\fP
.TP
\fB\fICCN_CONTENT_ENCR \fP\fP
.TP
\fB\fICCN_CONTENT_GONE \fP\fP
.TP
\fB\fICCN_CONTENT_KEY \fP\fP
.TP
\fB\fICCN_CONTENT_LINK \fP\fP
.TP
\fB\fICCN_CONTENT_NACK \fP\fP

.PP
Definition at line 279 of file ccn.h.
.SS "enum \fBccn_marker\fP"
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICCN_MARKER_NONE \fP\fP
.TP
\fB\fICCN_MARKER_SEQNUM \fP\fP
consecutive block sequence numbers 
.TP
\fB\fICCN_MARKER_CONTROL \fP\fP
commands, etc. 
.TP
\fB\fICCN_MARKER_OSEQNUM \fP\fP
deprecated 
.TP
\fB\fICCN_MARKER_BLKID \fP\fP
nonconsecutive block ids 
.TP
\fB\fICCN_MARKER_VERSION \fP\fP
timestamp-based versioning 
.PP
Definition at line 228 of file ccn.h.
.SS "enum \fBccn_parsed_content_object_offsetid\fP"
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICCN_PCO_B_Signature \fP\fP
.TP
\fB\fICCN_PCO_B_DigestAlgorithm \fP\fP
.TP
\fB\fICCN_PCO_E_DigestAlgorithm \fP\fP
.TP
\fB\fICCN_PCO_B_Witness \fP\fP
.TP
\fB\fICCN_PCO_E_Witness \fP\fP
.TP
\fB\fICCN_PCO_B_SignatureBits \fP\fP
.TP
\fB\fICCN_PCO_E_SignatureBits \fP\fP
.TP
\fB\fICCN_PCO_E_Signature \fP\fP
.TP
\fB\fICCN_PCO_B_Name \fP\fP
.TP
\fB\fICCN_PCO_B_Component0 \fP\fP
.TP
\fB\fICCN_PCO_E_ComponentN \fP\fP
.TP
\fB\fICCN_PCO_E_ComponentLast \fP\fP
.TP
\fB\fICCN_PCO_E_Name \fP\fP
.TP
\fB\fICCN_PCO_B_SignedInfo \fP\fP
.TP
\fB\fICCN_PCO_B_PublisherPublicKeyDigest \fP\fP
.TP
\fB\fICCN_PCO_E_PublisherPublicKeyDigest \fP\fP
.TP
\fB\fICCN_PCO_B_Timestamp \fP\fP
.TP
\fB\fICCN_PCO_E_Timestamp \fP\fP
.TP
\fB\fICCN_PCO_B_Type \fP\fP
.TP
\fB\fICCN_PCO_E_Type \fP\fP
.TP
\fB\fICCN_PCO_B_FreshnessSeconds \fP\fP
.TP
\fB\fICCN_PCO_E_FreshnessSeconds \fP\fP
.TP
\fB\fICCN_PCO_B_FinalBlockID \fP\fP
.TP
\fB\fICCN_PCO_E_FinalBlockID \fP\fP
.TP
\fB\fICCN_PCO_B_KeyLocator \fP\fP
.TP
\fB\fICCN_PCO_B_Key_Certificate_KeyName \fP\fP
.TP
\fB\fICCN_PCO_B_KeyName_Name \fP\fP
.TP
\fB\fICCN_PCO_E_KeyName_Name \fP\fP
.TP
\fB\fICCN_PCO_B_KeyName_Pub \fP\fP
.TP
\fB\fICCN_PCO_E_KeyName_Pub \fP\fP
.TP
\fB\fICCN_PCO_E_Key_Certificate_KeyName \fP\fP
.TP
\fB\fICCN_PCO_E_KeyLocator \fP\fP
.TP
\fB\fICCN_PCO_B_ExtOpt \fP\fP
.TP
\fB\fICCN_PCO_E_ExtOpt \fP\fP
.TP
\fB\fICCN_PCO_E_SignedInfo \fP\fP
.TP
\fB\fICCN_PCO_B_Content \fP\fP
.TP
\fB\fICCN_PCO_E_Content \fP\fP
.TP
\fB\fICCN_PCO_E \fP\fP

.PP
Definition at line 642 of file ccn.h.
.SS "enum \fBccn_parsed_interest_offsetid\fP"
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICCN_PI_B_Name \fP\fP
.TP
\fB\fICCN_PI_B_Component0 \fP\fP
.TP
\fB\fICCN_PI_B_LastPrefixComponent \fP\fP
.TP
\fB\fICCN_PI_E_LastPrefixComponent \fP\fP
.TP
\fB\fICCN_PI_E_ComponentLast \fP\fP
.TP
\fB\fICCN_PI_E_Name \fP\fP
.TP
\fB\fICCN_PI_B_MinSuffixComponents \fP\fP
.TP
\fB\fICCN_PI_E_MinSuffixComponents \fP\fP
.TP
\fB\fICCN_PI_B_MaxSuffixComponents \fP\fP
.TP
\fB\fICCN_PI_E_MaxSuffixComponents \fP\fP
.TP
\fB\fICCN_PI_B_PublisherID \fP\fP
.TP
\fB\fICCN_PI_B_PublisherIDKeyDigest \fP\fP
.TP
\fB\fICCN_PI_E_PublisherIDKeyDigest \fP\fP
.TP
\fB\fICCN_PI_E_PublisherID \fP\fP
.TP
\fB\fICCN_PI_B_Exclude \fP\fP
.TP
\fB\fICCN_PI_E_Exclude \fP\fP
.TP
\fB\fICCN_PI_B_ChildSelector \fP\fP
.TP
\fB\fICCN_PI_E_ChildSelector \fP\fP
.TP
\fB\fICCN_PI_B_AnswerOriginKind \fP\fP
.TP
\fB\fICCN_PI_E_AnswerOriginKind \fP\fP
.TP
\fB\fICCN_PI_B_Scope \fP\fP
.TP
\fB\fICCN_PI_E_Scope \fP\fP
.TP
\fB\fICCN_PI_B_InterestLifetime \fP\fP
.TP
\fB\fICCN_PI_E_InterestLifetime \fP\fP
.TP
\fB\fICCN_PI_B_Nonce \fP\fP
.TP
\fB\fICCN_PI_E_Nonce \fP\fP
.TP
\fB\fICCN_PI_B_OTHER \fP\fP
.TP
\fB\fICCN_PI_E_OTHER \fP\fP
.TP
\fB\fICCN_PI_E \fP\fP

.PP
Definition at line 484 of file ccn.h.
.SS "enum \fBccn_parsed_Link_offsetid\fP"
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICCN_PL_B_Name \fP\fP
.TP
\fB\fICCN_PL_B_Component0 \fP\fP
.TP
\fB\fICCN_PL_E_ComponentLast \fP\fP
.TP
\fB\fICCN_PL_E_Name \fP\fP
.TP
\fB\fICCN_PL_B_Label \fP\fP
.TP
\fB\fICCN_PL_E_Label \fP\fP
.TP
\fB\fICCN_PL_B_LinkAuthenticator \fP\fP
.TP
\fB\fICCN_PL_B_PublisherID \fP\fP
.TP
\fB\fICCN_PL_B_PublisherDigest \fP\fP
.TP
\fB\fICCN_PL_E_PublisherDigest \fP\fP
.TP
\fB\fICCN_PL_E_PublisherID \fP\fP
.TP
\fB\fICCN_PL_B_NameComponentCount \fP\fP
.TP
\fB\fICCN_PL_E_NameComponentCount \fP\fP
.TP
\fB\fICCN_PL_B_Timestamp \fP\fP
.TP
\fB\fICCN_PL_E_Timestamp \fP\fP
.TP
\fB\fICCN_PL_B_Type \fP\fP
.TP
\fB\fICCN_PL_E_Type \fP\fP
.TP
\fB\fICCN_PL_B_ContentDigest \fP\fP
.TP
\fB\fICCN_PL_E_ContentDigest \fP\fP
.TP
\fB\fICCN_PL_E_LinkAuthenticator \fP\fP
.TP
\fB\fICCN_PL_E \fP\fP

.PP
Definition at line 527 of file ccn.h.
.SS "enum \fBccn_upcall_kind\fP"
.PP
This tells what kind of event the upcall is handling. The KEYMISSING and RAW codes are used only if deferred verification has been requested. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICCN_UPCALL_FINAL \fP\fP
handler is about to be deregistered 
.TP
\fB\fICCN_UPCALL_INTEREST \fP\fP
incoming interest 
.TP
\fB\fICCN_UPCALL_CONSUMED_INTEREST \fP\fP
incoming interest, someone has answered 
.TP
\fB\fICCN_UPCALL_CONTENT \fP\fP
incoming verified content 
.TP
\fB\fICCN_UPCALL_INTEREST_TIMED_OUT \fP\fP
interest timed out 
.TP
\fB\fICCN_UPCALL_CONTENT_UNVERIFIED \fP\fP
content that has not been verified 
.TP
\fB\fICCN_UPCALL_CONTENT_BAD \fP\fP
verification failed 
.TP
\fB\fICCN_UPCALL_CONTENT_KEYMISSING \fP\fP
key has not been fetched 
.TP
\fB\fICCN_UPCALL_CONTENT_RAW \fP\fP
verification has not been attempted 
.PP
Definition at line 73 of file ccn.h.
.SS "enum \fBccn_upcall_res\fP"
.PP
Upcalls return one of these values. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fICCN_UPCALL_RESULT_ERR \fP\fP
upcall detected an error 
.TP
\fB\fICCN_UPCALL_RESULT_OK \fP\fP
normal upcall return 
.TP
\fB\fICCN_UPCALL_RESULT_REEXPRESS \fP\fP
reexpress the same interest again 
.TP
\fB\fICCN_UPCALL_RESULT_INTEREST_CONSUMED \fP\fP
upcall claims to consume interest 
.TP
\fB\fICCN_UPCALL_RESULT_VERIFY \fP\fP
force an unverified result to be verified 
.TP
\fB\fICCN_UPCALL_RESULT_FETCHKEY \fP\fP
request fetching of an unfetched key 
.PP
Definition at line 88 of file ccn.h.
.SH "Function Documentation"
.PP 
.SS "void ccn_buf_advance (struct \fBccn_buf_decoder\fP * d)"
.PP
Definition at line 40 of file ccn_buf_decoder.c.
.PP
Referenced by append_interest_details(), appendComponents(), appendExclusions(), ccn_append_interest_bounds(), ccn_append_link_name(), ccn_buf_advance_past_element(), ccn_buf_check_close(), ccn_buf_decoder_start_at_components(), ccn_check_namebuf(), ccn_chk_signing_params(), ccn_compare_names(), ccn_content_matches_interest(), ccn_excluded(), ccn_face_instance_parse(), ccn_fetch_tagged_nonNegativeInteger(), ccn_flatname_append_from_ccnb(), ccn_forwarding_entry_parse(), ccn_header_parse(), ccn_name_comp_get(), ccn_name_last_component_offset(), ccn_parse_Collection_start(), ccn_parse_ContentObject(), ccn_parse_Exclude(), ccn_parse_interest(), ccn_parse_KeyName(), ccn_parse_Link(), ccn_parse_LinkAuthenticator(), ccn_parse_Name(), ccn_parse_nonNegativeInteger(), ccn_parse_optional_Any_or_Bloom(), ccn_parse_optional_tagged_nonNegativeInteger(), ccn_parse_PublisherID(), ccn_parse_required_tagged_binary_number(), ccn_parse_required_tagged_BLOB(), ccn_parse_required_tagged_timestamp(), ccn_parse_required_tagged_UDATA(), ccn_parse_Signature(), ccn_parse_SignedInfo(), ccn_parse_tagged_required_uintmax(), ccn_parse_tagged_string(), ccn_parse_timestamp(), ccn_parse_uintmax(), ccn_pubid_matches(), ccn_ref_tagged_BLOB(), ccn_ref_tagged_string(), ccn_uri_append(), extract_bounds(), extractDeltas(), find_first_match_candidate(), make_template(), r_proto_check_exclude(), r_proto_initiate_key_fetch(), r_proto_parse_policy(), reportExclude(), slice_parse(), SyncAppendAllComponents(), SyncAppendElementInner(), SyncCmpNamesInner(), SyncComponentCount(), SyncComponentMatch(), SyncGetComponentPtr(), SyncGetHashPtr(), SyncParseComposite(), SyncParseName(), SyncParseUnsigned(), SyncPatternMatch(), SyncPrefixMatch(), and SyncRootDecodeAndAdd().
.SS "int ccn_buf_advance_past_element (struct \fBccn_buf_decoder\fP * d)"
.PP
Definition at line 119 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_append_interest_bounds(), ccn_chk_signing_params(), ccn_flatname_append_from_ccnb(), ccn_uri_append(), and find_first_match_candidate().
.SS "void ccn_buf_check_close (struct \fBccn_buf_decoder\fP * d)"
.PP
Enter an error state if element closer not found. 
.PP
Definition at line 108 of file ccn_buf_decoder.c.
.PP
Referenced by append_interest_details(), appendComponents(), ccn_append_interest_bounds(), ccn_append_link_name(), ccn_buf_advance_past_element(), ccn_check_namebuf(), ccn_chk_signing_params(), ccn_compare_names(), ccn_excluded(), ccn_face_instance_parse(), ccn_fetch_tagged_nonNegativeInteger(), ccn_flatname_append_from_ccnb(), ccn_forwarding_entry_parse(), ccn_header_parse(), ccn_name_comp_get(), ccn_name_last_component_offset(), ccn_parse_Collection_next(), ccn_parse_ContentObject(), ccn_parse_Exclude(), ccn_parse_interest(), ccn_parse_KeyName(), ccn_parse_Link(), ccn_parse_LinkAuthenticator(), ccn_parse_Name(), ccn_parse_optional_Any_or_Bloom(), ccn_parse_optional_tagged_nonNegativeInteger(), ccn_parse_PublisherID(), ccn_parse_required_tagged_binary_number(), ccn_parse_required_tagged_BLOB(), ccn_parse_required_tagged_timestamp(), ccn_parse_required_tagged_UDATA(), ccn_parse_Signature(), ccn_parse_SignedInfo(), ccn_parse_tagged_required_uintmax(), ccn_parse_tagged_string(), ccn_ref_tagged_BLOB(), ccn_ref_tagged_string(), ccn_uri_append(), extract_bounds(), extractDeltas(), find_first_match_candidate(), make_template(), r_proto_check_exclude(), r_proto_initiate_key_fetch(), r_proto_parse_policy(), reportExclude(), slice_parse(), SyncAppendAllComponents(), SyncAppendElementInner(), SyncCmpNamesInner(), SyncComponentCount(), SyncComponentMatch(), SyncGetComponentPtr(), SyncGetHashPtr(), SyncParseComposite(), SyncParseName(), SyncParseUnsigned(), SyncPatternMatch(), SyncPrefixMatch(), and SyncRootDecodeAndAdd().
.SS "struct \fBccn_buf_decoder\fP* ccn_buf_decoder_start (struct \fBccn_buf_decoder\fP * d, const unsigned char * buf, size_t size)\fC [read]\fP"
.PP
Definition at line 28 of file ccn_buf_decoder.c.
.PP
Referenced by append_interest_details(), ccn_append_interest_bounds(), ccn_append_link_name(), ccn_buf_decoder_start_at_components(), ccn_check_namebuf(), ccn_chk_signing_params(), ccn_content_matches_interest(), ccn_excluded(), ccn_face_instance_parse(), ccn_fetch_tagged_nonNegativeInteger(), ccn_flatname_append_from_ccnb(), ccn_forwarding_entry_parse(), ccn_get_public_key(), ccn_header_parse(), ccn_interest_lifetime(), ccn_locate_key(), ccn_name_comp_get(), ccn_name_last_component_offset(), ccn_name_split(), ccn_parse_ContentObject(), ccn_parse_interest(), ccn_pubid_matches(), ccn_ref_tagged_BLOB(), ccn_ref_tagged_string(), ccn_uri_append(), ccnd_reg_uri(), extract_bounds(), extractDeltas(), extractNode(), find_first_match_candidate(), load_policy(), main(), make_template(), process_incoming_link_message(), r_proto_check_exclude(), r_proto_initiate_key_fetch(), r_proto_parse_policy(), slice_parse(), SyncCacheEntryFetch(), SyncHandleSlice(), SyncInitDecoderFromCharbufRange(), SyncInterestArrived(), SyncNodeFromBytes(), and testRootBasic().
.SS "int ccn_buf_match_attr (struct \fBccn_buf_decoder\fP * d, const char * s)"
.PP
Definition at line 98 of file ccn_buf_decoder.c.
.SS "int ccn_buf_match_blob (struct \fBccn_buf_decoder\fP * d, const unsigned char ** bufp, size_t * sizep)"
.PP
Definition at line 70 of file ccn_buf_decoder.c.
.PP
Referenced by append_interest_details(), appendComponents(), appendExclusions(), ccn_check_namebuf(), ccn_compare_names(), ccn_content_matches_interest(), ccn_excluded(), ccn_face_instance_parse(), ccn_flatname_append_from_ccnb(), ccn_forwarding_entry_parse(), ccn_get_public_key(), ccn_header_parse(), ccn_name_comp_get(), ccn_name_last_component_offset(), ccn_parse_Name(), ccn_parse_required_tagged_binary_number(), ccn_ref_tagged_BLOB(), ccn_uri_append(), make_template(), r_proto_check_exclude(), reportExclude(), SyncAppendAllComponents(), SyncAppendElementInner(), SyncCmpNamesInner(), SyncComponentCount(), SyncComponentMatch(), SyncGetComponentPtr(), SyncGetHashPtr(), SyncParseComposite(), SyncParseName(), SyncPatternMatch(), and SyncPrefixMatch().
.SS "int ccn_buf_match_dtag (struct \fBccn_buf_decoder\fP * d, enum \fBccn_dtag\fP dtag)"
.PP
Definition at line 48 of file ccn_buf_decoder.c.
.PP
Referenced by append_interest_details(), appendComponents(), appendExclusions(), ccn_append_interest_bounds(), ccn_append_link_name(), ccn_buf_decoder_start_at_components(), ccn_check_namebuf(), ccn_chk_signing_params(), ccn_compare_names(), ccn_content_matches_interest(), ccn_excluded(), ccn_face_instance_parse(), ccn_fetch_tagged_nonNegativeInteger(), ccn_flatname_append_from_ccnb(), ccn_forwarding_entry_parse(), ccn_header_parse(), ccn_locate_key(), ccn_name_comp_get(), ccn_name_last_component_offset(), ccn_parse_Collection_next(), ccn_parse_Collection_start(), ccn_parse_ContentObject(), ccn_parse_Exclude(), ccn_parse_interest(), ccn_parse_KeyName(), ccn_parse_Link(), ccn_parse_LinkAuthenticator(), ccn_parse_Name(), ccn_parse_optional_Any_or_Bloom(), ccn_parse_optional_tagged_binary_number(), ccn_parse_optional_tagged_BLOB(), ccn_parse_optional_tagged_nonNegativeInteger(), ccn_parse_optional_tagged_UDATA(), ccn_parse_PublisherID(), ccn_parse_required_tagged_binary_number(), ccn_parse_required_tagged_BLOB(), ccn_parse_required_tagged_timestamp(), ccn_parse_required_tagged_UDATA(), ccn_parse_Signature(), ccn_parse_SignedInfo(), ccn_parse_tagged_required_uintmax(), ccn_parse_tagged_string(), ccn_ref_tagged_BLOB(), ccn_ref_tagged_string(), ccn_uri_append(), extract_bounds(), extractDeltas(), find_first_match_candidate(), main(), make_template(), r_proto_check_exclude(), r_proto_initiate_key_fetch(), r_proto_parse_policy(), reportExclude(), slice_parse(), SyncAppendAllComponents(), SyncAppendElementInner(), SyncCmpNamesInner(), SyncComponentCount(), SyncComponentMatch(), SyncExtractName(), SyncGetComponentPtr(), SyncGetHashPtr(), SyncIsName(), SyncParseComposite(), SyncParseName(), SyncParseUnsigned(), SyncPatternMatch(), SyncPrefixMatch(), and SyncRootDecodeAndAdd().
.SS "int ccn_buf_match_some_blob (struct \fBccn_buf_decoder\fP * d)"
.PP
Definition at line 63 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_buf_match_blob(), ccn_chk_signing_params(), ccn_parse_LinkAuthenticator(), ccn_parse_PublisherID(), ccn_parse_required_tagged_BLOB(), and ccn_pubid_matches().
.SS "int ccn_buf_match_some_dtag (struct \fBccn_buf_decoder\fP * d)"
.PP
Definition at line 56 of file ccn_buf_decoder.c.
.SS "int ccn_buf_match_udata (struct \fBccn_buf_decoder\fP * d, const char * s)"
.PP
Definition at line 88 of file ccn_buf_decoder.c.
.SS "int ccn_charbuf_append_closer (struct \fBccn_charbuf\fP * c)"
.PP
Append a CCN_CLOSE. Use this to close off an element in ccnb-encoded data. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP is the buffer to append to. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success or -1 for error. 
.RE
.PP

.PP
Definition at line 274 of file ccn_buf_encoder.c.
.PP
Referenced by answer_passive(), append_Any_filter(), append_bf_all(), append_bloom_element(), append_filter_all(), append_future_vcomp(), appendExclusions(), ccn_construct_interest(), ccn_create_version(), ccn_encode_ContentObject(), ccn_encode_Signature(), ccn_encode_StatusResponse(), ccn_guest_prefix(), ccn_initiate_key_fetch(), ccn_name_append_components(), ccn_name_from_uri(), ccn_name_init(), ccn_sign_content(), ccn_signed_info_create(), ccnb_append_Link(), ccnb_append_tagged_blob(), ccnb_element_end(), ccnb_tagged_putf(), ccnd_answer_req(), ccnd_init_service_ccnb(), ccnd_req_guest(), ccnr_answer_req(), ccnr_init_service_ccnb(), create_passive_templ(), express_bulkdata_interest(), express_interest(), express_my_interest(), find_first_match_candidate(), handle_key(), incoming_content(), local_scope(), local_scope_rm_template(), main(), make_data_template(), make_template(), me_too(), process_incoming_content(), r_proto_initiate_key_fetch(), r_proto_start_write(), r_proto_start_write_checked(), resolve_templ(), send_interest(), stuff_and_send(), stuff_link_check(), SyncAppendElementInner(), SyncAppendRandomHash(), SyncAppendRandomName(), SyncGenInterest(), and SyncSignBuf().
.SS "int ccn_charbuf_append_tt (struct \fBccn_charbuf\fP * c, size_t val, enum \fBccn_tt\fP tt)"
.PP
Append a ccnb start marker. This forms the basic building block of ccnb-encoded data. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP is the buffer to append to. 
.br
\fIval\fP is the numval, intepreted according to tt (see enum ccn_tt). 
.br
\fItt\fP is the type field. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success or -1 for error. 
.RE
.PP

.PP
Definition at line 256 of file ccn_buf_encoder.c.
.PP
Referenced by answer_passive(), append_Any_filter(), append_bf_all(), append_bloom_element(), append_filter_all(), append_future_vcomp(), appendExclusions(), ccn_append_link_stuff(), ccn_append_pubkey_blob(), ccn_construct_interest(), ccn_create_version(), ccn_encode_ContentObject(), ccn_encode_Signature(), ccn_encode_StatusResponse(), ccn_guest_prefix(), ccn_initiate_key_fetch(), ccn_name_append(), ccn_name_init(), ccn_sign_content(), ccn_signed_info_create(), ccnb_append_Link(), ccnb_append_number(), ccnb_append_tagged_blob(), ccnb_append_timestamp_blob(), ccnb_element_begin(), ccnb_tagged_putf(), ccnd_init_service_ccnb(), ccnr_init_service_ccnb(), create_passive_templ(), express_bulkdata_interest(), express_interest(), express_my_interest(), handle_key(), incoming_content(), local_scope(), local_scope_rm_template(), main(), make_data_template(), make_template(), process_incoming_content(), r_proto_initiate_key_fetch(), resolve_templ(), stuff_and_send(), stuff_link_check(), SyncAppendElementInner(), SyncAppendRandomHash(), SyncAppendRandomName(), SyncGenInterest(), and SyncSignBuf().
.SS "int ccn_chk_signing_params (struct ccn * h, const struct \fBccn_signing_params\fP * params, struct \fBccn_signing_params\fP * result, struct \fBccn_charbuf\fP ** ptimestamp, struct \fBccn_charbuf\fP ** pfinalblockid, struct \fBccn_charbuf\fP ** pkeylocator, struct \fBccn_charbuf\fP ** pextopt)"
.PP
This is mostly for use within the library, but may be useful for some clients. 
.PP
Definition at line 2682 of file ccn_client.c.
.PP
Referenced by ccn_get_public_key(), ccn_sign_content(), ccnd_init_internal_keystore(), and ccnr_init_repo_keystore().
.SS "int ccn_compare_names (const unsigned char * a, size_t asize, const unsigned char * b, size_t bsize)"
.PP
Definition at line 942 of file ccn_buf_decoder.c.
.PP
Referenced by content_skiplist_findbefore(), namecompare(), and r_proto_start_write().
.SS "int ccn_connect (struct ccn * h, const char * name)"
.PP
Connect to local ccnd. \fBParameters:\fP
.RS 4
\fIh\fP is a ccn library handle 
.br
\fIname\fP is the name of the unix-domain socket to connect to, or the string 'tcp[4|6][:port]' to indicate a TCP connection using either IPv4 (default) or IPv6 on the optional port; use NULL to get the default, which is affected by the environment variables CCN_LOCAL_TRANSPORT, interpreted as is name, and CCN_LOCAL_PORT if there is no port specified, or CCN_LOCAL_SOCKNAME and CCN_LOCAL_PORT. 
.RE
.PP
\fBReturns:\fP
.RS 4
the fd for the connection, or -1 for error. 
.RE
.PP

.PP
Definition at line 358 of file ccn_client.c.
.PP
Referenced by ccn_fetch_new(), ccn_get(), ccndc_initialize_data(), chat_main(), existingRootOp(), getFile(), main(), putFile(), putFileList(), r_init_create(), and sendSlice().
.SS "int ccn_content_get_value (const unsigned char * data, size_t data_size, const struct \fBccn_parsed_ContentObject\fP * content, const unsigned char ** value, size_t * size)"
.PP
Definition at line 929 of file ccn_buf_decoder.c.
.PP
Referenced by CallMe(), ccn_cache_key(), ccn_get_header(), ccn_guest_prefix(), ccnd_req_destroyface(), ccnd_req_newface(), ccnd_req_prefix_or_self_reg(), ccnd_req_unreg(), ccndc_do_face_action(), ccndc_do_prefix_action(), ccns_read_slice(), decode_message(), display_the_content(), extractDeltas(), extractNode(), handle_key(), handle_prefix_reg_reply(), incoming_content(), main(), process_test(), r_proto_initiate_key_fetch(), SyncCacheEntryFetch(), SyncNodeFromParsedObject(), and SyncPointerToContent().
.SS "int ccn_content_matches_interest (const unsigned char * content_object, size_t content_object_size, int implicit_content_digest, struct \fBccn_parsed_ContentObject\fP * pc, const unsigned char * interest_msg, size_t interest_msg_size, const struct \fBccn_parsed_interest\fP * pi)"
.PP
Test for a match between a ContentObject and an Interest. \fBParameters:\fP
.RS 4
\fIcontent_object\fP ccnb-encoded ContentObject 
.br
\fIcontent_object_size\fP its size in bytes 
.br
\fIimplicit_content_digest\fP boolean indicating whether the final name component is implicit (as in the on-wire format) or explicit (as within ccnd's content store). 
.br
\fIpc\fP Valid parse information may be provided to speed things up. If NULL it will be reconstructed internally. 
.br
\fIinterest_msg\fP ccnb-encoded Interest 
.br
\fIinterest_msg_size\fP its size in bytes 
.br
\fIpi\fP see _pc_
.RE
.PP
\fBReturns:\fP
.RS 4
1 if the ccnb-encoded content_object matches the ccnb-encoded interest_msg, otherwise 0. 
.RE
.PP

.PP
Definition at line 195 of file ccn_match.c.
.PP
Referenced by ccn_dispatch_message(), ccnd_answer_by_guid(), ccnd_answer_req(), ccnd_req_guest(), ccnr_answer_req(), cob_matches(), consume_matching_interests(), incoming_interest(), interest_handler(), matchbox(), process_incoming_interest(), r_match_consume_matching_interests(), r_proto_begin_enumeration(), r_proto_continue_enumeration(), seqw_incoming_interest(), SyncInterestArrived(), and write_interest_handler().
.SS "struct ccn* ccn_create (void)\fC [read]\fP"
.PP
Create a client handle. The new handle is not yet connected. On error, returns NULL and sets errno. Errors: ENOMEM 
.PP
Definition at line 270 of file ccn_client.c.
.PP
Referenced by ccn_fetch_new(), ccn_get(), ccnd_internal_client_start(), ccndc_initialize_data(), ccnr_direct_client_start(), ccnr_internal_client_start(), chat_main(), existingRootOp(), getFile(), main(), putFile(), putFileList(), and sendSlice().
.SS "int ccn_create_version (struct ccn * h, struct \fBccn_charbuf\fP * name, int versioning_flags, intmax_t secs, int nsecs)"
.PP
Extend a Name with a new version stamp. \fBParameters:\fP
.RS 4
\fIh\fP is the the ccn handle. May be NULL. This procedure does not use the connection. 
.br
\fIname\fP is a ccnb-encoded Name prefix. By default it gets extended in-place with one additional Component that conforms to the versioning profile and is based on the supplied time, unless a version component is already present. 
.br
\fIversioning_flags\fP modifies the default behavior: CCN_V_REPLACE causes the last component to be replaced if it appears to be a version stamp. If CCN_V_HIGH is set as well, an attempt will be made to generate a new version stamp that is later than the existing one, or to return an error. CCN_V_NOW bases the version on the current time rather than the supplied time. CCN_V_NESTOK will allow the new version component to be appended even if there is one there (this makes no difference if CCN_V_REPLACE is also set). 
.br
\fIsecs\fP is the desired time, in seconds since epoch (ignored if CCN_V_NOW is set). 
.br
\fInsecs\fP is the number of nanoseconds. 
.RE
.PP
\fBReturns:\fP
.RS 4
-1 for error, 0 for success. 
.RE
.PP

.PP
Definition at line 254 of file ccn_versioning.c.
.PP
Referenced by ccn_seqw_create(), ccnd_init_face_guid_cob(), ccnd_init_service_ccnb(), ccnd_req_guest(), ccnr_init_policy_link_cob(), ccnr_init_service_ccnb(), ccns_delete_slice(), ccns_write_slice(), generate_cob(), load_policy(), localStore(), main(), putFile(), r_proto_begin_enumeration(), SendDeltasReply(), SyncCacheEntryStore(), and SyncInterestArrived().
.SS "int ccn_defer_verification (struct ccn * h, int defer)"
.PP
Tell the library to defer verification. For some specialized applications (performance testing being an example), the normal verification done within the library may be undesirable. Setting the 'defer validation' flag will cause the library to pass content to the application without attempting to verify it. In this case, the CCN_UPCALL_CONTENT_RAW upcall kind will be passed instead of CCN_UPCALL_CONTENT, and CCN_UPCALL_CONTENT_KEYMISSING instead of CCN_UPCALL_CONTENT_UNVERIFIED. If the application wants do still do key fetches, it may use the CCN_UPCALL_RESULT_FETCHKEY response instead of CCN_UPCALL_RESULT_VERIFY.
.PP
Calling this while there are interests outstanding is not recommended.
.PP
This call is available beginning with CCN_API_VERSION 4004.
.PP
\fBParameters:\fP
.RS 4
\fIdefer\fP is 0 to verify, 1 to defer, -1 to leave unchanged. 
.RE
.PP
\fBReturns:\fP
.RS 4
previous value, or -1 in case of error. 
.RE
.PP

.PP
Definition at line 333 of file ccn_client.c.
.PP
Referenced by getFile(), main(), r_init_create(), and sync_start_default().
.SS "void ccn_destroy (struct ccn ** hp)"
.PP
Definition at line 571 of file ccn_client.c.
.PP
Referenced by ccn_fetch_destroy(), ccn_fetch_new(), ccn_get(), ccnd_internal_client_start(), ccnd_internal_client_stop(), ccndc_destroy_data(), ccnr_direct_client_start(), ccnr_direct_client_stop(), ccnr_internal_client_start(), ccnr_internal_client_stop(), existingRootOp(), getFile(), main(), putFile(), putFileList(), and sendSlice().
.SS "void ccn_digest_ContentObject (const unsigned char * msg, struct \fBccn_parsed_ContentObject\fP * pc)"
.PP
Compute the digest of the entire ContentObject if necessary, caching the result in pc->digest, pc->digest_bytes. 
.PP
Definition at line 34 of file ccn_match.c.
.PP
Referenced by ccn_content_matches_interest(), incoming_content(), process_incoming_content(), r_store_set_flatname(), storeHandler(), and test_insert_content().
.SS "int ccn_disconnect (struct ccn * h)"
.PP
Definition at line 448 of file ccn_client.c.
.PP
Referenced by ccn_destroy(), ccn_fetch_destroy(), ccn_process_input(), ccn_run(), ccndc_destroy_data(), main(), r_init_create(), and r_io_shutdown_client_fd().
.SS "int ccn_encode_ContentObject (struct \fBccn_charbuf\fP * buf, const struct \fBccn_charbuf\fP * Name, const struct \fBccn_charbuf\fP * SignedInfo, const void * data, size_t size, const char * digest_algorithm, const struct ccn_pkey * private_key)"
.PP
Encode and sign a ContentObject. \fBParameters:\fP
.RS 4
\fIbuf\fP is the output buffer where encoded object is written. 
.br
\fIName\fP is the ccnb-encoded name from ccn_name_init and friends. 
.br
\fISignedInfo\fP is the ccnb-encoded info from ccn_signed_info_create. 
.br
\fIdata\fP pintes to the raw data to be encoded. 
.br
\fIsize\fP is the size, in bytes, of the raw data to be encoded. 
.br
\fIdigest_algorithm\fP may be NULL for default. 
.br
\fIprivate_key\fP is the private key to use for signing. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success or -1 for error. 
.RE
.PP

.PP
Definition at line 161 of file ccn_buf_encoder.c.
.PP
Referenced by ccn_sign_content(), encode_message(), and main().
.SS "int ccn_encode_StatusResponse (struct \fBccn_charbuf\fP * buf, int errcode, const char * errtext)"
.PP
Definition at line 232 of file ccn_buf_encoder.c.
.PP
Referenced by ccnd_nack().
.SS "int ccn_excluded (const unsigned char * excl, size_t excl_size, const unsigned char * nextcomp, size_t nextcomp_size)"
.PP
Test for a match between a next component and an exclusion clause. \fBParameters:\fP
.RS 4
\fIexcl\fP address of exclusion encoding 
.br
\fIexcl_size\fP bytes in exclusion encoding 
.br
\fInextcomp\fP addr of nextcomp bytes 
.br
\fInextcomp_size\fP number of nextcomp bytes 
.RE
.PP
\fBReturns:\fP
.RS 4
1 if the ccnb-encoded nextcomp matches the ccnb-encoded exclusion clause, otherwise 0. 
.RE
.PP

.PP
Definition at line 102 of file ccn_match.c.
.PP
Referenced by ccn_btree_match_interest(), ccn_content_matches_interest(), and SyncInterestArrived().
.SS "int ccn_express_interest (struct ccn * h, struct \fBccn_charbuf\fP * namebuf, struct \fBccn_closure\fP * action, struct \fBccn_charbuf\fP * interest_template)"
.PP
Definition at line 698 of file ccn_client.c.
.PP
Referenced by ask_more(), ccn_get(), ccn_initiate_ccndid_fetch(), ccn_initiate_key_fetch(), ccn_initiate_prefix_reg(), ccnd_adjacency_offer_or_commit_req(), express_bulkdata_interest(), express_interest(), express_my_interest(), fill_holes(), handle_key(), incoming_content(), main(), me_too(), my_get(), NeedSegment(), r_proto_expect_content(), r_proto_initiate_key_fetch(), r_proto_start_write(), send_adjacency_solicit(), start_interest(), SyncSendRootAdviseInterest(), SyncStartContentFetch(), and SyncStartNodeFetch().
.SS "int ccn_fetch_tagged_nonNegativeInteger (enum \fBccn_dtag\fP tt, const unsigned char * buf, size_t start, size_t stop)"
.PP
Definition at line 543 of file ccn_buf_decoder.c.
.PP
Referenced by get_outbound_faces(), r_store_set_content_timer(), and set_content_timer().
.SS "int ccn_get (struct ccn * h, struct \fBccn_charbuf\fP * name, struct \fBccn_charbuf\fP * interest_template, int timeout_ms, struct \fBccn_charbuf\fP * resultbuf, struct \fBccn_parsed_ContentObject\fP * pcobuf, struct \fBccn_indexbuf\fP * compsbuf, int flags)"
.PP
Get a single matching ContentObject This is a convenience for getting a single matching ContentObject. Blocks until a matching ContentObject arrives or there is a timeout. 
.PP
\fBParameters:\fP
.RS 4
\fIh\fP is the ccn handle. If NULL or ccn_get is called from inside an upcall, a new connection will be used and upcalls from other requests will not be processed while ccn_get is active. 
.br
\fIname\fP holds a ccnb-encoded Name 
.br
\fIinterest_template\fP conveys other fields to be used in the interest (may be NULL). 
.br
\fItimeout_ms\fP limits the time spent waiting for an answer (milliseconds). 
.br
\fIresultbuf\fP is updated to contain the ccnb-encoded ContentObject. 
.br
\fIpcobuf\fP may be supplied to save the client the work of re-parsing the ContentObject; may be NULL if this information is not actually needed. 
.br
\fIcompsbuf\fP works similarly. 
.br
\fIflags\fP - CCN_GET_NOKEYWAIT means that it is permitted to return unverified data. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success, -1 for an error. 
.RE
.PP

.PP
Definition at line 2146 of file ccn_client.c.
.PP
Referenced by ccn_get_header(), ccn_guest_prefix(), ccn_resolve_version(), ccndc_do_face_action(), ccndc_do_prefix_action(), ccndc_get_ccnd_id(), ccns_read_slice(), existingRootOp(), getFile(), localStore(), main(), putFile(), putFileList(), and write_slice().
.SS "int ccn_get_connection_fd (struct ccn * h)"
.PP
Definition at line 422 of file ccn_client.c.
.PP
Referenced by ccnr_direct_client_refresh(), main(), r_dispatch_run(), r_init_create(), r_proto_answer_req(), r_proto_expect_content(), r_sync_upcall_store(), and wait_for_input_or_timeout().
.SS "int ccn_get_public_key (struct ccn * h, const struct \fBccn_signing_params\fP * params, struct \fBccn_charbuf\fP * digest_result, struct \fBccn_charbuf\fP * result)"
.PP
Place the public key associated with the params into result buffer, and its digest into digest_result. This is for one of our signing keys, not just any key. Result buffers may be NULL if the corresponding result is not wanted.
.PP
\fBReturns:\fP
.RS 4
0 for success, negative for error 
.RE
.PP

.PP
Definition at line 2547 of file ccn_client.c.
.PP
Referenced by ccnd_init_service_ccnb(), ccnr_init_policy_cob(), ccnr_init_policy_link_cob(), and ccnr_init_service_ccnb().
.SS "int ccn_geterror (struct ccn * h)"
.PP
Recover last error code. \fBParameters:\fP
.RS 4
\fIh\fP is the ccn handle - may be NULL. 
.RE
.PP
\fBReturns:\fP
.RS 4
the most recently set error code, or 0 if h is NULL. 
.RE
.PP

.PP
Definition at line 212 of file ccn_client.c.
.SS "int ccn_guest_prefix (struct ccn * h, struct \fBccn_charbuf\fP * result, int ms)"
.PP
Ask upstream for a guest prefix that will be routed to us. On success, the prefix is placed into result, in the form of a uri. ms is the maximum time to wait for an answer.
.PP
\fBReturns:\fP
.RS 4
is 0 for success, or -1 for failure. 
.RE
.PP

.PP
Definition at line 2985 of file ccn_client.c.
.PP
Referenced by main().
.SS "intmax_t ccn_interest_lifetime (const unsigned char * msg, const struct \fBccn_parsed_interest\fP * pi)"\fBReturns:\fP
.RS 4
the lifetime of the interest in units of 2**(-12) seconds (the same units as timestamps). 
.RE
.PP

.PP
Definition at line 32 of file ccn_interest.c.
.PP
Referenced by ccn_construct_interest(), ccn_interest_lifetime_seconds(), ccnd_debug_ccnb(), main(), propagate_interest(), and toss_in_pit().
.SS "int ccn_interest_lifetime_seconds (const unsigned char * msg, const struct \fBccn_parsed_interest\fP * pi)"\fBReturns:\fP
.RS 4
the lifetime of the interest in units of seconds; any fractional part is truncated. Not useful for short-lived interests. 
.RE
.PP

.PP
Definition at line 56 of file ccn_interest.c.
.PP
Referenced by main(), and r_proto_begin_enumeration().
.SS "int ccn_is_final_block (struct \fBccn_upcall_info\fP * info)"
.PP
Check whether content described by info is final block. \fBParameters:\fP
.RS 4
\fIinfo\fP - the \fBccn_upcall_info\fP describing the ContentObject 
.RE
.PP
\fBReturns:\fP
.RS 4
1 for final block, 0 for not final, -1 if an error occurs 
.RE
.PP

.PP
Definition at line 2932 of file ccn_client.c.
.PP
Referenced by r_proto_expect_content().
.SS "int ccn_is_final_pco (const unsigned char * ccnb, struct \fBccn_parsed_ContentObject\fP * pco, struct \fBccn_indexbuf\fP * comps)"
.PP
Given a ccnb encoded content object, the parsed form, and name components report whether this is the last (FinalBlockID) segment of a stream. \fBParameters:\fP
.RS 4
\fIccnb\fP - a ccnb encoded content object 
.br
\fIpco\fP - the parsed content object 
.br
\fIcomps\fP - an indexbuf locating the components of the name 
.RE
.PP
\fBReturns:\fP
.RS 4
1 for final block, 0 for not final, or -1 for error. 
.RE
.PP

.PP
Definition at line 2946 of file ccn_client.c.
.PP
Referenced by ccn_is_final_block(), load_policy(), and r_proto_policy_update().
.SS "int ccn_load_default_key (struct ccn * h, const char * keystore_path, const char * keystore_passphrase)"
.PP
Load the handle's default signing key from a keystore. This call is only required for applications that use something other than the user's default signing key as the handle's default. It should be called early and at most once. 
.PP
\fBParameters:\fP
.RS 4
\fIh\fP is the ccn handle 
.br
\fIkeystore_path\fP is the pathname of the keystore file 
.br
\fIkeystore_passphrase\fP is the passphase needed to unlock the keystore 
.RE
.PP
\fBReturns:\fP
.RS 4
is 0 for success, negative for error. 
.RE
.PP

.PP
Definition at line 2507 of file ccn_client.c.
.PP
Referenced by ccnd_init_internal_keystore(), and ccnr_init_repo_keystore().
.SS "int ccn_load_private_key (struct ccn * h, const char * keystore_path, const char * keystore_passphrase, struct \fBccn_charbuf\fP * pubid_out)"
.PP
Load a private key from a keystore file. This call is only required for applications that use something other than the user's default signing key. 
.PP
\fBParameters:\fP
.RS 4
\fIh\fP is the ccn handle 
.br
\fIkeystore_path\fP is the pathname of the keystore file 
.br
\fIkeystore_passphrase\fP is the passphase needed to unlock the keystore 
.br
\fIpubid_out,if\fP not NULL, is loaded with the digest of the public key 
.RE
.PP
\fBReturns:\fP
.RS 4
is 0 for success, negative for error. 
.RE
.PP

.PP
Definition at line 2442 of file ccn_client.c.
.PP
Referenced by ccn_load_default_key(), and ccn_load_or_create_key().
.SS "int ccn_name_append (struct \fBccn_charbuf\fP * c, const void * component, size_t n)"
.PP
Add a Component to a Name. The component is an arbitrary string of n octets, no escaping required. 
.PP
\fBReturns:\fP
.RS 4
0, or -1 for error. 
.RE
.PP

.PP
Definition at line 50 of file ccn_name_util.c.
.PP
Referenced by add_cob_exclusion(), add_info_exclusion(), append_adjacency_uri(), appendComponents(), ccn_get_header(), ccn_guest_prefix(), ccn_initiate_prefix_reg(), ccn_name_append_flatname(), ccn_name_append_nonce(), ccn_name_append_numeric(), ccn_name_append_str(), ccn_name_from_uri(), ccn_name_next_sibling(), ccn_resolve_version(), ccnd_adjacency_offer_or_commit_req(), ccnd_init_face_guid_cob(), ccnd_init_service_ccnb(), ccnd_reg_ccnx_ccndid(), ccnd_req_guest(), ccnd_start_notice(), ccndc_do_face_action(), ccndc_do_prefix_action(), ccnr_init_policy_link_cob(), ccnr_init_service_ccnb(), ccns_open(), ccns_slice_name(), constructCommandPrefix(), express_bulkdata_interest(), incoming_content(), main(), my_get(), r_proto_begin_enumeration(), r_store_next_child_at_level(), SendDeltasReply(), sendSlice(), sequenced_name(), start_interest(), start_node_fetch(), storeHandler(), SyncAppendAllComponents(), SyncAppendElementInner(), SyncAppendRandomName(), SyncConstructCommandPrefix(), SyncExclusionsFromHashList(), SyncInterestArrived(), SyncNameForIndexbuf(), SyncNameForLocalNode(), SyncSendRootAdviseInterest(), and SyncStartNodeFetch().
.SS "int ccn_name_append_components (struct \fBccn_charbuf\fP * c, const unsigned char * ccnb, size_t start, size_t stop)"
.PP
Add sequence of ccnb-encoded Components to a ccnb-encoded Name. start and stop are offsets from ccnb 
.PP
\fBReturns:\fP
.RS 4
0, or -1 for obvious error 
.RE
.PP

.PP
Definition at line 131 of file ccn_name_util.c.
.PP
Referenced by age_forwarding(), ccn_initiate_prefix_reg(), ccnd_reg_prefix(), collect_forwarding_html(), collect_forwarding_xml(), incoming_content(), next_child_at_level(), r_proto_append_repo_info(), r_proto_begin_enumeration(), r_proto_bulk_import(), r_proto_continue_enumeration(), r_proto_expect_content(), r_proto_policy_complete(), r_proto_start_write(), and r_proto_start_write_checked().
.SS "int ccn_name_append_nonce (struct \fBccn_charbuf\fP * c)"
.PP
Add nonce Component to ccnb-encoded Name. Uses C1.N namespace. 
.PP
\fBReturns:\fP
.RS 4
0, or -1 for error see doc/technical/NameConventions.html 
.RE
.PP

.PP
Definition at line 114 of file ccn_name_util.c.
.PP
Referenced by localStore(), main(), putFile(), putFileList(), and write_slice().
.SS "int ccn_name_append_numeric (struct \fBccn_charbuf\fP * c, enum \fBccn_marker\fP marker, uintmax_t value)"
.PP
Add a binary Component to a ccnb-encoded Name. These are special components used for marking versions, fragments, etc. 
.PP
\fBReturns:\fP
.RS 4
0, or -1 for error see doc/technical/NameConventions.html 
.RE
.PP

.PP
Definition at line 90 of file ccn_name_util.c.
.PP
Referenced by ccns_delete_slice(), ccns_write_slice(), generate_cob(), incoming_content(), load_policy(), localStore(), main(), r_proto_continue_enumeration(), r_proto_expect_content(), r_proto_policy_update(), r_proto_start_write(), SendDeltasReply(), sequenced_name(), seqw_next_cob(), storeHandler(), SyncCacheEntryStore(), and SyncInterestArrived().
.SS "int ccn_name_append_str (struct \fBccn_charbuf\fP * c, const char * s)"
.PP
Add a Component that is a NUL-terminated string. The component added consists of the bytes of the string without the NUL. This function is convenient for those applications that construct component names from simple strings. 
.PP
\fBReturns:\fP
.RS 4
0, or -1 for error. 
.RE
.PP

.PP
Definition at line 77 of file ccn_name_util.c.
.PP
Referenced by ccn_get_header(), ccn_initiate_prefix_reg(), ccnd_start_notice(), ccndc_do_face_action(), ccndc_do_prefix_action(), ccns_open(), constructCommandPrefix(), encode_message(), existingRootOp(), main(), my_get(), putFileList(), SendDeltasReply(), sendSlice(), start_interest(), SyncConstructCommandPrefix(), and SyncNameForLocalNode().
.SS "int ccn_name_chop (struct \fBccn_charbuf\fP * c, struct \fBccn_indexbuf\fP * components, int n)"
.PP
Chop the name down to n components. \fBParameters:\fP
.RS 4
\fIc\fP contains a ccnb-encoded Name 
.br
\fIcomponents\fP may be NULL; if provided it must be consistent with some prefix of the name, and is updated accordingly. 
.br
\fIn\fP is the number or components to leave, or, if negative, specifies how many components to remove, e.g. -1 will remove just the last component. 
.RE
.PP
\fBReturns:\fP
.RS 4
-1 for error, otherwise the new number of Components 
.RE
.PP

.PP
Definition at line 226 of file ccn_name_util.c.
.PP
Referenced by adjust_regprefix(), ccn_name_chop(), ccn_name_next_sibling(), load_policy(), main(), r_proto_policy_update(), and write_slice().
.SS "int ccn_name_comp_get (const unsigned char * data, const struct \fBccn_indexbuf\fP * indexbuf, unsigned int i, const unsigned char ** comp, size_t * size)"
.PP
Extract a pointer to and size of component at given index i. The first component is index 0. 
.PP
\fBReturns:\fP
.RS 4
0, or -1 for error. 
.RE
.PP

.PP
Definition at line 152 of file ccn_name_util.c.
.PP
Referenced by advise_interest_arrived(), ccn_name_comp_strcmp(), ccn_resolve_version(), ccn_sign_content(), ccnd_answer_by_guid(), ccnd_answer_req(), ccnd_req_guest(), ccnd_uri_listen(), ccnr_answer_req(), ccnr_uri_listen(), check_offer_matches_my_solicit(), load_policy(), name_comp_equal_prefix(), r_proto_bulk_import(), r_proto_check_exclude(), r_proto_policy_complete(), r_util_name_comp_compare(), SyncInterestArrived(), SyncNameForIndexbuf(), and SyncRootAdviseResponse().
.SS "int ccn_name_comp_strcmp (const unsigned char * data, const struct \fBccn_indexbuf\fP * indexbuf, unsigned int i, const char * val)"
.PP
Definition at line 182 of file ccn_name_util.c.
.PP
Referenced by decode_message().
.SS "int ccn_name_init (struct \fBccn_charbuf\fP * c)"
.PP
Reset charbuf to represent an empty Name in binary format. \fBReturns:\fP
.RS 4
0, or -1 for error. 
.RE
.PP

.PP
Definition at line 33 of file ccn_name_util.c.
.PP
Referenced by add_cob_exclusion(), add_info_exclusion(), age_forwarding(), appendName(), ccn_initiate_prefix_reg(), ccn_name_from_uri(), ccn_uri_append_flatname(), ccnd_reg_prefix(), ccnd_reg_uri(), ccndc_do_face_action(), ccndc_do_prefix_action(), ccndc_initialize_data(), ccns_slice_create(), collect_forwarding_html(), collect_forwarding_xml(), constructCommandPrefix(), encode_message(), existingRootOp(), incoming_content(), main(), next_child_at_level(), putFileList(), r_match_match_interests(), r_proto_append_repo_info(), r_proto_begin_enumeration(), r_proto_bulk_import(), r_proto_continue_enumeration(), r_proto_expect_content(), r_proto_policy_complete(), r_proto_start_write(), r_proto_start_write_checked(), r_store_next_child_at_level(), r_sync_notify_content(), sendSlice(), stuff_link_check(), SyncConstructCommandPrefix(), SyncExclusionsFromHashList(), SyncNameForIndexbuf(), SyncNameForLocalNode(), and test_flatname().
.SS "int ccn_name_next_sibling (struct \fBccn_charbuf\fP * c)"
.PP
Advance the last Component of a Name to the next possible value. \fBParameters:\fP
.RS 4
\fIc\fP contains a ccnb-encoded Name to be updated. 
.RE
.PP
\fBReturns:\fP
.RS 4
-1 for error, otherwise the number of Components 
.RE
.PP

.PP
Definition at line 262 of file ccn_name_util.c.
.PP
Referenced by main(), next_child_at_level(), and r_store_next_child_at_level().
.SS "int ccn_name_split (const struct \fBccn_charbuf\fP * c, struct \fBccn_indexbuf\fP * components)"
.PP
Find Component boundaries in a ccnb-encoded Name. Thin veneer over \fBccn_parse_Name()\fP. components arg may be NULL to just do a validity check
.PP
\fBReturns:\fP
.RS 4
-1 for error, otherwise the number of Components. 
.RE
.PP

.PP
Definition at line 207 of file ccn_name_util.c.
.PP
Referenced by add_cob_exclusion(), ccn_create_version(), ccn_name_chop(), ccn_name_next_sibling(), ccn_resolve_version(), ccn_sign_content(), ccnd_req_prefix_or_self_reg(), ccnd_req_unreg(), ccnd_uri_listen(), ccnr_uri_listen(), load_policy(), r_match_match_interests(), and r_proto_check_exclude().
.SS "int ccn_output_is_pending (struct ccn * h)"
.PP
Definition at line 1158 of file ccn_client.c.
.PP
Referenced by ccn_grab_buffered_output(), ccn_process_scheduled_operations(), ccn_run(), and r_io_prepare_poll_fds().
.SS "int ccn_parse_Collection_next (struct \fBccn_buf_decoder\fP * d, struct \fBccn_parsed_Link\fP * link, struct \fBccn_indexbuf\fP * components)"
.PP
Definition at line 1098 of file ccn_buf_decoder.c.
.PP
Referenced by main().
.SS "int ccn_parse_Collection_start (struct \fBccn_buf_decoder\fP * d)"
.PP
Definition at line 1084 of file ccn_buf_decoder.c.
.PP
Referenced by main().
.SS "int ccn_parse_ContentObject (const unsigned char * msg, size_t size, struct \fBccn_parsed_ContentObject\fP * x, struct \fBccn_indexbuf\fP * components)"
.PP
Definition at line 814 of file ccn_buf_decoder.c.
.PP
Referenced by add_cob_exclusion(), ccn_content_matches_interest(), ccn_dispatch_message(), ccnd_answer_req(), ccnd_req_destroyface(), ccnd_req_newface(), ccnd_req_prefix_or_self_reg(), ccnd_req_unreg(), ccnr_answer_req(), decode_message(), deliver_content(), interest_handler(), load_policy(), main(), process_incoming_content(), process_test(), r_proto_policy_update(), r_store_content_field_access(), r_store_set_flatname(), start_node_fetch(), storeHandler(), SyncHandleSlice(), SyncLocalRepoFetch(), SyncPointerToContent(), and test_insert_content().
.SS "int ccn_parse_interest (const unsigned char * msg, size_t size, struct \fBccn_parsed_interest\fP * interest, struct \fBccn_indexbuf\fP * components)"
.PP
Definition at line 564 of file ccn_buf_decoder.c.
.PP
Referenced by append_interest_details(), ccn_age_interest(), ccn_construct_interest(), ccn_content_matches_interest(), ccn_dispatch_message(), ccn_parse_interest(), ccnd_debug_ccnb(), ccnr_debug_ccnb(), main(), process_incoming_interest(), propagate_interest(), r_lookup(), r_proto_begin_enumeration(), r_proto_start_write_checked(), testhelp_count_matches(), and update_npe_children().
.SS "int ccn_parse_Link (struct \fBccn_buf_decoder\fP * d, struct \fBccn_parsed_Link\fP * link, struct \fBccn_indexbuf\fP * components)"
.PP
Definition at line 1041 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_parse_Collection_next(), ccn_parse_Link(), load_policy(), and main().
.SS "int ccn_parse_LinkAuthenticator (struct \fBccn_buf_decoder\fP * d, struct \fBccn_parsed_Link\fP * link)"
.PP
Definition at line 982 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_parse_Link().
.SS "int ccn_parse_Name (struct \fBccn_buf_decoder\fP * d, struct \fBccn_indexbuf\fP * components)"
.PP
Parses a ccnb-encoded name. \fBParameters:\fP
.RS 4
\fId\fP is the decoder 
.br
\fIcomponents\fP may be NULL, otherwise is filled in with the Component boundary offsets 
.RE
.PP
\fBReturns:\fP
.RS 4
the number of Components in the Name, or -1 if there is an error. 
.RE
.PP

.PP
Definition at line 288 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_append_link_name(), ccn_forwarding_entry_parse(), ccn_name_split(), ccn_parse_ContentObject(), ccn_parse_interest(), ccn_parse_KeyName(), ccn_parse_Link(), ccnd_reg_uri(), r_proto_initiate_key_fetch(), and slice_parse().
.SS "int ccn_parse_nonNegativeInteger (struct \fBccn_buf_decoder\fP * d)"
.PP
Definition at line 389 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_fetch_tagged_nonNegativeInteger(), ccn_parse_optional_tagged_nonNegativeInteger(), and slice_parse().
.SS "uintmax_t ccn_parse_optional_tagged_binary_number (struct \fBccn_buf_decoder\fP * d, enum \fBccn_dtag\fP dtag, int minlen, int maxlen, uintmax_t default_value)"
.PP
Definition at line 204 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_interest_lifetime(), ccn_parse_LinkAuthenticator(), and ccn_parse_SignedInfo().
.SS "int ccn_parse_optional_tagged_BLOB (struct \fBccn_buf_decoder\fP * d, enum \fBccn_dtag\fP dtag, int minlen, int maxlen)"
.PP
Definition at line 167 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_chk_signing_params(), ccn_parse_interest(), ccn_parse_LinkAuthenticator(), ccn_parse_optional_Any_or_Bloom(), ccn_parse_Signature(), and ccn_parse_SignedInfo().
.SS "int ccn_parse_optional_tagged_nonNegativeInteger (struct \fBccn_buf_decoder\fP * d, enum \fBccn_dtag\fP dtag)"
.PP
Definition at line 529 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_chk_signing_params(), ccn_face_instance_parse(), ccn_forwarding_entry_parse(), ccn_parse_interest(), ccn_parse_LinkAuthenticator(), and ccn_parse_SignedInfo().
.SS "uintmax_t ccn_parse_required_tagged_binary_number (struct \fBccn_buf_decoder\fP * d, enum \fBccn_dtag\fP dtag, int minlen, int maxlen)"
.PP
Definition at line 176 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_parse_optional_tagged_binary_number(), and process_incoming_link_message().
.SS "int ccn_parse_required_tagged_BLOB (struct \fBccn_buf_decoder\fP * d, enum \fBccn_dtag\fP dtag, int minlen, int maxlen)"
.PP
Definition at line 142 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_chk_signing_params(), ccn_parse_ContentObject(), ccn_parse_Exclude(), ccn_parse_optional_tagged_BLOB(), ccn_parse_Signature(), ccn_parse_SignedInfo(), extract_bounds(), and SyncParseHash().
.SS "int ccn_parse_tagged_string (struct \fBccn_buf_decoder\fP * d, enum \fBccn_dtag\fP dtag, struct \fBccn_charbuf\fP * store)"
.PP
Parses a ccnb-encoded element expected to contain a UDATA string. \fBParameters:\fP
.RS 4
\fId\fP is the decoder 
.br
\fIdtag\fP is the expected dtag value 
.br
\fIstore\fP - on success, the string value is appended to store, with null termination. 
.RE
.PP
\fBReturns:\fP
.RS 4
the offset into the store buffer of the copied value, or -1 for error. If a parse error occurs, d->decoder.state is set to a negative value. If the element is not present, -1 is returned but no parse error is indicated. 
.RE
.PP

.PP
Definition at line 253 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_face_instance_parse(), ccn_forwarding_entry_parse(), and r_proto_parse_policy().
.SS "int ccn_parse_uintmax (struct \fBccn_buf_decoder\fP * d, uintmax_t * result)"
.PP
Parse a potentially large non-negative integer. \fBReturns:\fP
.RS 4
0 for success, and the value is place in *result; for an error a negative value is returned and *result is unchanged. 
.RE
.PP

.PP
Definition at line 433 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_parse_tagged_required_uintmax(), slice_parse(), and SyncParseUnsigned().
.SS "void ccn_perror (struct ccn * h, const char * s)"
.PP
Produce message on standard error output describing the last error encountered during a call using the given handle. \fBParameters:\fP
.RS 4
\fIh\fP is the ccn handle - may not be NULL. 
.br
\fIs\fP is a client-supplied message; if NULL a message will be supplied where available. 
.RE
.PP

.PP
Definition at line 166 of file ccn_client.c.
.PP
Referenced by ccn_create(), ccn_note_err(), ccn_resolve_version(), and main().
.SS "int ccn_put (struct ccn * h, const void * p, size_t length)"
.PP
Definition at line 1114 of file ccn_client.c.
.PP
Referenced by ccn_refresh_interest(), ccn_seqw_write(), ccnd_answer_by_guid(), ccnd_answer_req(), ccnd_req_guest(), ccnr_answer_req(), incoming_adjacency(), incoming_interest(), interest_handler(), localStore(), main(), outgoing_content(), r_io_send(), r_proto_begin_enumeration(), r_proto_bulk_import(), r_proto_continue_enumeration(), r_proto_start_write(), r_proto_start_write_checked(), send_matching_data(), SendDeltasReply(), seqw_incoming_interest(), storeHandler(), SyncInterestArrived(), and write_interest_handler().
.SS "int ccn_ref_tagged_BLOB (enum \fBccn_dtag\fP tt, const unsigned char * buf, size_t start, size_t stop, const unsigned char ** presult, size_t * psize)"
.PP
Definition at line 849 of file ccn_buf_decoder.c.
.PP
Referenced by add_cob_exclusion(), add_info_exclusion(), ccn_btree_insert_content(), ccn_btree_match_interest(), ccn_chk_signing_params(), ccn_content_get_value(), ccn_digest_Content(), ccn_initiate_key_fetch(), ccn_is_final_pco(), ccn_locate_key(), ccn_name_next_sibling(), ccn_verify_signature(), ccnd_debug_ccnb(), ccndc_get_ccnd_id(), ccnr_debug_ccnb(), display_the_content(), extract_bounds(), GetNumberFromInfo(), handle_ccndid_response(), incoming_content(), incoming_interest(), is_final(), load_policy(), main(), propagate_interest(), r_proto_policy_update(), r_store_content_field_access(), r_util_segment_from_component(), and segFromInfo().
.SS "int ccn_ref_tagged_string (enum \fBccn_dtag\fP dtag, const unsigned char * buf, size_t start, size_t stop, const unsigned char ** presult, size_t * psize)"
.PP
Produce a pointer and length for the string in a ccnb-encoded tagged element containing a UDATA string. \fBParameters:\fP
.RS 4
\fIdtag\fP is the expected dtag value 
.br
\fIbuf\fP is a ccnb-encoded source. 
.br
\fIstart\fP is an offset into buf at which the element starts 
.br
\fIstop\fP is an offset into buf where the element ends 
.br
\fIpresult\fP if non-NULL, a pointer through which pointer into buf for start of string will be stored 
.br
\fIpsize\fP if non-NULL, a pointer through which size of string will be stored. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success, <0 on failure. 
.RE
.PP

.PP
Definition at line 883 of file ccn_buf_decoder.c.
.PP
Referenced by ccn_verify_signature().
.SS "int ccn_resolve_version (struct ccn * h, struct \fBccn_charbuf\fP * name, int versioning_flags, int timeout_ms)"
.PP
Resolve the version, based on existing ccn content. \fBParameters:\fP
.RS 4
\fIh\fP is the the ccn handle; it may be NULL, but it is preferable to use the handle that the client probably already has. 
.br
\fIname\fP is a ccnb-encoded Name prefix. It gets extended in-place with one additional Component such that it names highest extant version that can be found, subject to the supplied timeout. 
.br
\fIversioning_flags\fP presently must be CCN_V_HIGH or CCN_V_HIGHEST, possibly combined with CCN_V_NESTOK. If CCN_V_NESTOK is not present and the ending component appears to be a version, the routine returns 0 immediately, on the assumption that an explicit version has already been provided. 
.br
\fItimeout_ms\fP is a time value in milliseconds. This is the total time that the caller can wait. 
.RE
.PP
\fBReturns:\fP
.RS 4
-1 for error, 0 if name was not extended, 1 if was. 
.RE
.PP

.PP
Definition at line 139 of file ccn_versioning.c.
.PP
Referenced by ccn_fetch_open(), ccn_get_header(), ccn_guest_prefix(), ccns_read_slice(), getFile(), and main().
.SS "int ccn_run (struct ccn * h, int timeout)"
.PP
Run the ccn client event loop. This may serve as the main event loop for simple apps by passing a timeout value of -1. 
.PP
\fBParameters:\fP
.RS 4
\fIh\fP is the ccn handle. 
.br
\fItimeout\fP is in milliseconds. 
.RE
.PP
\fBReturns:\fP
.RS 4
a negative value for error, zero for success. 
.RE
.PP

.PP
Definition at line 2004 of file ccn_client.c.
.PP
Referenced by ccn_dump_names(), ccn_fetch_poll(), ccn_get(), ccn_guest_prefix(), ccndc_daemonize(), chat_main(), getFile(), main(), putFile(), putFileList(), r_dispatch_process_input(), r_link_do_deferred_write(), and write_slice().
.SS "int ccn_set_interest_filter (struct ccn * h, struct \fBccn_charbuf\fP * namebuf, struct \fBccn_closure\fP * action)"
.PP
Register to receive interests on a prefix. The action will be called upon the arrival of an interest that has the given name as a prefix.
.PP
If action is NULL, any existing filter for the prefix is removed. Note that this may have undesirable effects in applications that share the same handle for independently operating subcomponents. See \fBccn_set_interest_filter_with_flags()\fP for a way to deal with this.
.PP
The contents of namebuf are copied as needed.
.PP
The handler should return CCN_UPCALL_RESULT_INTEREST_CONSUMED as a promise that it has produced, or will soon produce, a matching content object.
.PP
The upcall kind passed to the handler will be CCN_UPCALL_INTEREST if no other handler has claimed to produce content, or else CCN_UPCALL_CONSUMED_INTEREST.
.PP
This call is equivalent to a call to ccn_set_interest_filter_with_flags, passing the forwarding flags (CCN_FORW_ACTIVE | CCN_FORW_CHILD_INHERIT).
.PP
\fBReturns:\fP
.RS 4
-1 in case of error, non-negative for success. 
.RE
.PP

.PP
Definition at line 845 of file ccn_client.c.
.PP
Referenced by ccn_seqw_close(), ccn_seqw_create(), ccnd_uri_listen(), ccnr_uri_listen(), ccns_open(), chat_main(), main(), putFile(), r_proto_uri_listen(), SyncRegisterInterest(), and write_slice().
.SS "int ccn_set_interest_filter_with_flags (struct ccn * h, struct \fBccn_charbuf\fP * namebuf, struct \fBccn_closure\fP * action, int forw_flags)"
.PP
Register to receive interests on a prefix, with forwarding flags. See ccn_set_interest_filter for a description of the basic operation.
.PP
The additional forw_flags argument offers finer control of which interests are forward to the application. Refer to doc/technical/Registration for details.
.PP
There may be multiple actions associated with the prefix. They will be called in an unspecified order. The flags passed to ccnd will be the inclusive-or of the flags associated with each action.
.PP
Passing a value of 0 for forw_flags will unregister just this specific action, leaving other actions untouched.
.PP
\fBReturns:\fP
.RS 4
-1 in case of error, non-negative for success. 
.RE
.PP

.PP
Definition at line 783 of file ccn_client.c.
.PP
Referenced by ccn_set_interest_filter(), ccndc_daemonize(), ccns_close(), and main().
.SS "int ccn_set_run_timeout (struct ccn * h, int timeout)"
.PP
Modify ccn_run timeout. This may be called from an upcall to change the timeout value. Most often this will be used to set the timeout to zero so that \fBccn_run()\fP will return control to the client. 
.PP
\fBParameters:\fP
.RS 4
\fIh\fP is the ccn handle. 
.br
\fItimeout\fP is in milliseconds. 
.RE
.PP
\fBReturns:\fP
.RS 4
old timeout value. 
.RE
.PP

.PP
Definition at line 1988 of file ccn_client.c.
.PP
Referenced by CallMe(), handle_simple_incoming_content(), incoming_content(), incoming_interest(), and write_interest_handler().
.SS "int ccn_seterror (struct ccn * h, int error_code)"
.PP
Set the error code in a ccn handle. \fBParameters:\fP
.RS 4
\fIh\fP is the ccn handle - may be NULL. 
.br
\fIerror_code\fP is the code to set. 
.RE
.PP
\fBReturns:\fP
.RS 4
-1 in all cases. 
.RE
.PP

.PP
Definition at line 195 of file ccn_client.c.
.PP
Referenced by ccn_resolve_version(), and ccn_seqw_write().
.SS "int ccn_sign_content (struct ccn * h, struct \fBccn_charbuf\fP * resultbuf, const struct \fBccn_charbuf\fP * name_prefix, const struct \fBccn_signing_params\fP * params, const void * data, size_t size)"
.PP
Create a signed ContentObject. \fBParameters:\fP
.RS 4
\fIh\fP is the ccn handle 
.br
\fIresultbuf\fP - result buffer to which the ContentObject will be appended 
.br
\fIname_prefix\fP contains the ccnb-encoded name 
.br
\fIparams\fP describe the ancillary information needed 
.br
\fIdata\fP points to the raw content 
.br
\fIsize\fP is the size of the raw content, in bytes 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success, -1 for error 
.RE
.PP

.PP
Definition at line 2830 of file ccn_client.c.
.PP
Referenced by ccn_initiate_prefix_reg(), ccnd_answer_req(), ccnd_init_face_guid_cob(), ccnd_init_service_ccnb(), ccnd_req_guest(), ccndc_do_face_action(), ccndc_do_prefix_action(), ccnr_answer_req(), ccnr_init_policy_cob(), ccnr_init_policy_link_cob(), ccnr_init_service_ccnb(), generate_cob(), localStore(), main(), r_proto_bulk_import(), r_proto_continue_enumeration(), r_proto_start_write(), r_proto_start_write_checked(), seqw_next_cob(), storeHandler(), SyncSignBuf(), and write_slice().
.SS "int ccn_signed_info_create (struct \fBccn_charbuf\fP * c, const void * publisher_key_id, size_t publisher_key_id_size, const struct \fBccn_charbuf\fP * timestamp, enum \fBccn_content_type\fP type, int freshness, const struct \fBccn_charbuf\fP * finalblockid, const struct \fBccn_charbuf\fP * key_locator)"
.PP
Create SignedInfo. \fBParameters:\fP
.RS 4
\fIc\fP is used to hold the result. 
.br
\fIpublisher_key_id\fP points to the digest of the publisher key id. 
.br
\fIpublisher_key_id_size\fP is the size in bytes(32) of the pub key digest 
.br
\fItimestamp\fP holds the timestamp, as a ccnb-encoded blob, or is NULL to use the current time. 
.br
\fItype\fP indicates the Type of the ContentObject. 
.br
\fIfreshness\fP is the FreshnessSeconds value, or -1 to omit. 
.br
\fIfinalblockid\fP holds the FinalBlockID, as a ccnb-encoded blob, or is NULL to omit. 
.br
\fIkey_locator\fP is the ccnb-encoded KeyLocator element, or NULL to omit. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success or -1 for error. 
.RE
.PP

.PP
Definition at line 49 of file ccn_buf_encoder.c.
.PP
Referenced by ccn_sign_content(), and main().
.SS "int ccn_verify_content (struct ccn * h, const unsigned char * msg, struct \fBccn_parsed_ContentObject\fP * pco)"
.PP
Verify a ContentObject using the public key from either the object itself or our cache of keys. This routine does not attempt to fetch the public key if it is not at hand. 
.PP
\fBReturns:\fP
.RS 4
negative for error, 0 verification success, or 1 if the key needs to be requested. 
.RE
.PP

.PP
Definition at line 2413 of file ccn_client.c.
.PP
Referenced by ccnd_answer_req(), ccnr_answer_req(), handle_ccndid_response(), handle_prefix_reg_reply(), and SyncLocalRepoFetch().
.SS "int ccnb_append_Link (struct \fBccn_charbuf\fP * buf, const struct \fBccn_charbuf\fP * name, const char * label, const struct \fBccn_charbuf\fP * linkAuthenticator)"
.PP
Append a representation of a Link to a charbuf. \fBParameters:\fP
.RS 4
\fIbuf\fP is the output buffer where encoded link is written. 
.br
\fIname\fP is the ccnb-encoded name from ccn_name_init and friends. 
.br
\fIlabel\fP is a UTF-8 string in a \fBccn_charbuf\fP. 
.br
\fIlinkAuthenticator\fP is the ccnb-encoded LinkAuthenticator. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success or -1 for error. 
.RE
.PP

.PP
Definition at line 495 of file ccn_buf_encoder.c.
.PP
Referenced by ccnr_init_policy_link_cob(), and main().
.SS "int ccnb_append_now_blob (struct \fBccn_charbuf\fP * c, enum \fBccn_marker\fP marker)"
.PP
Append a binary timestamp, using the current time. Like \fBccnb_append_timestamp_blob()\fP but uses current time 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP is the buffer to append to. 
.br
\fImarker\fP - see \fBccnb_append_timestamp_blob()\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success or -1 for error. 
.RE
.PP

.PP
Definition at line 356 of file ccn_buf_encoder.c.
.PP
Referenced by ccn_create_version(), and ccn_signed_info_create().
.SS "int ccnb_append_number (struct \fBccn_charbuf\fP * c, int nni)"
.PP
Append a non-negative integer as a UDATA. \fBParameters:\fP
.RS 4
\fIc\fP is the buffer to append to. 
.br
\fInni\fP is a non-negative value. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success or -1 for error. 
.RE
.PP

.PP
Definition at line 289 of file ccn_buf_encoder.c.
.PP
Referenced by main(), make_data_template(), and make_template().
.SS "int ccnb_append_tagged_binary_number (struct \fBccn_charbuf\fP * cb, enum \fBccn_dtag\fP dtag, uintmax_t val)"
.PP
Append a tagged binary number as a blob containing the integer value. This is a ccnb-encoded element holding a 
.PP
\fBParameters:\fP
.RS 4
\fIcb\fP is the buffer to append to. 
.br
\fIdtag\fP is the element's dtab 
.br
\fIval\fP is the unsigned integer to be appended 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success or -1 for error. 
.RE
.PP

.PP
Definition at line 421 of file ccn_buf_encoder.c.
.PP
Referenced by resolve_templ(), and send_interest().
.SS "int ccnb_append_tagged_blob (struct \fBccn_charbuf\fP * c, enum \fBccn_dtag\fP dtag, const void * data, size_t size)"
.PP
Append a tagged BLOB. This is a ccnb-encoded element with containing the BLOB as content 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP is the buffer to append to. 
.br
\fIdtag\fP is the element's dtab 
.br
\fIdata\fP points to the binary data 
.br
\fIsize\fP is the size of the data, in bytes 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success or -1 for error. 
.RE
.PP

.PP
Definition at line 396 of file ccn_buf_encoder.c.
.PP
Referenced by appendExclusions(), appendLifetime(), ccn_encode_ContentObject(), ccnb_append_face_instance(), ccnb_append_forwarding_entry(), ccnb_append_header(), ccnb_append_tagged_binary_number(), ccnd_adjacency_offer_or_commit_req(), main(), putFile(), send_adjacency_solicit(), send_interest(), SyncAppendElementInner(), and SyncNodeAppendLongHash().
.SS "int ccnb_append_timestamp_blob (struct \fBccn_charbuf\fP * c, enum \fBccn_marker\fP marker, intmax_t secs, int nsecs)"
.PP
Append a binary timestamp as a BLOB using the ccn binary Timestamp representation (12-bit fraction). \fBParameters:\fP
.RS 4
\fIc\fP is the buffer to append to. 
.br
\fImarker\fP If marker >= 0, the low-order byte is used as a marker byte, useful for some content naming conventions (versioning, in particular). 
.br
\fIsecs\fP - seconds since epoch 
.br
\fInsecs\fP - nanoseconds 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success or -1 for error. 
.RE
.PP

.PP
Definition at line 317 of file ccn_buf_encoder.c.
.PP
Referenced by ccn_create_version(), and ccnb_append_now_blob().
.SS "int ccnb_element_begin (struct \fBccn_charbuf\fP * c, enum \fBccn_dtag\fP dtag)"
.PP
Append a start-of-element marker. 
.PP
Definition at line 370 of file ccn_buf_encoder.c.
.PP
Referenced by append_slice(), ccnb_append_face_instance(), ccnb_append_forwarding_entry(), ccnb_append_header(), ccnd_adjacency_offer_or_commit_req(), ccndc_initialize_data(), main(), make_scope1_template(), NewDeltas(), putFile(), r_proto_append_repo_info(), r_proto_begin_enumeration(), r_proto_continue_enumeration(), r_proto_mktemplate(), r_proto_policy_append_basic(), r_proto_start_write_checked(), send_adjacency_solicit(), sendSlice(), SyncResetComposite(), SyncRootAppendSlice(), and testEncodeDecode().
.SS "int ccnb_element_end (struct \fBccn_charbuf\fP * c)"
.PP
Append an end-of-element marker. This is the same as \fBccn_charbuf_append_closer()\fP 
.PP
Definition at line 380 of file ccn_buf_encoder.c.
.PP
Referenced by append_slice(), ccn_append_link_stuff(), ccnb_append_face_instance(), ccnb_append_forwarding_entry(), ccnb_append_header(), ccnd_adjacency_offer_or_commit_req(), ccndc_initialize_data(), CloseUpdateCoding(), main(), make_scope1_template(), putFile(), r_proto_append_repo_info(), r_proto_begin_enumeration(), r_proto_continue_enumeration(), r_proto_mktemplate(), r_proto_policy_append_basic(), r_proto_policy_append_namespace(), r_proto_start_write_checked(), send_adjacency_solicit(), sendSlice(), SyncEndComposite(), SyncRootAppendSlice(), and testEncodeDecode().
.SS "int ccnb_tagged_putf (struct \fBccn_charbuf\fP * c, enum \fBccn_dtag\fP dtag, const char * fmt,  ...)"
.PP
Append a tagged UDATA string, with printf-style formatting. This is a ccnb-encoded element with containing UDATA as content. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP is the buffer to append to. 
.br
\fIdtag\fP is the element's dtab. 
.br
\fIfmt\fP is a printf-style format string, followed by its values 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success or -1 for error. 
.RE
.PP

.PP
Definition at line 443 of file ccn_buf_encoder.c.
.PP
Referenced by answer_highest(), answer_passive(), append_slice(), ccn_encode_StatusResponse(), ccn_guest_prefix(), ccn_initiate_key_fetch(), ccn_signed_info_create(), ccnb_append_face_instance(), ccnb_append_forwarding_entry(), ccnb_append_header(), ccnd_adjacency_offer_or_commit_req(), ccndc_initialize_data(), express_interest(), handle_key(), incoming_content(), local_scope_rm_template(), main(), make_scope1_template(), make_template(), me_too(), r_proto_append_repo_info(), r_proto_initiate_key_fetch(), r_proto_mktemplate(), r_proto_policy_append_basic(), r_proto_policy_append_namespace(), resolve_templ(), send_adjacency_solicit(), stuff_link_check(), SyncAppendTaggedNumber(), SyncGenInterest(), and SyncSignBuf().
.SH "Author"
.PP 
Generated automatically by Doxygen for Content-Centric Networking in C from the source code.

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CCNx for Android: /tilde/dkords/dev/repos/ccn-external.git/ccnx-0.7.1/csrc/ccnr/ccnr_proto.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>/tilde/dkords/dev/repos/ccn-external.git/ccnx-0.7.1/csrc/ccnr/ccnr_proto.c File Reference</h1>
<p>Part of ccnr - CCNx Repository Daemon.  
<a href="#_details">More...</a></p>
<code>#include &lt;errno.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;fcntl.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;sys/errno.h&gt;</code><br/>
<code>#include &lt;sys/stat.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;ccn/ccn.h&gt;</code><br/>
<code>#include &lt;ccn/charbuf.h&gt;</code><br/>
<code>#include &lt;ccn/ccn_private.h&gt;</code><br/>
<code>#include &lt;ccn/hashtb.h&gt;</code><br/>
<code>#include &lt;ccn/schedule.h&gt;</code><br/>
<code>#include &lt;ccn/sockaddrutil.h&gt;</code><br/>
<code>#include &lt;ccn/uri.h&gt;</code><br/>
<code>#include &lt;ccn/coding.h&gt;</code><br/>
<code>#include &lt;sync/SyncBase.h&gt;</code><br/>
<code>#include &quot;ccnr_private.h&quot;</code><br/>
<code>#include &quot;ccnr_proto.h&quot;</code><br/>
<code>#include &quot;ccnr_dispatch.h&quot;</code><br/>
<code>#include &quot;ccnr_forwarding.h&quot;</code><br/>
<code>#include &quot;ccnr_init.h&quot;</code><br/>
<code>#include &quot;ccnr_io.h&quot;</code><br/>
<code>#include &quot;ccnr_msg.h&quot;</code><br/>
<code>#include &quot;ccnr_sendq.h&quot;</code><br/>
<code>#include &quot;ccnr_store.h&quot;</code><br/>
<code>#include &quot;ccnr_sync.h&quot;</code><br/>
<code>#include &quot;ccnr_util.h&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c5ac86d3f39a8829512117348e9a0fc"></a><!-- doxytag: member="ccnr_proto.c::CCNR_MAX_RETRY" ref="a5c5ac86d3f39a8829512117348e9a0fc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CCNR_MAX_RETRY</b>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8447991c4b9e95c2aa118c84f83d168"></a><!-- doxytag: member="ccnr_proto.c::ENUMERATION_STATE_TICK_MICROSEC" ref="ab8447991c4b9e95c2aa118c84f83d168" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>ENUMERATION_STATE_TICK_MICROSEC</b>&nbsp;&nbsp;&nbsp;1000000</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09cb147151d02fa0624317f58188fd10"></a><!-- doxytag: member="ccnr_proto.c::r_proto_start_write" ref="a09cb147151d02fa0624317f58188fd10" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)" -->
static enum ccn_upcall_res&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_start_write</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a430cf7f7832e08280285d33c6f393cb9"></a><!-- doxytag: member="ccnr_proto.c::r_proto_start_write_checked" ref="a430cf7f7832e08280285d33c6f393cb9" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)" -->
static enum ccn_upcall_res&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_start_write_checked</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8131ce5b8fa912cef71a628be6aab86b"></a><!-- doxytag: member="ccnr_proto.c::r_proto_begin_enumeration" ref="a8131ce5b8fa912cef71a628be6aab86b" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)" -->
static enum ccn_upcall_res&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_begin_enumeration</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cfb05cf8d7caa123adabe59f4cab40c"></a><!-- doxytag: member="ccnr_proto.c::r_proto_continue_enumeration" ref="a3cfb05cf8d7caa123adabe59f4cab40c" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)" -->
static enum ccn_upcall_res&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_continue_enumeration</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a563189db2b1adcbad622696782ac0440"></a><!-- doxytag: member="ccnr_proto.c::r_proto_bulk_import" ref="a563189db2b1adcbad622696782ac0440" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)" -->
static enum ccn_upcall_res&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_bulk_import</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info, int marker_comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a70fd987b1e084846de60266cd3c017c3">name_comp_equal_prefix</a> (const unsigned char *data, const struct ccn_indexbuf *indexbuf, unsigned int i, const void *buf, size_t length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare a name component at index i to bytes in buf and return 1 if they are equal in the first length bytes.  <a href="#a70fd987b1e084846de60266cd3c017c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2a5c89c02c02862fa60865cfd1b218e"></a><!-- doxytag: member="ccnr_proto.c::r_proto_answer_req" ref="ad2a5c89c02c02862fa60865cfd1b218e" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info)" -->
PUBLIC enum ccn_upcall_res&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_answer_req</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee367dfd2b8af67d21bcc3ece4db5b06"></a><!-- doxytag: member="ccnr_proto.c::r_proto_uri_listen" ref="aee367dfd2b8af67d21bcc3ece4db5b06" args="(struct ccnr_handle *ccnr, struct ccn *ccn, const char *uri, ccn_handler p, intptr_t intdata)" -->
PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_uri_listen</b> (struct ccnr_handle *ccnr, struct ccn *ccn, const char *uri, ccn_handler p, intptr_t intdata)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abef394d94d4306260f1355204eadfb12"></a><!-- doxytag: member="ccnr_proto.c::r_proto_init" ref="abef394d94d4306260f1355204eadfb12" args="(struct ccnr_handle *ccnr)" -->
PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_init</b> (struct ccnr_handle *ccnr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a10e1f366d8ac499821f7dd09b777e9d0">r_proto_activate_policy</a> (struct ccnr_handle *ccnr, struct ccnr_parsed_policy *pp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install the listener for the namespaces that the parsed policy says to serve.  <a href="#a10e1f366d8ac499821f7dd09b777e9d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85c77667b1ec23d0940fdc72ae10c377"></a><!-- doxytag: member="ccnr_proto.c::r_proto_deactivate_policy" ref="a85c77667b1ec23d0940fdc72ae10c377" args="(struct ccnr_handle *ccnr, struct ccnr_parsed_policy *pp)" -->
PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a85c77667b1ec23d0940fdc72ae10c377">r_proto_deactivate_policy</a> (struct ccnr_handle *ccnr, struct ccnr_parsed_policy *pp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Uninstall the listener for the namespaces that the parsed policy says to serve. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b4a35b4d6f63e221a2238c2024ef911"></a><!-- doxytag: member="ccnr_proto.c::r_proto_append_repo_info" ref="a9b4a35b4d6f63e221a2238c2024ef911" args="(struct ccnr_handle *ccnr, struct ccn_charbuf *rinfo, struct ccn_charbuf *names, const char *info)" -->
PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a9b4a35b4d6f63e221a2238c2024ef911">r_proto_append_repo_info</a> (struct ccnr_handle *ccnr, struct ccn_charbuf *rinfo, struct ccn_charbuf *names, const char *info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a charbuf with an encoding of a RepositoryInfo. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9fb0cd62eca64538e77a1682f1e25fe"></a><!-- doxytag: member="ccnr_proto.c::r_proto_mktemplate" ref="ae9fb0cd62eca64538e77a1682f1e25fe" args="(struct ccnr_expect_content *md, struct ccn_upcall_info *info)" -->
static struct ccn_charbuf *&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_mktemplate</b> (struct ccnr_expect_content *md, struct ccn_upcall_info *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7022342c3a0054757ce160533385ee77"></a><!-- doxytag: member="ccnr_proto.c::r_proto_expect_content" ref="a7022342c3a0054757ce160533385ee77" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info)" -->
PUBLIC enum ccn_upcall_res&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_expect_content</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2f1b5ff7ab1d71cf7f773d1e7ed8325"></a><!-- doxytag: member="ccnr_proto.c::r_proto_policy_update" ref="af2f1b5ff7ab1d71cf7f773d1e7ed8325" args="(struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_policy_update</b> (struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5313a2e879fe5d452edb9f41c5935fc3"></a><!-- doxytag: member="ccnr_proto.c::r_proto_policy_complete" ref="a5313a2e879fe5d452edb9f41c5935fc3" args="(struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_policy_complete</b> (struct ccn_closure *selfp, enum ccn_upcall_kind kind, struct ccn_upcall_info *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca9fa508dbede1f006cfd42bbf0f902a"></a><!-- doxytag: member="ccnr_proto.c::r_proto_check_exclude" ref="aca9fa508dbede1f006cfd42bbf0f902a" args="(struct ccnr_handle *ccnr, struct ccn_upcall_info *info, struct ccn_charbuf *name)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#aca9fa508dbede1f006cfd42bbf0f902a">r_proto_check_exclude</a> (struct ccnr_handle *ccnr, struct ccn_upcall_info *info, struct ccn_charbuf *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns 1 if the Exclude in the interest described by the info parameter would exclude the full name in name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a839f36da4f87d560b0cd5e7c21e7c83b"></a><!-- doxytag: member="ccnr_proto.c::r_proto_finalize_enum_state" ref="a839f36da4f87d560b0cd5e7c21e7c83b" args="(struct hashtb_enumerator *e)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_finalize_enum_state</b> (struct hashtb_enumerator *e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cc88e81a710eadbd5dd6399962354e4"></a><!-- doxytag: member="ccnr_proto.c::reap_enumerations" ref="a9cc88e81a710eadbd5dd6399962354e4" args="(struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a9cc88e81a710eadbd5dd6399962354e4">reap_enumerations</a> (struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove expired enumeration table entries. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e1ba0c455da37d01178bb2345ff3d44"></a><!-- doxytag: member="ccnr_proto.c::reap_enumerations_needed" ref="a1e1ba0c455da37d01178bb2345ff3d44" args="(struct ccnr_handle *ccnr)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>reap_enumerations_needed</b> (struct ccnr_handle *ccnr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae05c0877f3d803804ee2703f6c6f727"></a><!-- doxytag: member="ccnr_proto.c::r_proto_dump_enums" ref="aae05c0877f3d803804ee2703f6c6f727" args="(struct ccnr_handle *ccnr)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_dump_enums</b> (struct ccnr_handle *ccnr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03f6adb892890e069ed2de424f5f7471"></a><!-- doxytag: member="ccnr_proto.c::r_proto_policy_append_basic" ref="a03f6adb892890e069ed2de424f5f7471" args="(struct ccnr_handle *ccnr, struct ccn_charbuf *policy, const char *version, const char *local_name, const char *global_prefix)" -->
PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_policy_append_basic</b> (struct ccnr_handle *ccnr, struct ccn_charbuf *policy, const char *version, const char *local_name, const char *global_prefix)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04232b8c4b837b754c62910e924d9aaa"></a><!-- doxytag: member="ccnr_proto.c::r_proto_policy_append_namespace" ref="a04232b8c4b837b754c62910e924d9aaa" args="(struct ccnr_handle *ccnr, struct ccn_charbuf *policy, const char *namespace)" -->
PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_proto_policy_append_namespace</b> (struct ccnr_handle *ccnr, struct ccn_charbuf *policy, const char *namespace)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fd5a3888c075ae928fe02b60bba3a29"></a><!-- doxytag: member="ccnr_proto.c::r_proto_parse_policy" ref="a1fd5a3888c075ae928fe02b60bba3a29" args="(struct ccnr_handle *ccnr, const unsigned char *buf, size_t length, struct ccnr_parsed_policy *pp)" -->
PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a1fd5a3888c075ae928fe02b60bba3a29">r_proto_parse_policy</a> (struct ccnr_handle *ccnr, const unsigned char *buf, size_t length, struct ccnr_parsed_policy *pp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a ccnb-encoded policy content object and fill in a ccn_parsed_policy structure as the result. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__proto_8c.html#a22346544e87a567a668c08a4f722fe21">r_proto_initiate_key_fetch</a> (struct ccnr_handle *ccnr, const unsigned char *msg, struct ccn_parsed_ContentObject *pco, int use_link, ccnr_cookie a)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initiate a key fetch if necessary.  <a href="#a22346544e87a567a668c08a4f722fe21"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Part of ccnr - CCNx Repository Daemon. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a70fd987b1e084846de60266cd3c017c3"></a><!-- doxytag: member="ccnr_proto.c::name_comp_equal_prefix" ref="a70fd987b1e084846de60266cd3c017c3" args="(const unsigned char *data, const struct ccn_indexbuf *indexbuf, unsigned int i, const void *buf, size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int name_comp_equal_prefix </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct ccn_indexbuf *&nbsp;</td>
          <td class="paramname"> <em>indexbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare a name component at index i to bytes in buf and return 1 if they are equal in the first length bytes. </p>
<p>The name component must contain at least length bytes for this comparison to return equality. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 for equality, 0 for inequality. </dd></dl>

</div>
</div>
<a class="anchor" id="a10e1f366d8ac499821f7dd09b777e9d0"></a><!-- doxytag: member="ccnr_proto.c::r_proto_activate_policy" ref="a10e1f366d8ac499821f7dd09b777e9d0" args="(struct ccnr_handle *ccnr, struct ccnr_parsed_policy *pp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC void r_proto_activate_policy </td>
          <td>(</td>
          <td class="paramtype">struct ccnr_handle *&nbsp;</td>
          <td class="paramname"> <em>ccnr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ccnr_parsed_policy *&nbsp;</td>
          <td class="paramname"> <em>pp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Install the listener for the namespaces that the parsed policy says to serve. </p>
<p>Normal usage is to deactivate the old policy and then activate the new one </p>

</div>
</div>
<a class="anchor" id="a22346544e87a567a668c08a4f722fe21"></a><!-- doxytag: member="ccnr_proto.c::r_proto_initiate_key_fetch" ref="a22346544e87a567a668c08a4f722fe21" args="(struct ccnr_handle *ccnr, const unsigned char *msg, struct ccn_parsed_ContentObject *pco, int use_link, ccnr_cookie a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int r_proto_initiate_key_fetch </td>
          <td>(</td>
          <td class="paramtype">struct ccnr_handle *&nbsp;</td>
          <td class="paramname"> <em>ccnr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ccn_parsed_ContentObject *&nbsp;</td>
          <td class="paramname"> <em>pco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>use_link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ccnr_cookie&nbsp;</td>
          <td class="paramname"> <em>a</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initiate a key fetch if necessary. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 if error or no name, 0 if fetch was issued, 1 if already stored. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Feb 4 11:59:13 2013 for CCNx for Android by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CCNx for Android: /tilde/dkords/dev/repos/ccn-external.git/ccnx-0.7.1/csrc/ccnr/ccnr_store.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>/tilde/dkords/dev/repos/ccn-external.git/ccnx-0.7.1/csrc/ccnr/ccnr_store.c File Reference</h1>
<p>Part of ccnr - CCNx Repository Daemon.  
<a href="#_details">More...</a></p>
<code>#include &lt;errno.h&gt;</code><br/>
<code>#include &lt;fcntl.h&gt;</code><br/>
<code>#include &lt;limits.h&gt;</code><br/>
<code>#include &lt;netdb.h&gt;</code><br/>
<code>#include &lt;poll.h&gt;</code><br/>
<code>#include &lt;signal.h&gt;</code><br/>
<code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;arpa/inet.h&gt;</code><br/>
<code>#include &lt;sys/time.h&gt;</code><br/>
<code>#include &lt;sys/socket.h&gt;</code><br/>
<code>#include &lt;sys/stat.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;sys/un.h&gt;</code><br/>
<code>#include &lt;netinet/in.h&gt;</code><br/>
<code>#include &lt;ccn/bloom.h&gt;</code><br/>
<code>#include &lt;ccn/btree_content.h&gt;</code><br/>
<code>#include &lt;ccn/ccn.h&gt;</code><br/>
<code>#include &lt;ccn/ccn_private.h&gt;</code><br/>
<code>#include &lt;ccn/charbuf.h&gt;</code><br/>
<code>#include &lt;ccn/face_mgmt.h&gt;</code><br/>
<code>#include &lt;ccn/hashtb.h&gt;</code><br/>
<code>#include &lt;ccn/indexbuf.h&gt;</code><br/>
<code>#include &lt;ccn/schedule.h&gt;</code><br/>
<code>#include &lt;ccn/reg_mgmt.h&gt;</code><br/>
<code>#include &lt;ccn/uri.h&gt;</code><br/>
<code>#include &quot;ccnr_private.h&quot;</code><br/>
<code>#include &quot;ccnr_stats.h&quot;</code><br/>
<code>#include &quot;ccnr_store.h&quot;</code><br/>
<code>#include &quot;ccnr_init.h&quot;</code><br/>
<code>#include &quot;ccnr_link.h&quot;</code><br/>
<code>#include &quot;ccnr_util.h&quot;</code><br/>
<code>#include &quot;ccnr_proto.h&quot;</code><br/>
<code>#include &quot;ccnr_msg.h&quot;</code><br/>
<code>#include &quot;ccnr_sync.h&quot;</code><br/>
<code>#include &quot;ccnr_match.h&quot;</code><br/>
<code>#include &quot;ccnr_sendq.h&quot;</code><br/>
<code>#include &quot;ccnr_io.h&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontent__entry.html">content_entry</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00e75d347b482ae87d0420e5b1cca893"></a><!-- doxytag: member="ccnr_store.c::FAILIF" ref="a00e75d347b482ae87d0420e5b1cca893" args="(cond)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>FAILIF</b>(cond)&nbsp;&nbsp;&nbsp;do {} while ((cond) &amp;&amp; r_store_fatal(h, __func__, __LINE__))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4604b17b39247a487c0cc3d0087a72e"></a><!-- doxytag: member="ccnr_store.c::CHKSYS" ref="ac4604b17b39247a487c0cc3d0087a72e" args="(res)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CHKSYS</b>(res)&nbsp;&nbsp;&nbsp;FAILIF((res) == -1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf7cd00a3dd8ed9fa292c24dcb4151ab"></a><!-- doxytag: member="ccnr_store.c::CHKRES" ref="aaf7cd00a3dd8ed9fa292c24dcb4151ab" args="(res)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CHKRES</b>(res)&nbsp;&nbsp;&nbsp;FAILIF((res) &lt; 0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70544e4126ade0a547094953d25db485"></a><!-- doxytag: member="ccnr_store.c::CHKPTR" ref="a70544e4126ade0a547094953d25db485" args="(p)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CHKPTR</b>(p)&nbsp;&nbsp;&nbsp;FAILIF((p) == NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa18e56647329d4fd3fca70282dcf1b54"></a><!-- doxytag: member="ccnr_store.c::CCN_BT_CLEAN_BATCH" ref="aa18e56647329d4fd3fca70282dcf1b54" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#aa18e56647329d4fd3fca70282dcf1b54">CCN_BT_CLEAN_BATCH</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of btree index writes to do in a batch. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d16e54fa12f251bbd72bf98160810f3"></a><!-- doxytag: member="ccnr_store.c::CCN_BT_CLEAN_TICK_MICROS" ref="a6d16e54fa12f251bbd72bf98160810f3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a6d16e54fa12f251bbd72bf98160810f3">CCN_BT_CLEAN_TICK_MICROS</a>&nbsp;&nbsp;&nbsp;65536</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Approximate delay between batches of btree index writes. <br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6447188caeb093d5b9fd40b3b4403b67"></a><!-- doxytag: member="ccnr_store.c::r_store_set_flatname" ref="a6447188caeb093d5b9fd40b3b4403b67" args="(struct ccnr_handle *h, struct content_entry *content, struct ccn_parsed_ContentObject *pco)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a6447188caeb093d5b9fd40b3b4403b67">r_store_set_flatname</a> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content, struct ccn_parsed_ContentObject *pco)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses content object and sets content-&gt;flatname. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a4adb698043133ca24c239b4931df349e">r_store_content_btree_insert</a> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content, struct ccn_parsed_ContentObject *pco, ccnr_accession *accp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a5a6a34596ef8002676548185f68f0b"></a><!-- doxytag: member="ccnr_store.c::r_store_fatal" ref="a8a5a6a34596ef8002676548185f68f0b" args="(struct ccnr_handle *h, const char *fn, int lineno)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_fatal</b> (struct ccnr_handle *h, const char *fn, int lineno)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7297e7383093bccca677b96c2be16d5e"></a><!-- doxytag: member="ccnr_store.c::r_store_content_accession" ref="a7297e7383093bccca677b96c2be16d5e" args="(struct ccnr_handle *h, struct content_entry *content)" -->
PUBLIC ccnr_accession&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_content_accession</b> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70e87f04b52f42d0f5563242e3245e92"></a><!-- doxytag: member="ccnr_store.c::r_store_content_cookie" ref="a70e87f04b52f42d0f5563242e3245e92" args="(struct ccnr_handle *h, struct content_entry *content)" -->
PUBLIC ccnr_cookie&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_content_cookie</b> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74b4e2f1e9f862f9d39db49e8d19e499"></a><!-- doxytag: member="ccnr_store.c::r_store_content_size" ref="a74b4e2f1e9f862f9d39db49e8d19e499" args="(struct ccnr_handle *h, struct content_entry *content)" -->
PUBLIC size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_content_size</b> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a563c6a377b51ddb9d84bf3fcb0816587"></a><!-- doxytag: member="ccnr_store.c::r_store_offset_from_accession" ref="a563c6a377b51ddb9d84bf3fcb0816587" args="(struct ccnr_handle *h, ccnr_accession a)" -->
static off_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_offset_from_accession</b> (struct ccnr_handle *h, ccnr_accession a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4e41c408921574812157f83e2b4c332"></a><!-- doxytag: member="ccnr_store.c::r_store_repofile_from_accession" ref="ac4e41c408921574812157f83e2b4c332" args="(struct ccnr_handle *h, ccnr_accession a)" -->
static unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_repofile_from_accession</b> (struct ccnr_handle *h, ccnr_accession a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a839d6d966afc621273843b329af213d5"></a><!-- doxytag: member="ccnr_store.c::r_store_content_mapped" ref="a839d6d966afc621273843b329af213d5" args="(struct ccnr_handle *h, struct content_entry *content)" -->
static const unsigned char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_content_mapped</b> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c22ad40fd67273abd0572e7ac0f0b62"></a><!-- doxytag: member="ccnr_store.c::r_store_content_read" ref="a7c22ad40fd67273abd0572e7ac0f0b62" args="(struct ccnr_handle *h, struct content_entry *content)" -->
static const unsigned char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_content_read</b> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#aab67c6d367fb967c09dabeff6756b426">r_store_content_trim</a> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the content appears to be safely stored in the repository, removes any buffered copy.  <a href="#aab67c6d367fb967c09dabeff6756b426"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8cc1745c65a0e5fa8d24684a4072586"></a><!-- doxytag: member="ccnr_store.c::r_store_trim" ref="ad8cc1745c65a0e5fa8d24684a4072586" args="(struct ccnr_handle *h, unsigned long limit)" -->
PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#ad8cc1745c65a0e5fa8d24684a4072586">r_store_trim</a> (struct ccnr_handle *h, unsigned long limit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evict recoverable content from in-memory buffers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC const unsigned char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#aaae3d20273f3e24a347f97f29855fe8e">r_store_content_base</a> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the base address of the content object.  <a href="#aaae3d20273f3e24a347f97f29855fe8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1174393741ef6f2a3b513766dcf29a97"></a><!-- doxytag: member="ccnr_store.c::r_store_name_append_components" ref="a1174393741ef6f2a3b513766dcf29a97" args="(struct ccn_charbuf *dst, struct ccnr_handle *h, struct content_entry *content, int skip, int count)" -->
PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_name_append_components</b> (struct ccn_charbuf *dst, struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content, int skip, int count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a235317d791a1d46a0ddaac71ffdfe235"></a><!-- doxytag: member="ccnr_store.c::r_store_content_flags" ref="a235317d791a1d46a0ddaac71ffdfe235" args="(struct content_entry *content)" -->
PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_content_flags</b> (struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1184dd21f735acc3a1fbf6fab2c0132f"></a><!-- doxytag: member="ccnr_store.c::r_store_content_change_flags" ref="a1184dd21f735acc3a1fbf6fab2c0132f" args="(struct content_entry *content, int set, int clear)" -->
PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_content_change_flags</b> (struct <a class="el" href="structcontent__entry.html">content_entry</a> *content, int set, int clear)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90e7f3ce47869533a60592e151443331"></a><!-- doxytag: member="ccnr_store.c::r_store_write_stable_point" ref="a90e7f3ce47869533a60592e151443331" args="(struct ccnr_handle *h)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a90e7f3ce47869533a60592e151443331">r_store_write_stable_point</a> (struct ccnr_handle *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a file named index/stable that contains the size of repoFile1 when the repository is shut down. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c1706a73916d3c160bca3b1a50ca864"></a><!-- doxytag: member="ccnr_store.c::r_store_read_stable_point" ref="a8c1706a73916d3c160bca3b1a50ca864" args="(struct ccnr_handle *h)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a8c1706a73916d3c160bca3b1a50ca864">r_store_read_stable_point</a> (struct ccnr_handle *h)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the former size of repoFile1 from index/stable, and remove the latter. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade2d612d23a39283d7f37fe1e653efa4"></a><!-- doxytag: member="ccnr_store.c::r_store_reindexing" ref="ade2d612d23a39283d7f37fe1e653efa4" args="(struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#ade2d612d23a39283d7f37fe1e653efa4">r_store_reindexing</a> (struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Log a bit if we are taking a while to re-index. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a960328ab0131da171fa1075a69b3df3e"></a><!-- doxytag: member="ccnr_store.c::choose_limit" ref="a960328ab0131da171fa1075a69b3df3e" args="(unsigned l, unsigned m)" -->
static unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a960328ab0131da171fa1075a69b3df3e">choose_limit</a> (unsigned l, unsigned m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select power of 2 between l and m + 1 (if possible). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa634b29978cf3c2c5bb75e477807dc26"></a><!-- doxytag: member="ccnr_store.c::cleanup_content_entry" ref="aa634b29978cf3c2c5bb75e477807dc26" args="(struct ccnr_handle *h, struct content_entry *content)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>cleanup_content_entry</b> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf4c52e8d23e6243bd091579e8ae7361"></a><!-- doxytag: member="ccnr_store.c::finalize_accession" ref="acf4c52e8d23e6243bd091579e8ae7361" args="(struct hashtb_enumerator *e)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>finalize_accession</b> (struct hashtb_enumerator *e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43be7a800c9eceae515afab1b309380f"></a><!-- doxytag: member="ccnr_store.c::r_store_init" ref="a43be7a800c9eceae515afab1b309380f" args="(struct ccnr_handle *h)" -->
PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_init</b> (struct ccnr_handle *h)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acde18f242380618bdf0ca5c7a62239a0"></a><!-- doxytag: member="ccnr_store.c::r_store_final" ref="acde18f242380618bdf0ca5c7a62239a0" args="(struct ccnr_handle *h, int stable)" -->
PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_final</b> (struct ccnr_handle *h, int stable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a387651e1ec4f65311f48f4541d2ef0e3"></a><!-- doxytag: member="ccnr_store.c::r_store_content_from_accession" ref="a387651e1ec4f65311f48f4541d2ef0e3" args="(struct ccnr_handle *h, ccnr_accession accession)" -->
PUBLIC struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_content_from_accession</b> (struct ccnr_handle *h, ccnr_accession accession)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8c17095e61a1aa3402768734729bcf5"></a><!-- doxytag: member="ccnr_store.c::r_store_content_from_cookie" ref="ae8c17095e61a1aa3402768734729bcf5" args="(struct ccnr_handle *h, ccnr_cookie cookie)" -->
PUBLIC struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_content_from_cookie</b> (struct ccnr_handle *h, ccnr_cookie cookie)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC ccnr_cookie&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a182c604a10afa29e663b5ef9c7409870">r_store_enroll_content</a> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This makes a cookie for content, and, if it has an accession number already, enters it into the content_by_accession_tab.  <a href="#a182c604a10afa29e663b5ef9c7409870"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2513fc9d41f7b43c441b40b29b5b8ad0"></a><!-- doxytag: member="ccnr_store.c::r_store_forget_content" ref="a2513fc9d41f7b43c441b40b29b5b8ad0" args="(struct ccnr_handle *h, struct content_entry **pentry)" -->
PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a2513fc9d41f7b43c441b40b29b5b8ad0">r_store_forget_content</a> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> **pentry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove internal representation of a content object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a7abbc32cf208a66562096265150450a4">r_store_look</a> (struct ccnr_handle *h, const unsigned char *key, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a handle on the content object that matches key, or if there is no match, the one that would come just after it.  <a href="#a7abbc32cf208a66562096265150450a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#afaa022159dfca7b3bfd840845198bc73">ccn_append_interest_bounds</a> (const unsigned char *interest_msg, const struct ccn_parsed_interest *pi, struct ccn_charbuf *lower, struct ccn_charbuf *upper)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract the flatname representations of the bounds for the next component after the name prefix of the interest.  <a href="#afaa022159dfca7b3bfd840845198bc73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae928c525ce46100295755fea01e87f7c"></a><!-- doxytag: member="ccnr_store.c::r_store_lookup_backwards" ref="ae928c525ce46100295755fea01e87f7c" args="(struct ccnr_handle *h, const unsigned char *interest_msg, const struct ccn_parsed_interest *pi, struct ccn_indexbuf *comps)" -->
static struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_lookup_backwards</b> (struct ccnr_handle *h, const unsigned char *interest_msg, const struct ccn_parsed_interest *pi, struct ccn_indexbuf *comps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf33cf2bbc9d109184f04c57cbd4458d"></a><!-- doxytag: member="ccnr_store.c::r_store_find_first_match_candidate" ref="acf33cf2bbc9d109184f04c57cbd4458d" args="(struct ccnr_handle *h, const unsigned char *interest_msg, const struct ccn_parsed_interest *pi)" -->
PUBLIC struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_find_first_match_candidate</b> (struct ccnr_handle *h, const unsigned char *interest_msg, const struct ccn_parsed_interest *pi)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a373161d0e77726ee8c135eb03e2a2319"></a><!-- doxytag: member="ccnr_store.c::r_store_content_matches_interest_prefix" ref="a373161d0e77726ee8c135eb03e2a2319" args="(struct ccnr_handle *h, struct content_entry *content, const unsigned char *interest_msg, size_t interest_size)" -->
PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_content_matches_interest_prefix</b> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content, const unsigned char *interest_msg, size_t interest_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69fd3e01544a9576329f5bb1301d2af4"></a><!-- doxytag: member="ccnr_store.c::r_store_content_next" ref="a69fd3e01544a9576329f5bb1301d2af4" args="(struct ccnr_handle *h, struct content_entry *content)" -->
PUBLIC struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_content_next</b> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab179aa8dea9df6c5183b2eaf55c45ad5"></a><!-- doxytag: member="ccnr_store.c::r_store_next_child_at_level" ref="ab179aa8dea9df6c5183b2eaf55c45ad5" args="(struct ccnr_handle *h, struct content_entry *content, int level)" -->
PUBLIC struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_next_child_at_level</b> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content, int level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79f1fc95cadf17dd869726090f66c494"></a><!-- doxytag: member="ccnr_store.c::r_store_lookup" ref="a79f1fc95cadf17dd869726090f66c494" args="(struct ccnr_handle *h, const unsigned char *msg, const struct ccn_parsed_interest *pi, struct ccn_indexbuf *comps)" -->
PUBLIC struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_lookup</b> (struct ccnr_handle *h, const unsigned char *msg, const struct ccn_parsed_interest *pi, struct ccn_indexbuf *comps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a18c07809591e2988b192125c1e92d260">r_store_lookup_ccnb</a> (struct ccnr_handle *h, const unsigned char *namish, size_t size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the first content handle that matches the prefix given by the namish, which may be a Name, Interest, ContentObject, .  <a href="#a18c07809591e2988b192125c1e92d260"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25885e8c4e958c6d152d502b7e1d03f6"></a><!-- doxytag: member="ccnr_store.c::r_store_mark_stale" ref="a25885e8c4e958c6d152d502b7e1d03f6" args="(struct ccnr_handle *h, struct content_entry *content)" -->
PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a25885e8c4e958c6d152d502b7e1d03f6">r_store_mark_stale</a> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark content as stale. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a214d64cac928f3d7a30509226914d2ba"></a><!-- doxytag: member="ccnr_store.c::expire_content" ref="a214d64cac928f3d7a30509226914d2ba" args="(struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a214d64cac928f3d7a30509226914d2ba">expire_content</a> (struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scheduled event that makes content stale when its FreshnessSeconds has expired. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e75e3e47dfae135c4e667fa1204f3cd"></a><!-- doxytag: member="ccnr_store.c::r_store_set_content_timer" ref="a9e75e3e47dfae135c4e667fa1204f3cd" args="(struct ccnr_handle *h, struct content_entry *content, struct ccn_parsed_ContentObject *pco)" -->
PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a9e75e3e47dfae135c4e667fa1204f3cd">r_store_set_content_timer</a> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content, struct ccn_parsed_ContentObject *pco)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedules content expiration based on its FreshnessSeconds. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PUBLIC struct ccn_charbuf *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ccnr__store_8c.html#a36e999c840ecfc6ea8c1a325a6cbba6c">r_store_content_flatname</a> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the flatname associated with content.  <a href="#a36e999c840ecfc6ea8c1a325a6cbba6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa806a3059d39e9cd3cdac56c950efbf4"></a><!-- doxytag: member="ccnr_store.c::process_incoming_content" ref="aa806a3059d39e9cd3cdac56c950efbf4" args="(struct ccnr_handle *h, struct fdholder *fdholder, unsigned char *msg, size_t size, off_t *offsetp)" -->
PUBLIC struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>process_incoming_content</b> (struct ccnr_handle *h, struct fdholder *fdholder, unsigned char *msg, size_t size, off_t *offsetp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c896a62816c08d5f51f9fcf7a126a3b"></a><!-- doxytag: member="ccnr_store.c::r_store_content_field_access" ref="a1c896a62816c08d5f51f9fcf7a126a3b" args="(struct ccnr_handle *h, struct content_entry *content, enum ccn_dtag dtag, const unsigned char **bufp, size_t *sizep)" -->
PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_content_field_access</b> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content, enum ccn_dtag dtag, const unsigned char **bufp, size_t *sizep)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab29ce4f0a5a30fd836789e5d01ab9a33"></a><!-- doxytag: member="ccnr_store.c::r_store_set_accession_from_offset" ref="ab29ce4f0a5a30fd836789e5d01ab9a33" args="(struct ccnr_handle *h, struct content_entry *content, struct fdholder *fdholder, off_t offset)" -->
PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_set_accession_from_offset</b> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content, struct fdholder *fdholder, off_t offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4469202bb4fec5c42645e31eb9399863"></a><!-- doxytag: member="ccnr_store.c::r_store_send_content" ref="a4469202bb4fec5c42645e31eb9399863" args="(struct ccnr_handle *h, struct fdholder *fdholder, struct content_entry *content)" -->
PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_send_content</b> (struct ccnr_handle *h, struct fdholder *fdholder, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb4f3bb1e938ab7384fc10370de8413c"></a><!-- doxytag: member="ccnr_store.c::r_store_commit_content" ref="afb4f3bb1e938ab7384fc10370de8413c" args="(struct ccnr_handle *h, struct content_entry *content)" -->
PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_commit_content</b> (struct ccnr_handle *h, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4967ebff8011a63877d2add998be5cfc"></a><!-- doxytag: member="ccnr_store.c::ccnr_debug_content" ref="a4967ebff8011a63877d2add998be5cfc" args="(struct ccnr_handle *h, int lineno, const char *msg, struct fdholder *fdholder, struct content_entry *content)" -->
PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ccnr_debug_content</b> (struct ccnr_handle *h, int lineno, const char *msg, struct fdholder *fdholder, struct <a class="el" href="structcontent__entry.html">content_entry</a> *content)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a842f63048137bb1891679666b653e0f6"></a><!-- doxytag: member="ccnr_store.c::r_store_index_cleaner" ref="a842f63048137bb1891679666b653e0f6" args="(struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_index_cleaner</b> (struct ccn_schedule *sched, void *clienth, struct ccn_scheduled_event *ev, int flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6224dcc3eda470451691b11804c4637"></a><!-- doxytag: member="ccnr_store.c::r_store_index_needs_cleaning" ref="ae6224dcc3eda470451691b11804c4637" args="(struct ccnr_handle *h)" -->
PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_index_needs_cleaning</b> (struct ccnr_handle *h)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49318ac3bf42dd9c26fb1a02adc1f677"></a><!-- doxytag: member="ccnr_store.c::bogon" ref="a49318ac3bf42dd9c26fb1a02adc1f677" args="" -->
static const unsigned char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>bogon</b> = NULL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a19fc61ebbe33cc0521c182e4bff8bc"></a><!-- doxytag: member="ccnr_store.c::r_store_mark_repoFile1" ref="a7a19fc61ebbe33cc0521c182e4bff8bc" args="" -->
const ccnr_accession&nbsp;</td><td class="memItemRight" valign="bottom"><b>r_store_mark_repoFile1</b> = ((ccnr_accession)1) &lt;&lt; 48</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Part of ccnr - CCNx Repository Daemon. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="afaa022159dfca7b3bfd840845198bc73"></a><!-- doxytag: member="ccnr_store.c::ccn_append_interest_bounds" ref="afaa022159dfca7b3bfd840845198bc73" args="(const unsigned char *interest_msg, const struct ccn_parsed_interest *pi, struct ccn_charbuf *lower, struct ccn_charbuf *upper)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int ccn_append_interest_bounds </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>interest_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct ccn_parsed_interest *&nbsp;</td>
          <td class="paramname"> <em>pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ccn_charbuf *&nbsp;</td>
          <td class="paramname"> <em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ccn_charbuf *&nbsp;</td>
          <td class="paramname"> <em>upper</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract the flatname representations of the bounds for the next component after the name prefix of the interest. </p>
<p>These are exclusive bounds. The results are appended to lower and upper (when not NULL). If there is no lower bound, lower will be unchanged. If there is no upper bound, a sentinel value is appended to upper.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>on success the number of Components in Exclude. A negative value indicates an error. </dd></dl>

</div>
</div>
<a class="anchor" id="aaae3d20273f3e24a347f97f29855fe8e"></a><!-- doxytag: member="ccnr_store.c::r_store_content_base" ref="aaae3d20273f3e24a347f97f29855fe8e" args="(struct ccnr_handle *h, struct content_entry *content)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC const unsigned char* r_store_content_base </td>
          <td>(</td>
          <td class="paramtype">struct ccnr_handle *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td>
          <td class="paramname"> <em>content</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the base address of the content object. </p>
<p>This may involve reading the object in. Caller should not assume that the address will stay valid after it relinquishes control, either by returning or by calling routines that might invalidate objects. </p>

</div>
</div>
<a class="anchor" id="a4adb698043133ca24c239b4931df349e"></a><!-- doxytag: member="ccnr_store.c::r_store_content_btree_insert" ref="a4adb698043133ca24c239b4931df349e" args="(struct ccnr_handle *h, struct content_entry *content, struct ccn_parsed_ContentObject *pco, ccnr_accession *accp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int r_store_content_btree_insert </td>
          <td>(</td>
          <td class="paramtype">struct ccnr_handle *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ccn_parsed_ContentObject *&nbsp;</td>
          <td class="paramname"> <em>pco</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ccnr_accession *&nbsp;</td>
          <td class="paramname"> <em>accp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>2 if content was added to index, 1 if it was there but had no accession, 0 if it was already there, -1 for error </dd></dl>

</div>
</div>
<a class="anchor" id="a36e999c840ecfc6ea8c1a325a6cbba6c"></a><!-- doxytag: member="ccnr_store.c::r_store_content_flatname" ref="a36e999c840ecfc6ea8c1a325a6cbba6c" args="(struct ccnr_handle *h, struct content_entry *content)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC struct ccn_charbuf* r_store_content_flatname </td>
          <td>(</td>
          <td class="paramtype">struct ccnr_handle *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td>
          <td class="paramname"> <em>content</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the flatname associated with content. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>flatname in a charbuf, which should be treated as read-only. </dd></dl>

</div>
</div>
<a class="anchor" id="aab67c6d367fb967c09dabeff6756b426"></a><!-- doxytag: member="ccnr_store.c::r_store_content_trim" ref="aab67c6d367fb967c09dabeff6756b426" args="(struct ccnr_handle *h, struct content_entry *content)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC int r_store_content_trim </td>
          <td>(</td>
          <td class="paramtype">struct ccnr_handle *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td>
          <td class="paramname"> <em>content</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If the content appears to be safely stored in the repository, removes any buffered copy. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if buffer was removed, -1 if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a182c604a10afa29e663b5ef9c7409870"></a><!-- doxytag: member="ccnr_store.c::r_store_enroll_content" ref="a182c604a10afa29e663b5ef9c7409870" args="(struct ccnr_handle *h, struct content_entry *content)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC ccnr_cookie r_store_enroll_content </td>
          <td>(</td>
          <td class="paramtype">struct ccnr_handle *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcontent__entry.html">content_entry</a> *&nbsp;</td>
          <td class="paramname"> <em>content</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This makes a cookie for content, and, if it has an accession number already, enters it into the content_by_accession_tab. </p>
<p>Does not index by name. </p>

</div>
</div>
<a class="anchor" id="a7abbc32cf208a66562096265150450a4"></a><!-- doxytag: member="ccnr_store.c::r_store_look" ref="a7abbc32cf208a66562096265150450a4" args="(struct ccnr_handle *h, const unsigned char *key, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structcontent__entry.html">content_entry</a>* r_store_look </td>
          <td>(</td>
          <td class="paramtype">struct ccnr_handle *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a handle on the content object that matches key, or if there is no match, the one that would come just after it. </p>
<p>The key is in flatname format. </p>

</div>
</div>
<a class="anchor" id="a18c07809591e2988b192125c1e92d260"></a><!-- doxytag: member="ccnr_store.c::r_store_lookup_ccnb" ref="a18c07809591e2988b192125c1e92d260" args="(struct ccnr_handle *h, const unsigned char *namish, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PUBLIC struct <a class="el" href="structcontent__entry.html">content_entry</a>* r_store_lookup_ccnb </td>
          <td>(</td>
          <td class="paramtype">struct ccnr_handle *&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>namish</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the first content handle that matches the prefix given by the namish, which may be a Name, Interest, ContentObject, . </p>
<p>..</p>
<p>Does not check the other parts of namish, in particular, does not generate the digest component of a ContentObject. </p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Feb 4 11:59:13 2013 for CCNx for Android by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

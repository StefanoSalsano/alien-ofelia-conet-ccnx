<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Content-Centric Networking in Java: org.ccnx.ccn.io.content.KeyDirectory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<b>io</b>.<b>content</b>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html">KeyDirectory</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.io.content.KeyDirectory Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::io::content::KeyDirectory" --><!-- doxytag: inherits="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList" -->
<p>A key directory holds a key (secret or private), distributed to entities (represented by public keys), by a set of key blocks each of which wrapping that key under different target keys.  
<a href="#_details">More...</a></p>

<p><a href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory_1_1_no_private_key_exception.html">NoPrivateKeyException</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a7d87cf8ec540c4531fdeb17f547baeb1">KeyDirectory</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> directoryName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Directory name should be versioned, else we pull the latest version; start enumeration.  <a href="#a7d87cf8ec540c4531fdeb17f547baeb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#aa6254cf0a256aa254047e8e228db9db7">KeyDirectory</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> directoryName, boolean enumerate, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Directory name should be versioned, else we pull the latest version.  <a href="#aa6254cf0a256aa254047e8e228db9db7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a1f5fb870d06ff2010db6cd029b688b14">hasResult</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subclasses should override this test to answer true if waiters should break out of a waitForNoUpdatesOrResult loop.  <a href="#a1f5fb870d06ff2010db6cd029b688b14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TreeSet&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#aef127a673dc0acb891ea3123dfed3f77">getCopyOfWrappingKeyIDs</a> ()  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a copy to avoid synchronization problems.  <a href="#aef127a673dc0acb891ea3123dfed3f77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TreeSet&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a704b32238317892f2b8f09c806e8e4ab">getCopyOfOtherNames</a> ()  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy to avoid synchronization problems.  <a href="#a704b32238317892f2b8f09c806e8e4ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#aae5381a02cd880fae2e36e1cd3fab4f9">getWrappedKeyForKeyID</a> (byte[] keyID)  throws ContentDecodingException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wrapped key object corresponding to a public key specified by its digest.  <a href="#aae5381a02cd880fae2e36e1cd3fab4f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#aa3b7265afcf8e99f0c62f12555d56e43">getWrappedKeyNameForKeyID</a> (byte[] keyID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wrapped key name for a public key specified by its digest.  <a href="#aa3b7265afcf8e99f0c62f12555d56e43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a1a964a9e10ebfebc72d62121d3cab52a">hasSupersededBlock</a> ()  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for the existence of a superseded block.  <a href="#a1a964a9e10ebfebc72d62121d3cab52a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7306964b8292661a65e800c6cb9554d6"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getSupersededBlockName" ref="a7306964b8292661a65e800c6cb9554d6" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getSupersededBlockName</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#aaa2a1a1e05b49223a9c16cedbcb627ca">getSupersededWrappedKey</a> ()  throws ContentDecodingException, ContentNotReadyException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We have several choices for how to represent superseded and previous keys.  <a href="#aaa2a1a1e05b49223a9c16cedbcb627ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a767ae095ec17bb5ce9ebda35883a0655">getWrappedKey</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> wrappedKeyName)  throws ContentDecodingException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wrapped key object corresponding to the specified wrapped key name.  <a href="#a767ae095ec17bb5ce9ebda35883a0655"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a3b0e4c5e9345b924acc63e92d3e0e0ad">hasPreviousKeyBlock</a> ()  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for the existence of a previous key block.  <a href="#a3b0e4c5e9345b924acc63e92d3e0e0ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38cfc7c00a4d75562c5d138b368c860e"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getPreviousKeyBlockName" ref="a38cfc7c00a4d75562c5d138b368c860e" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getPreviousKeyBlockName</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_link.html">Link</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a613294cc3bb3fc069d80837975ff47c2">getPreviousKey</a> (long timeout)  throws ContentNotReadyException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a link to the previous key.  <a href="#a613294cc3bb3fc069d80837975ff47c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a1cfafe64a2b2f90665176d24b4e9e34e">hasPrivateKeyBlock</a> ()  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We store a private key as a single block wrapped under a nonce key, which is then wrapped under the public keys of various principals.  <a href="#a1cfafe64a2b2f90665176d24b4e9e34e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a562f7a47f1c63157889d8c9ddf07acec"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getPrivateKeyBlockName" ref="a562f7a47f1c63157889d8c9ddf07acec" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getPrivateKeyBlockName</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a7e88b2b7596265d2e52b85e308b85c4b">getUnwrappedKey</a> (byte[] expectedKeyID)  throws InvalidKeyException, ContentDecodingException, IOException, NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unwrap and return the key wrapped in a wrapping key specified by its digest.  <a href="#a7e88b2b7596265d2e52b85e308b85c4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a45969d2265e2d99ef0acb495a510acb8">isPrivateKeyInCache</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a68207bff4280c9957160453f0519b0b0">getPrivateKey</a> ()  throws AccessDeniedException, InvalidKeyException, 	ContentNotReadyException, ContentGoneException, ContentDecodingException, 	IOException, NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the private key stored in the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>.  <a href="#a68207bff4280c9957160453f0519b0b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#ad4f2cd07ceba295883bf35dd3257714d">addWrappedKeyBlock</a> (Key secretKeyToWrap, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> publicKeyName, PublicKey publicKey)  throws ContentEncodingException, IOException, InvalidKeyException, VersionMissingException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a wrapped key block to the repository.  <a href="#ad4f2cd07ceba295883bf35dd3257714d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a19345df2049e38c420e2e015ab871fe6">addPrivateKeyBlock</a> (PrivateKey privateKey, Key privateKeyWrappingKey)  throws ContentEncodingException, IOException, InvalidKeyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a private key block to the repository.  <a href="#a19345df2049e38c420e2e015ab871fe6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#adfbaeb301c104c94587b711ee581faa6">addSupersededByBlock</a> (Key oldPrivateKeyWrappingKey, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> storedSupersedingKeyName, byte[] storedSupersedingKeyID, Key newPrivateKeyWrappingKey)  throws InvalidKeyException, ContentEncodingException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a superseded-by block to our key directory.  <a href="#adfbaeb301c104c94587b711ee581faa6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#af1cc5eff557c2d8ab7b2d8bae03d7c09">addPreviousKeyLink</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> previousKey, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_i_d.html">PublisherID</a> previousKeyPublisher)  throws ContentEncodingException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a link to a previous key to the repository.  <a href="#af1cc5eff557c2d8ab7b2d8bae03d7c09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a3befc109edc280fbad489697a06281b2">addPreviousKeyBlock</a> (Key oldPrivateKeyWrappingKey, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> supersedingKeyName, Key newPrivateKeyWrappingKey)  throws InvalidKeyException, ContentEncodingException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a previous key block to the repository.  <a href="#a3befc109edc280fbad489697a06281b2"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98db97d3f456e934538c78a19b0977f1"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getSupersededBlockNameForKey" ref="a98db97d3f456e934538c78a19b0977f1" args="(ContentName versionedKeyName)" -->
static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getSupersededBlockNameForKey</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> versionedKeyName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05a5cba8cf1cbceacf4e89c86fe74cae"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getPreviousKeyBlockName" ref="a05a5cba8cf1cbceacf4e89c86fe74cae" args="(ContentName keyDirectoryName)" -->
static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getPreviousKeyBlockName</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyDirectoryName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a1b5bd9c8af2c2fdedf00d1f63a915bf3">addSupersededByBlock</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> oldKeyVersionedNameToAddBlockTo, Key oldKeyToBeSuperseded, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> storedSupersedingKeyName, byte[] storedSupersedingKeyID, Key supersedingKey, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws ContentEncodingException, IOException, InvalidKeyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a superseded-by block to another node key, where we may have only its name, not its enumeration.  <a href="#a1b5bd9c8af2c2fdedf00d1f63a915bf3"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e31c40165a0d3cfb1490c463c401b3b"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::SUPERSEDED_MARKER" ref="a7e31c40165a0d3cfb1490c463c401b3b" args="" -->
static final <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_component.html">Component</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>SUPERSEDED_MARKER</b> = new <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_component.html">Component</a>(&quot;SupersededBy&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96328b14ee05b9e1569efaf700846012"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::PREVIOUS_KEY" ref="a96328b14ee05b9e1569efaf700846012" args="" -->
static final <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_component.html">Component</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>PREVIOUS_KEY</b> = new <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_component.html">Component</a>(&quot;PreviousKey&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea19d8d404917cb5a1568048cc68dbc7"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::GROUP_PUBLIC_KEY" ref="aea19d8d404917cb5a1568048cc68dbc7" args="" -->
static final <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_component.html">Component</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GROUP_PUBLIC_KEY</b> = new <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_component.html">Component</a>(&quot;Key&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ba1a615d22cf2e4784e88e8add9c4ce"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::GROUP_PRIVATE_KEY" ref="a7ba1a615d22cf2e4784e88e8add9c4ce" args="" -->
static final <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_component.html">Component</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>GROUP_PRIVATE_KEY</b> = new <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_component.html">Component</a>(&quot;PrivateKey&quot;)</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a3db09cbfc4af2b2daed36840f3abbcc8">initialize</a> (boolean startEnumerating)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We don't start enumerating until we get here.  <a href="#a3db09cbfc4af2b2daed36840f3abbcc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca5811be11ad57f76e64f1e2740b82b9"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::processNewChildren" ref="aca5811be11ad57f76e64f1e2740b82b9" args="(SortedSet&lt; ContentName &gt; newChildren)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#aca5811be11ad57f76e64f1e2740b82b9">processNewChildren</a> (SortedSet&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> &gt; newChildren)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called each time new data comes in, gets to parse it and load processed arrays. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b5debf7ea9649c53dd298b64ad254a9"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::processNewChild" ref="a0b5debf7ea9649c53dd298b64ad254a9" args="(byte[] wkChildName)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>processNewChild</b> (byte[] wkChildName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a70631f2cc0ed483acb277c2cbe07aa34">getPrivateKeyObject</a> ()  throws ContentGoneException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the private key object, if one exists as a wrapped key object.  <a href="#a70631f2cc0ed483acb277c2cbe07aa34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac01dbd68c16abda0986b8354e2bfd1dd"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::findUnwrappedKey" ref="ac01dbd68c16abda0986b8354e2bfd1dd" args="(byte[] expectedKeyID)" -->
Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>findUnwrappedKey</b> (byte[] expectedKeyID)  throws IOException, 			ContentNotReadyException, InvalidKeyException, 			ContentDecodingException, NoSuchAlgorithmException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a0e072833bc839bd2a339ee4f8c6197b0">unwrapKeyViaCache</a> (byte[] keyIDOfCachedKeytoUse)  throws ContentDecodingException, IOException, InvalidKeyException, NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast path -- once we have an idea which of our keys will unwrap this key, get it.  <a href="#a0e072833bc839bd2a339ee4f8c6197b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b4509430b71889328c9ea94cf9c893b"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::unwrapKeyViaCache" ref="a0b4509430b71889328c9ea94cf9c893b" args="()" -->
Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>unwrapKeyViaCache</b> ()  throws InvalidKeyException, ContentDecodingException, IOException, NoSuchAlgorithmException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f6f6f4408f669098b9578f06c0bb393"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::unwrapKeyViaSupersededKey" ref="a3f6f6f4408f669098b9578f06c0bb393" args="()" -->
Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>unwrapKeyViaSupersededKey</b> ()  throws InvalidKeyException, ContentDecodingException, IOException, NoSuchAlgorithmException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2809f4c664aaf8afe75712d7622e6d43"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::factory" ref="a2809f4c664aaf8afe75712d7622e6d43" args="(ContentName name)" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html">KeyDirectory</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>factory</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name)  throws IOException </td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24c9e81016f14c05aafcd9a3e91f1712"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::_handle" ref="a24c9e81016f14c05aafcd9a3e91f1712" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>_handle</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae70c4423ed6d1b5bd93bc210dc6e2977"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::cacheHit" ref="ae70c4423ed6d1b5bd93bc210dc6e2977" args="" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>cacheHit</b></td></tr>
<tr><td colspan="2"><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2902506c54529831b36ea2ddba887926"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::byteArrayComparator" ref="a2902506c54529831b36ea2ddba887926" args="" -->
static final Comparator&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>byteArrayComparator</b> = new <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1support_1_1_byte_array_compare.html">ByteArrayCompare</a>()</td></tr>
<tr><td colspan="2"><h2>Package Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e8c722591969672230f9a65dd07dc13"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::_keyIDs" ref="a4e8c722591969672230f9a65dd07dc13" args="" -->
TreeSet&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a4e8c722591969672230f9a65dd07dc13">_keyIDs</a> = new TreeSet&lt;byte []&gt;(byteArrayComparator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The set _keyIDs contains the digests of the (public) wrapping keys of the wrapped key objects stored in the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34376976ad6f06c49fba0236fa361e9d"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::_keyIDLock" ref="a34376976ad6f06c49fba0236fa361e9d" args="" -->
final ReadWriteLock&nbsp;</td><td class="memItemRight" valign="bottom"><b>_keyIDLock</b> = new ReentrantReadWriteLock()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21116d7c77b708ac60667a4bcb27fdb6"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::_otherNames" ref="a21116d7c77b708ac60667a4bcb27fdb6" args="" -->
TreeSet&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html#a21116d7c77b708ac60667a4bcb27fdb6">_otherNames</a> = new TreeSet&lt;byte []&gt;(byteArrayComparator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The set _otherNames records the presence of superseded keys, previous keys, group private keys, etc. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8389f7b43646b5e4075e70aa1948135f"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::_otherNamesLock" ref="a8389f7b43646b5e4075e70aa1948135f" args="" -->
final ReadWriteLock&nbsp;</td><td class="memItemRight" valign="bottom"><b>_otherNamesLock</b> = new ReentrantReadWriteLock()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A key directory holds a key (secret or private), distributed to entities (represented by public keys), by a set of key blocks each of which wrapping that key under different target keys. </p>
<p>If the key to be distributed is a private key, it is first wrapped under a nonce key, and that nonce key is stored encrypted under the keys of the receiving entitites.</p>
<p>Essentially a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a> is a software wrapper for managing a set of content stored in CCNx (writing and reading portions of that content); that content consists of a set of key blocks used to give one key to a number of target entities.</p>
<p>Key blocks are implemented as a set of wrapped key objects all stored in one directory. Wrapped key objects are typically short and only need one segment. The directory the keys are stored in is prefixed by a version, to allow the contents to evolve. In addition some potential supporting information pointing to previous or subsequent versions of this key is kept. A particular wrapped key entry's name would look like:</p>
<pre>&lt;keyname&gt;/version/xxx/s0</pre><p> <br/>
Where xxx is the identifier of the wrapped key.</p>
<p>Our model is that higher-level function may use this interface to try many ways to get a given key. Some will work (access is allowed), some may not -- the latter does not mean that the principal doesn't have access, just that the principal doesn't have access by this route. So for the moment, we return null when we don't conclusively know that this principal doesn't have access to this data somehow, rather than throwing AccessDeniedException. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7d87cf8ec540c4531fdeb17f547baeb1"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::KeyDirectory" ref="a7d87cf8ec540c4531fdeb17f547baeb1" args="(ContentName directoryName, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.content.KeyDirectory.KeyDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>directoryName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Directory name should be versioned, else we pull the latest version; start enumeration. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>manager</em>&nbsp;</td><td>the access control manager. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>directoryName</em>&nbsp;</td><td>the root of the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6254cf0a256aa254047e8e228db9db7"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::KeyDirectory" ref="aa6254cf0a256aa254047e8e228db9db7" args="(ContentName directoryName, boolean enumerate, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.content.KeyDirectory.KeyDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>directoryName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>enumerate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Directory name should be versioned, else we pull the latest version. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>directoryName</em>&nbsp;</td><td>the root of the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3befc109edc280fbad489697a06281b2"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::addPreviousKeyBlock" ref="a3befc109edc280fbad489697a06281b2" args="(Key oldPrivateKeyWrappingKey, ContentName supersedingKeyName, Key newPrivateKeyWrappingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.content.KeyDirectory.addPreviousKeyBlock </td>
          <td>(</td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>oldPrivateKeyWrappingKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>supersedingKeyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>newPrivateKeyWrappingKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a previous key block to the repository. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oldPrivateKeyWrappingKey</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>supersedingKeyName</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newPrivateKeyWrappingKey</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1cc5eff557c2d8ab7b2d8bae03d7c09"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::addPreviousKeyLink" ref="af1cc5eff557c2d8ab7b2d8bae03d7c09" args="(ContentName previousKey, PublisherID previousKeyPublisher)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.content.KeyDirectory.addPreviousKeyLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>previousKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_i_d.html">PublisherID</a>&nbsp;</td>
          <td class="paramname"> <em>previousKeyPublisher</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a link to a previous key to the repository. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>previousKey</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>previousKeyPublisher</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19345df2049e38c420e2e015ab871fe6"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::addPrivateKeyBlock" ref="a19345df2049e38c420e2e015ab871fe6" args="(PrivateKey privateKey, Key privateKeyWrappingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.content.KeyDirectory.addPrivateKeyBlock </td>
          <td>(</td>
          <td class="paramtype">PrivateKey&nbsp;</td>
          <td class="paramname"> <em>privateKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>privateKeyWrappingKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a>, IOException, InvalidKeyException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a private key block to the repository. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>privateKey</em>&nbsp;</td><td>the private key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>privateKeyWrappingKey</em>&nbsp;</td><td>the wrapping key used to wrap the private key. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b5bd9c8af2c2fdedf00d1f63a915bf3"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::addSupersededByBlock" ref="a1b5bd9c8af2c2fdedf00d1f63a915bf3" args="(ContentName oldKeyVersionedNameToAddBlockTo, Key oldKeyToBeSuperseded, ContentName storedSupersedingKeyName, byte[] storedSupersedingKeyID, Key supersedingKey, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void org.ccnx.ccn.io.content.KeyDirectory.addSupersededByBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>oldKeyVersionedNameToAddBlockTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>oldKeyToBeSuperseded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>storedSupersedingKeyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>storedSupersedingKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>supersedingKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a>, IOException, InvalidKeyException <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a superseded-by block to another node key, where we may have only its name, not its enumeration. </p>
<p>Use as a static method to add our own superseded-by blocks as well. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfbaeb301c104c94587b711ee581faa6"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::addSupersededByBlock" ref="adfbaeb301c104c94587b711ee581faa6" args="(Key oldPrivateKeyWrappingKey, ContentName storedSupersedingKeyName, byte[] storedSupersedingKeyID, Key newPrivateKeyWrappingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.content.KeyDirectory.addSupersededByBlock </td>
          <td>(</td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>oldPrivateKeyWrappingKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>storedSupersedingKeyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>storedSupersedingKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>newPrivateKeyWrappingKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a superseded-by block to our key directory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oldPrivateKeyWrappingKey</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>supersedingKeyName</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newPrivateKeyWrappingKey</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4f2cd07ceba295883bf35dd3257714d"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::addWrappedKeyBlock" ref="ad4f2cd07ceba295883bf35dd3257714d" args="(Key secretKeyToWrap, ContentName publicKeyName, PublicKey publicKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.io.content.KeyDirectory.addWrappedKeyBlock </td>
          <td>(</td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>secretKeyToWrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>publicKeyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublicKey&nbsp;</td>
          <td class="paramname"> <em>publicKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a>, IOException, InvalidKeyException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_version_missing_exception.html">VersionMissingException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a wrapped key block to the repository. </p>
<p>Eventually aggregate signing and repo stream operations at the very least across writing paired objects and links, preferably across larger swaths of data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>secretKeyToWrap</em>&nbsp;</td><td>either a node key, a data key, or a private key wrapping key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publicKeyName</em>&nbsp;</td><td>the name of the public key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publicKey</em>&nbsp;</td><td>the public key. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VersionMissingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VersionMissingException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_principal_key_directory.html#af2ff6d464ba2cf98c8c7d6c564dadff7">org.ccnx.ccn.profiles.security.access.group.PrincipalKeyDirectory</a>.</p>

</div>
</div>
<a class="anchor" id="a704b32238317892f2b8f09c806e8e4ab"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getCopyOfOtherNames" ref="a704b32238317892f2b8f09c806e8e4ab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TreeSet&lt;byte []&gt; org.ccnx.ccn.io.content.KeyDirectory.getCopyOfOtherNames </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a copy to avoid synchronization problems. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef127a673dc0acb891ea3123dfed3f77"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getCopyOfWrappingKeyIDs" ref="aef127a673dc0acb891ea3123dfed3f77" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TreeSet&lt;byte []&gt; org.ccnx.ccn.io.content.KeyDirectory.getCopyOfWrappingKeyIDs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a copy to avoid synchronization problems. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a613294cc3bb3fc069d80837975ff47c2"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getPreviousKey" ref="a613294cc3bb3fc069d80837975ff47c2" args="(long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_link.html">Link</a> org.ccnx.ccn.io.content.KeyDirectory.getPreviousKey </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a link to the previous key. </p>
<p>Previous key might be a link, if we're a simple newer version, or it might be a wrapped key, if we're an interposed node key. DKS TODO </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68207bff4280c9957160453f0519b0b0"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getPrivateKey" ref="a68207bff4280c9957160453f0519b0b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key org.ccnx.ccn.io.content.KeyDirectory.getPrivateKey </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1_access_denied_exception.html">AccessDeniedException</a>, InvalidKeyException, 	<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_gone_exception.html">ContentGoneException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, 	IOException, NoSuchAlgorithmException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the private key stored in the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>. </p>
<p>The private key is wrapped in a wrapping key, which is itself wrapped. So the unwrapping proceeds in two steps. First, we unwrap the wrapping key for the private key. Then, we unwrap the private key itself. Relies on the caller, who presumably knows the public key, to add the result to the cache. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AccessDeniedException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_gone_exception.html" title="Informative subclass of IOException to be thrown when content is expected, but GONE...">ContentGoneException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70631f2cc0ed483acb277c2cbe07aa34"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getPrivateKeyObject" ref="a70631f2cc0ed483acb277c2cbe07aa34" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.io.content.KeyDirectory.getPrivateKeyObject </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_gone_exception.html">ContentGoneException</a>, IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the private key object, if one exists as a wrapped key object. </p>
<p>Does not check to see if we have a private key block; simply sends a request for it (saves the requirement to do enumeration). Callers should check available() on the result to see if we actually got one. In general, callers will know whether one should exist or not. hasPrivateKeyBlock can be used to test (after enumeration) whether one exists if you don't know. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_gone_exception.html" title="Informative subclass of IOException to be thrown when content is expected, but GONE...">ContentGoneException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa2a1a1e05b49223a9c16cedbcb627ca"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getSupersededWrappedKey" ref="aaa2a1a1e05b49223a9c16cedbcb627ca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.io.content.KeyDirectory.getSupersededWrappedKey </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>We have several choices for how to represent superseded and previous keys. </p>
<p>Ignoring for now the case where we might have to have more than one per key directory (e.g. if we represent removal of several interposed ACLs), we could have the wrapped key block stored in the superseded block location, and the previous key block be a link, or the previous key block be a wrapped key and the superseded location be a link. Or we could store wrapped key blocks in both places. Because the wrapped key blocks can contain the name of the key that wrapped them (but not the key being wrapped), they are in essence a pointer forward to the replacing key. So, the superseded block, if it contains a wrapped key, is both a key and a link. If the block was stored at the previous key, it would not be both a key and a link, as its wrapping key is indicated by where it is. So it should indeed be a link -- except in the case of an interposed ACL, where there is nothing to link to; and it instead stores a wrapped key block containing the effective node key that was the previous key. This method checks for the existence of a superseded block. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e88b2b7596265d2e52b85e308b85c4b"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getUnwrappedKey" ref="a7e88b2b7596265d2e52b85e308b85c4b" args="(byte[] expectedKeyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key org.ccnx.ccn.io.content.KeyDirectory.getUnwrappedKey </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>expectedKeyID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws InvalidKeyException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, IOException, NoSuchAlgorithmException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unwrap and return the key wrapped in a wrapping key specified by its digest. </p>
<p>Find a copy of the key block in this directory that we can unwrap (either the private key wrapping key block or a wrapped raw symmetric key). Chase superseding keys if we have to. This mechanism should be generic, and should work for node keys as well as private key wrapping keys in directories following this structure. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a767ae095ec17bb5ce9ebda35883a0655"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getWrappedKey" ref="a767ae095ec17bb5ce9ebda35883a0655" args="(ContentName wrappedKeyName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.io.content.KeyDirectory.getWrappedKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>wrappedKeyName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the wrapped key object corresponding to the specified wrapped key name. </p>
<p>We know there is only one version of this object, so avoid getLatestVersion. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrappedKeyName</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae5381a02cd880fae2e36e1cd3fab4f9"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getWrappedKeyForKeyID" ref="aae5381a02cd880fae2e36e1cd3fab4f9" args="(byte[] keyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.io.content.KeyDirectory.getWrappedKeyForKeyID </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>keyID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the wrapped key object corresponding to a public key specified by its digest. </p>
<p>Up to caller to decide when this is reasonable to call; should call available() on result. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyID</em>&nbsp;</td><td>the digest of the specified public key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the corresponding wrapped key object. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3b7265afcf8e99f0c62f12555d56e43"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::getWrappedKeyNameForKeyID" ref="aa3b7265afcf8e99f0c62f12555d56e43" args="(byte[] keyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.io.content.KeyDirectory.getWrappedKeyNameForKeyID </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>keyID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the wrapped key name for a public key specified by its digest. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyID</em>&nbsp;</td><td>the digest of the public key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the corresponding wrapped key name. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b0e4c5e9345b924acc63e92d3e0e0ad"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::hasPreviousKeyBlock" ref="a3b0e4c5e9345b924acc63e92d3e0e0ad" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.content.KeyDirectory.hasPreviousKeyBlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for the existence of a previous key block. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1cfafe64a2b2f90665176d24b4e9e34e"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::hasPrivateKeyBlock" ref="a1cfafe64a2b2f90665176d24b4e9e34e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.content.KeyDirectory.hasPrivateKeyBlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>We store a private key as a single block wrapped under a nonce key, which is then wrapped under the public keys of various principals. </p>
<p>The <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key.html" title="A representation of wrapped (encrypted) keys for strorage in CCN.">WrappedKey</a> structure would allow us to do this (wrap private in public) in a single object, with an inline nonce key, but this option is more efficient. Checks for the existence of a private key block </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f5fb870d06ff2010db6cd029b688b14"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::hasResult" ref="a1f5fb870d06ff2010db6cd029b688b14" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.content.KeyDirectory.hasResult </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subclasses should override this test to answer true if waiters should break out of a waitForNoUpdatesOrResult loop. </p>
<p>Note that results must be cleared manually using clearResult. Default behavior always returns false. Subclasses probably want to set a variable in processNewChildren that will be read here. </p>

<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#af593f0d16a23fc8b8488487e6fce7c81">org.ccnx.ccn.profiles.nameenum.EnumeratedNameList</a>.</p>

</div>
</div>
<a class="anchor" id="a1a964a9e10ebfebc72d62121d3cab52a"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::hasSupersededBlock" ref="a1a964a9e10ebfebc72d62121d3cab52a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.content.KeyDirectory.hasSupersededBlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for the existence of a superseded block. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html" title="IOException type to indicate when a given NetworkObject has not yet retrieved its...">ContentNotReadyException</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3db09cbfc4af2b2daed36840f3abbcc8"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::initialize" ref="a3db09cbfc4af2b2daed36840f3abbcc8" args="(boolean startEnumerating)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.content.KeyDirectory.initialize </td>
          <td>(</td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>startEnumerating</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>We don't start enumerating until we get here. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_principal_key_directory.html#a532c3e6bcbbbbb74604380aab0ec12b2">org.ccnx.ccn.profiles.security.access.group.PrincipalKeyDirectory</a>.</p>

</div>
</div>
<a class="anchor" id="a45969d2265e2d99ef0acb495a510acb8"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::isPrivateKeyInCache" ref="a45969d2265e2d99ef0acb495a510acb8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.content.KeyDirectory.isPrivateKeyInCache </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the private key is in the secure key cache. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e072833bc839bd2a339ee4f8c6197b0"></a><!-- doxytag: member="org::ccnx::ccn::io::content::KeyDirectory::unwrapKeyViaCache" ref="a0e072833bc839bd2a339ee4f8c6197b0" args="(byte[] keyIDOfCachedKeytoUse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key org.ccnx.ccn.io.content.KeyDirectory.unwrapKeyViaCache </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>keyIDOfCachedKeytoUse</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, IOException, InvalidKeyException, NoSuchAlgorithmException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fast path -- once we have an idea which of our keys will unwrap this key, get it. </p>
<p>Can be called after enumeration, or if we have a guess of what key to use. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyIDOfCachedKeytoUse</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/io/content/KeyDirectory.java</li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Feb 4 11:58:59 2013 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>

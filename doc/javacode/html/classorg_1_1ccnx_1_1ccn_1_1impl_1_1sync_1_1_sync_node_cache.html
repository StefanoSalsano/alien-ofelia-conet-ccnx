<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Content-Centric Networking in Java: org.ccnx.ccn.impl.sync.SyncNodeCache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<a class="el" href="namespaceorg_1_1ccnx_1_1ccn_1_1impl.html">impl</a>.<b>sync</b>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache.html">SyncNodeCache</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.impl.sync.SyncNodeCache Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::impl::sync::SyncNodeCache" -->
<p>Nodes can be cached by hash across different comparators.  
<a href="#_details">More...</a></p>

<p><a href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache_1_1_pending.html">Pending</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This mechanism is used to avoid requesting the same node more than once (see below).  <a href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache_1_1_pending.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache.html#a7e6f8d0e22bc19806be7eb84d3a65344">putNode</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_sync_node_composite.html">SyncNodeComposite</a> node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put a newly decoded node into the cache.  <a href="#a7e6f8d0e22bc19806be7eb84d3a65344"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_sync_node_composite.html">SyncNodeComposite</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache.html#a67369c227b398a3dfe57ac81fb0fb79a">getNode</a> (byte[] hash)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a node associated with a hash if there is one.  <a href="#a67369c227b398a3dfe57ac81fb0fb79a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache_1_1_pending.html">Pending</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache.html#abbd1237aaeb91a76148b90e2878a6628">pending</a> (byte[] hash)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Activate the mechanism to avoid multiple requests for the same node and to wait for a node in the process of being fetched by another comparator if it is.  <a href="#abbd1237aaeb91a76148b90e2878a6628"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache.html#acd51fa54b8c3f502eb6e1ae28de4f3d6">clearPending</a> (byte[] hash)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this after a node has been returned.  <a href="#acd51fa54b8c3f502eb6e1ae28de4f3d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache.html#ab1ac57a0ddeb4e9f445f00fe0f7b827c">wakeupPending</a> (byte[] hash)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wakeup waiters but leave lock pending.  <a href="#ab1ac57a0ddeb4e9f445f00fe0f7b827c"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeacb2a54c733b3a7b7715499696daada"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SyncNodeCache::_nodes" ref="aeacb2a54c733b3a7b7715499696daada" args="" -->
HashMap&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_hash_entry.html">SyncHashEntry</a>, <br class="typebreak"/>
WeakReference<br class="typebreak"/>
&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_sync_node_composite.html">SyncNodeComposite</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>_nodes</b> = new HashMap&lt;<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_hash_entry.html">SyncHashEntry</a>, WeakReference&lt;<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_sync_node_composite.html">SyncNodeComposite</a>&gt;&gt;()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Nodes can be cached by hash across different comparators. </p>
<p>We use WeakReferences to avoid accidentally caching nodes that no longer have any real referents.</p>
<p>Since we only need to request nodes once per slice, the pending mechanism should be global </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="acd51fa54b8c3f502eb6e1ae28de4f3d6"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SyncNodeCache::clearPending" ref="acd51fa54b8c3f502eb6e1ae28de4f3d6" args="(byte[] hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.sync.SyncNodeCache.clearPending </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>hash</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this after a node has been returned. </p>
<p>It releases the semaphore (allowing waiters to continue) and removes the entry from the array of pending node requests </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hash</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67369c227b398a3dfe57ac81fb0fb79a"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SyncNodeCache::getNode" ref="a67369c227b398a3dfe57ac81fb0fb79a" args="(byte[] hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_sync_node_composite.html">SyncNodeComposite</a> org.ccnx.ccn.impl.sync.SyncNodeCache.getNode </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>hash</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a node associated with a hash if there is one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hash</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="abbd1237aaeb91a76148b90e2878a6628"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SyncNodeCache::pending" ref="abbd1237aaeb91a76148b90e2878a6628" args="(byte[] hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1sync_1_1_sync_node_cache_1_1_pending.html">Pending</a> org.ccnx.ccn.impl.sync.SyncNodeCache.pending </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>hash</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Activate the mechanism to avoid multiple requests for the same node and to wait for a node in the process of being fetched by another comparator if it is. </p>
<p>This is a "get and set" routine which creates and stores a lock for sharing if one hasn't already been created for this hash. The caller must acquire or attempt to acquire the lock. The first caller should request the node and notify waiters when it has it. Subsequent callers will wait for the node to return by acquiring the lock.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hash</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Lock object for waiting for the node </dd></dl>

</div>
</div>
<a class="anchor" id="a7e6f8d0e22bc19806be7eb84d3a65344"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SyncNodeCache::putNode" ref="a7e6f8d0e22bc19806be7eb84d3a65344" args="(SyncNodeComposite node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.sync.SyncNodeCache.putNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_sync_node_composite.html">SyncNodeComposite</a>&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put a newly decoded node into the cache. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1ac57a0ddeb4e9f445f00fe0f7b827c"></a><!-- doxytag: member="org::ccnx::ccn::impl::sync::SyncNodeCache::wakeupPending" ref="ab1ac57a0ddeb4e9f445f00fe0f7b827c" args="(byte[] hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.sync.SyncNodeCache.wakeupPending </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>hash</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wakeup waiters but leave lock pending. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hash</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/impl/sync/SyncNodeCache.java</li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Feb 4 11:58:57 2013 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
